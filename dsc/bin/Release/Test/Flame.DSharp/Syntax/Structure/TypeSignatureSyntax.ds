using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.DSharp.Build;
using Flame.DSharp.Lexer;

namespace Flame.Syntax.DSharp
{
    public class TypeSignatureSyntax : ISignatureSyntax, IRelevantSyntax<Token>
    {
        public const this(set ISignatureSyntax SignatureSyntax, set Token Colon, set IEnumerable<ITypeSyntax> BaseTypes)
        {
            this.GenericConstraints = new GenericConstraintSyntax[0];
        }
        public const this(set ISignatureSyntax SignatureSyntax, set Token Colon, set IEnumerable<ITypeSyntax> BaseTypes, set IEnumerable<GenericConstraintSyntax> GenericConstraints);
        public const this(ISignatureSyntax CommonSignatureSyntax)
        {
            this.SignatureSyntax = CommonSignatureSyntax;
            this.BaseTypes = new ITypeSyntax[0];
            this.GenericConstraints = new GenericConstraintSyntax[0];
        }

        public ISignatureSyntax SignatureSyntax { const get; private set; }
        public Token Colon { const get; private set; }
        public IEnumerable<ITypeSyntax> BaseTypes { const get; private set; }
        public IEnumerable<GenericConstraintSyntax> GenericConstraints { const get; private set; }
        public bool IsOperator { const get return false; }
        
        public IEnumerable<Token> LeadingTrivia
        {
        	const get
        	{
        		List<Token> tokens = new List<Token>();
				foreach (var item in SignatureSyntax.Attributes)
					tokens.AddRange(item.GetAllTrivia());
				foreach (var item in SignatureSyntax.ModifierTokens)
					tokens.AddRange(item.GetAllTrivia());
				tokens.AddRange(SignatureSyntax.TypeSyntax.GetAllTrivia());
				tokens.AddRange(SignatureSyntax.NameToken.GetAllTrivia());
				foreach (var item in SignatureSyntax.GenericDeclarations)
					tokens.AddRange(item.GetAllTrivia());
				tokens.AddRange(Colon.GetAllTrivia());
				foreach (var item in BaseTypes)
					tokens.AddRange(item.GetAllTrivia());
				foreach (var item in GenericConstraints)
					tokens.AddRange(item.GetAllTrivia());
				return tokens;
        	}
        }
        public IEnumerable<Token> TrailingTrivia { const get return (IEnumerable<Token>)new Token[0]; }

        public IEnumerable<IAttributeSyntax> Attributes
        {
            const get { return SignatureSyntax.Attributes; }
        }

        public IEnumerable<Token> ModifierTokens
        {
            const get { return SignatureSyntax.ModifierTokens; }
        }

        public IEnumerable<IGenericParameterDeclarationSyntax> GenericDeclarations
        {
            const get { return SignatureSyntax.GenericDeclarations; }
        }

        public ITypeSyntax TypeSyntax
        {
            const get { return SignatureSyntax.TypeSyntax; }
        }

        public Token NameToken
        {
            const get { return SignatureSyntax.NameToken; }
        }

        public const CodeBuilder GetCode()
        {
            var cb = SignatureSyntax.GetCode();
            bool first = true;
            foreach (var item in this.BaseTypes)
            {
            	if (first)
             	{
                	cb.Append(Colon.ToString());
                	first = false;
               	}
               	else
               	{
                	cb.Append(",");
                }
               	cb.Append(item.GetCode());
	        }
            foreach (var item in GenericConstraints)
            {
                cb.Append(item.GetCode());
            }
            return cb;
        }
    }
}