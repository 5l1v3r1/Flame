using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Binding
{
    public class LocalNamespaceBinder : BinderBase, ILocalNamespaceBinder
    {
        public this(set IBinder Binder, set INamespace CurrentNamespace)
        {
        	this.State = new NamespaceState();
        }
        public this(set IBinder Binder, set INamespace CurrentNamespace, set NamespaceState State);

        private INamespace currentNs;
        public INamespace CurrentNamespace
        {
            const get
            {
                return currentNs;
            }
            private set
            {
                currentNs = value;
                localNs = null;
            }
        }
        public NamespaceState State { const get; private set; }
        public IBinder Binder { const get; private set; }

        public void UseNamespace(string Namespace)
        {
        	State.UsingNamespaces.Add(Namespace);
        }

        public void MapNamespace(string Key, string Namespace)
        {
        	State.MappedNamespaces[Key] = Namespace;
        }

        private string[] localNs;
        protected string[] LocalNamespaces
        {
            const get
            {
                if (localNs == null)
                {
                	if (CurrentNamespace == null)
                	{
                		localNs = new string[0];
                	}
                	else
                	{
	                    var fullName = CurrentNamespace.FullName;
	                    string[] split = fullName.Split(new char[] { '.' });
	                    StringBuilder sb = new StringBuilder();
	                    string[] ns = new string[split.Length];
	                    for (int i = 0; i < split.Length; i++)
	                    {
	                        if (i > 0)
	                        {
	                            sb.Append('.');
	                        }
	                        sb.Append(split[i]);
	                        ns[i] = sb.ToString();
	                    }
	                    localNs = ns;
                    }
                }
                return localNs;
            }
        }
        
        public override IEnvironment Environment : BinderBase.Environment { const get return Binder.Environment; }

        public override IType BindTypeCore(string Name)
        {
            IType type = Binder.BindType(Name);
            if (type != null)
            {
                return type;
            }
            string[] splitName = Name.Split(new char[] { '.' });
            if (State.MappedNamespaces.ContainsKey(Enumerable.First<string>((IEnumerable<string>)splitName)))
            {
                string newName = ToTypeName(LocalNamespaceBinder.ConcatArrays<string>(new string[] { State.MappedNamespaces[splitName[0]] }, LocalNamespaceBinder.SubArray<string>(splitName, 1)));
                type = Binder.BindType(newName);
                if (VerifyMatch(type))
                {
                    return type;
                }
            }
            foreach (var item in UsingNamespaces)
            {
                string newName = ToTypeName(LocalNamespaceBinder.ConcatArrays<string>(new string[] { item }, splitName));
                type = Binder.BindType(newName);
                if (VerifyMatch(type))
                {
                    return type;
                }
            }
            return null;
        }

        #region Match Verification

        protected bool VerifyMatch(IType Type)
        {
            if (Type == null)
            {
                return false;
            }
            else
            {
                var accessModifier = Type.Access;
                if (accessModifier == AccessModifier.Assembly)
                	return VerifyAssemblyType(Type);
                else if (accessModifier == AccessModifier.Protected)
                	return VerifyProtectedType(Type);
                else if (accessModifier == AccessModifier.ProtectedAndAssembly)
                	return VerifyAssemblyType(Type) && VerifyProtectedType(Type);
                else if (accessModifier == AccessModifier.ProtectedOrAssembly)
                	return VerifyAssemblyType(Type) || VerifyProtectedType(Type);
                else if (accessModifier == AccessModifier.Private)
                	return VerifyPrivateType(Type);
				else
					return true;
            }
        }

        protected bool VerifyPrivateType(IType Type)
        {
            if (!(CurrentNamespace is IType))
            {
                return false;
            }
            var declType = (IType)Type.DeclaringNamespace;
            if (declType != null)
            {
                if (declType.Equals(CurrentNamespace))
                {
                    return true;
                }
                else
                {
                    return VerifyPrivateType(declType);
                }
            }
            else
            {
                return false;
            }
        }

        protected bool VerifyProtectedType(IType Type)
        {
            if (!(CurrentNamespace is IType))
            {
                return false;
            }
            var declType = (IType)Type.DeclaringNamespace;
            if (declType != null)
            {
                if (declType.Is((IType)CurrentNamespace))
                {
                    return true;
                }
                else
                {
                    return VerifyPrivateType(declType);
                }
            }
            else
            {
                return false;
            }
        }

        protected bool VerifyAssemblyType(IType Type)
        {
            return CurrentNamespace.DeclaringAssembly.Equals(Type.DeclaringNamespace.DeclaringAssembly);
        }

        #endregion

        private static T[] SubArray<T>(T[] Elements, int StartPosition)
        {
            T[] newArray = new T[Elements.Length - StartPosition];
            for (int32 i = 0; i < newArray.Length; i++)
            {
                newArray[i] = Elements[i + StartPosition];
            }
            return newArray;
        }
        
        private static T[] ConcatArrays<T>(T[] First, T[] Second)
        {
        	int32 firstLength = First.Length;
        	T[] result = new T[firstLength + Second.Length];
        	for (int32 i = 0; i < firstLength; i++)
        	{
        		result[i] = First[i];
        	}
        	for (int32 i = 0; i < Second.Length; i++)
        	{
        		result[firstLength + i] = Second[i];
        	}
        	return result;
        }

        private static string ToTypeName(string[] Elements)
        {
            StringBuilder sb = new StringBuilder();
            for (int32 i = 0; i < Elements.Length; i++)
            {
                if (i != 0)
                {
                    sb.Append(".");
                }
                sb.Append(Elements[i]);
            }
            return sb.ToString();
        }

        public IEnumerable<string> UsingNamespaces
        {
            const get { return Enumerable.Concat<string>((IEnumerable<string>)LocalNamespaces, (IEnumerable<string>)State.UsingNamespaces); }
        }

        public IDictionary<string, string> MappedNamespaces
        {
            const get { return State.MappedNamespaces; }
        }

        public bool SupportsNamespaces
        {
            const get { return true; }
        }

        public override const IEnumerable<IType> GetTypes()
        {
            return Binder.GetTypes();
        }
    }
}