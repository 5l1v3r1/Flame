/// <summary>
/// Describes a generic read-only collection of items.
/// </summary>
/// <remarks>
/// To unify identical functionality across different collection-like ADTs, such as the table, list or sorted list, this interface is introduced.
/// ADTs such as these should inherit read-only collection functionality from this, rather than specifying their own version of said functionality.
/// Every read-only collection must implement the '__iter__' method in Python, as specified by the 'iterable<T>' base type.
/// Implementing this allows using the for loop statement on any read-only collection.
/// The exact contracts of 'iterable<T>' and '__iter__' are omitted here, as they are both platform-specific means of enabling a platform-agnostic pattern.
/// Instead, 'iterable<T>' is defined as a base type that supports the use of a for loop on the collection.
/// </remarks>
public interface IReadOnlyCollection<T> : [T]
{
	/// <summary>
	/// Gets the number of elements in the collection.
	/// </summary>
    /// <remarks>
    /// The Count property corresponds to the various length properties/getLength methods defined across collection-like ADTs.
    /// </remarks>
	int Count { const get; }
    
    /// <summary>
    /// Creates an iterator that iterates over every element in the collection.
    /// </summary>
    const [<T>] __iter__();
}

/// <summary>
/// Describes a generic collection that allows items to be added.
/// </summary>
public interface ICollection<T> : IReadOnlyCollection<T>
{
    /// <summary>
    /// Adds an item to the collection.
    /// </summary>
    /// <remarks>
    /// This method allows items to be added to a collection without knowledge of how the collection organizes itself.
    /// It does not specify where the item will be inserted, only that it will be inserted.
    /// </remarks>
    void Add(T Item);
}

/// <summary>
/// Describes a generic read-only, zero-based list.
/// </summary>
/// <remarks>
/// The read-only list is useful for scenarios where a read-only copy of the data contained in another ADT is to be provided.
/// For example, a sorted list implementation that uses the list ADT internally could return an alias of said list, rather than a copy, when a position-oriented list version of its data is requested.
/// If the return type of the 'ToList()' method of the sorted list would have been a list, the client could reliably change the internal representation of the sorted list's data, destroying the integrity of the carefully constructed state of the sorted list.
/// Because the return type is a read-only list, however, clients know they should not try to (and indeed do not have a reliable way to) change the list's state. This increases performance by removing unnecessary list copying without sacrificing encapsulation.
/// An extra requirement is that a read-only list implements the inherited base type 'iterable<T>' (from 'IReadOnlyCollection<T>') in a way that the item at the first index are iterated over in the order that they would be accessed by their indices: the item at index 0 should be indexed first, and the item at the end of the list should be indexed last.
/// </remarks>
public interface IReadOnlyList<T> : IReadOnlyCollection<T>
{
    /// <summary>
    /// Gets the item at the specified position in the list.
    /// </summary>
    /// <pre>
    /// Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    /// </pre>
    /// <post>
    /// If the index is a valid index in the linked list, the item at said index is returned.
    /// Otherwise, an exception is thrown.
    /// </post>
    T this[int Index] { const get; }
}

/// <summary>
/// Describes a generic list.
/// </summary>
/// <remarks>
/// This list ADT inherits the 'Add(in Item : T)' method from Collection, with the added requirement that items inserted through Add should be placed at the end of the list.
/// </remarks>
public interface IList<T> : IReadOnlyList<T>, ICollection<T>
{
	/// <summary>
	/// Inserts an item in the list at the specified position.
	/// </summary>
        /// <pre>
        /// Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
        /// </pre>
        /// <post>
        /// If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
        /// Otherwise, all items from the given index upward are shifted once to the right, and the provided item is inserted at the specified index in the list.
        /// </post>
	bool Insert(int Index, T Item);
    
    /// <summary>
    /// Removes the element at the specified index from the list.
    /// </summary>
    /// <pre>
    /// Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    /// </pre>
    /// <post>
    /// If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    /// Otherwise, the item at the specified index is removed and the index of all items whose index is greater than the provided index, will be decremented by one.
    /// </post>
    bool RemoveAt(int Index);
    
    /// <summary>
    /// Sets the item at the specified position in the list.
    /// </summary>
    /// <pre>
    /// Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    /// </pre>
    /// <post>
    /// If the index is a valid index in the linked list, the operation on said index is performed.
    /// Otherwise, an exception is thrown.
    /// </post>
    T this[int Index] { const get; set; }
}