/// <summary>
/// Describes an item in an open hash table.
/// </summary>
public class OpenHashtableItem<T>
{
    /// <summary>
    /// Creates a new item for use in an open hash table.
    /// </summary>
    public const this(set T Value, set bool IsEmpty);
    
    public bool IsEmpty;
    public T Value;
}

/// <summary>
/// Represents a hash table that uses open addressing.
/// </summary>
public class OpenHashtable<TKey, TValue> : ITable<TKey, TValue>
{
    /// <summary>
    /// Creates a new hash table, with the provided key map and probe sequence map.
    /// </summary>
    public const this(set IMap<TValue, TKey> KeyMap, set IMap<int, [int]> ProbeSequenceMap);
    
    /// <summary>
    /// Gets the record-to-key mapping function used by this hash table.
    /// </summary>
    public IMap<TValue, TKey> KeyMap { const get; private set; }
    
    /// <summary>
    /// Gets the open addressed hash table's hash key to probe sequence mapping function.
    /// </summary>
    public IMap<int, [int]> ProbeSequenceMap { const get; private set; }
    
    private int[] prime_list = new int[] 
    {
        31,        97,         
        389,       1543,       
        6151,      24593,      
        98317,     393241,     
        1572869,   6291469,    
        25165843,  100663319,  
        402653189, 1610612741
    };
    
    private OpenHashtableItem<TValue>[] values = new OpenHashtableItem<TValue>[prime_list[0]];
    
    /// <summary>
    /// Gets the table's capacity.
    /// </summary>
    private int Capacity { const get return values.Length; }
    
    /// <summary>
    /// Gets the number of items in the table.
    /// </summary>
    public int Count { const get; private set; }
    
    /// <summary>
    /// Gets a boolean value that indicates whether the table is empty or not.
    /// </summary>
    public bool IsEmpty { const get return Count == 0; }
    
    /// <summary>
    /// Gets the table's load factor.
    /// </summary>
    private double LoadFactor
    {
        const get
        {
            return (double)Count / Capacity;
        }
    }
    
    /// <summary>
    /// Gets the next prime in the prime list. If this prime is not available, -1 is returned.
    /// </summary>
    private const int GetNextPrime()
    {
        for (int i = 0; i < prime_list.Length - 1; i++)
        {
            if (prime_list[i] > Capacity)
                return prime_list[i];
        }
        return -1;
    }
    
    /// <summary>
    /// Tries to resize the table to the next prime and re-hashes every element.
    /// </summary>
    private void ResizeTable()
    {
        int nextPrime = GetNextPrime();
        if (nextPrime > -1)
        {
            var oldValues = values;
            this.values = new OpenHashtableItem<TValue>[nextPrime];
            this.Count = 0;
            foreach (var item in oldValues)
            {
                if (item != null && !item.IsEmpty)
                {
                    this.Insert(item.Value);
                }
            }
        }
    }
    
    private OpenHashtableItem<TValue> FindOpenItem(TKey Key)
    {
        int hashCode = hash(Key);
        var seq = ProbeSequenceMap.Map(hashCode);
        foreach (int index in seq)
        {
            int i = index % Capacity;
            if (IsOpen(i))
            {
                if (values[i] == null)
                {
                    values[i] = new OpenHashtableItem<TValue>(default(TValue), true);
                }
                return values[i];
            }
            else if (KeyMap.Map(values[i].Value) == Key)
            {
                return null;
            }
        }
    }
    
    /// <summary>
    /// Finds out if the position at the given index is open.
    /// </summary>
    private bool IsOpen(int Index)
    {
        return values[Index] == null || values[Index].IsEmpty;
    }
    
    public bool Insert(TValue Item)
    {
        var key = KeyMap.Map(Item);
        var openItem = FindOpenItem(key);
        if (openItem == null) return false;
        else
        {
            Count++;
            openItem.Value = Item;
            openItem.IsEmpty = false;
            if (LoadFactor > .75)
                ResizeTable();
            return true;
        }
    }
    
    public TValue this[TKey Key]
    {
        const get
        {
            int hashCode = hash(Key);
            var seq = ProbeSequenceMap.Map(hashCode);
            foreach (int index in seq)
            {
                int i = index % Capacity;
                if (values[i] == null) // item is not in table
                    return default(TValue);
                else if (!values[i].IsEmpty && KeyMap.Map(values[i].Value) == Key)
                    return values[i].Value;
            }
        }
    }
    
    public bool ContainsKey(TKey Key)
    {
        return this[Key] != default(TValue);
    }
    
    public bool Remove(TKey Key)
    {
        int hashCode = hash(Key);
        var seq = ProbeSequenceMap.Map(hashCode);
        foreach (int index in seq)
        {
            int i = index % Capacity;
            if (values[i] == null) // item is not in table
            {
                return false;
            }
            else if (!values[i].IsEmpty && KeyMap.Map(values[i].Value) == Key)
            {
                values[i].IsEmpty = true;
                Count--;
                return true;
            }
        }
    }
    
    public const [<TValue>] __iter__()
    {
        foreach (var item in values)
        {
            if (item != null && !item.IsEmpty)
                yield return item.Value;
        }
    }
    
    public const IReadOnlyList<TValue> ToList()
    {
        var results = new ArrayList<TValue>();
        foreach (var item in values)
        {
            if (item != null && !item.IsEmpty)
                results.Add(item.Value);
        }
        return results;
    }
}