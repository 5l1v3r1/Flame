/// <summary>
/// A sorted list whose backing list can be swapped. It is the sorted equivalent of 'SwapList<T>'
/// </summary>
public class SortedSwapList<T> : ISortedList<T>
{
    /// <summary>
    /// Creates a new sorted swap list with the specified backing list.
    /// </summary>
    public const this(set ISortedList<T> backingList);

    private ISortedList<T> backingList;
    
    public IMap<T, object> KeyMap { const get return backingList.KeyMap; }
    
    /// <summary>
    /// Swaps the sorted swap list's backing container with another backing list.
    /// </summary>
    /// <pre>
    /// 'Container' should be empty. If not, it will be cleared.
    /// </pre>
    /// <post>
    /// The container is cleared. 
    /// Then, all items in the current backing list are copied to 'Container'.
    /// After that, the backing list of this sorted swap list is set to 'Container'.
    /// </post>
    public void Swap(ISortedList<T> Container)
    {
        var preItems = Container.ToList();
        for (int i = 0; i < preItems.Count; i++)
            Container.Remove(preItems[i]);
        var items = backingList.ToList();
        BinaryCopy(items, Container, 0, items.Count);
        this.backingList = Container;
    }
    
    /// <summary>
    /// A recursive algorithm that copies all items from a read-only list to the given target list.
    /// This is intended to maximize performance when switching to a backing sorted list implemented by a binary tree.
    /// </summary>
    private void BinaryCopy(IReadOnlyList<T> Source, ISortedList<T> Target, int StartIndex, int Count)
    {
        if (Count > 0)
        {
            int mid = StartIndex + Count / 2;
            Target.Add(Source[mid]);
            int leftCount = mid;
            BinaryCopy(Source, Target, StartIndex, leftCount);
            int rightCount = StartIndex + Count - mid - 1;
            BinaryCopy(Source, Target, mid + 1, rightCount);
        }
    }
    
    public bool IsEmpty { const get return backingList.IsEmpty; }
    public int Count { const get return backingList.Count; }
    
    public void Add(T Item)
    {
        backingList.Add(Item);
    }
    
    public bool Remove(T Item)
    {
        return backingList.Remove(Item);
    }
    
    public const bool Contains(T Item)
    {
        return backingList.Contains(Item);
    }
    
    public const IReadOnlyList<T> ToList()
    {
        return backingList.ToList();
    }
    
    public const [<T>] __iter__()
    {
        return backingList.__iter__();
    }
}