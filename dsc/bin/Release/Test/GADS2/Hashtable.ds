/// <summary>
/// Represents a hash table that uses separate chaining.
/// </summary>
public class Hashtable<TKey, TValue> : ITable<TKey, TValue>
{
    /// <summary>
    /// Creates a new hash table, from the provided key map and the bucket table factory.
    /// </summary>
    /// <remarks>
    /// 'BucketFactory' of type 'IFactory<ITable<TKey, TValue>, IMap<TValue, TKey>>' is a factory that creates instances of 'ITable<TKey, TValue>' when provided an argument of type 'IMap<TValue, TKey>'.
    /// Essentially, it creates new buckets, which are themselves tables, from a key-value map.
    /// </remarks>
    public const this(set IMap<TValue, TKey> KeyMap, set IFactory<ITable<TKey, TValue>, IMap<TValue, TKey>> BucketFactory)
    {
        this.buckets = new ITable<TKey, TValue>[prime_list[0]];
    }
    
    /// <summary>
    /// Gets the record-to-key mapping function used by this hash table.
    /// </summary>
    public IMap<TValue, TKey> KeyMap { const get; private set; }
    
    /// <summary>
    /// Gets the factory that is used to create new buckets for this hash table.
    /// </summary>
    public IFactory<ITable<TKey, TValue>, IMap<TValue, TKey>> BucketFactory { const get; private set; }

    public int Count
    {
        const get
        {
            int result = 0;
            foreach (var item in buckets)
            if (item != null)
            {
                result += item.Count;
            }
            return result;
        }
    }

    public bool IsEmpty
    {
        const get
        {
            foreach (var item in buckets)
            if (item != null && item.Count > 0)
            {
                return false;
            }
            return true;
        }
    }
    
    /// <summary>
    /// Gets the number of buckets in the table.
    /// </summary>
    private int BucketCapacity { const get return buckets.Length; }
    
    private int BucketCount = 0;
    
    /// <summary>
    /// Gets the bucket load factor.
    /// </summary>
    private double BucketLoadFactor
    {
        const get
        {
            return (double)BucketCount / BucketCapacity;
        }
    }
    
    private int[] prime_list = new int[] 
    {
        31,        97,         
        389,       1543,       
        6151,      24593,      
        98317,     393241,     
        1572869,   6291469,    
        25165843,  100663319,  
        402653189, 1610612741
    };
    
    /// <summary>
    /// Gets the next prime in the prime list. If this prime is not available, -1 is returned.
    /// </summary>
    private const int GetNextPrime()
    {
        for (int i = 0; i < prime_list.Length - 1; i++)
        {
            if (prime_list[i] > BucketCapacity)
                return prime_list[i];
        }
        return -1;
    }
    
    /// <summary>
    /// Tries to resize the table to the next prime and re-hashes every element.
    /// </summary>
    private void ResizeTable()
    {
        int nextPrime = GetNextPrime();
        if (nextPrime > -1)
        {
            var oldBuckets = buckets;
            this.buckets = new ITable<TKey, TValue>[nextPrime];
            this.BucketCount = 0;
            foreach (var bucket in oldBuckets)
            {
                if (bucket != null)
                {
                    foreach (TValue item in bucket)
                    {
                        this.Insert(item);
                    }
                }
            }
        }
    }
    
    private ITable<TKey, TValue>[] buckets;
    
    /// <summary>
    /// Gets the bucket for items with the given hash code.
    /// </summary>
    private const ITable<TKey, TValue> GetBucket(int HashCode)
    {
        int index = HashCode % BucketCapacity;
        var bucket = buckets[index];
        return bucket;
    }
    
    /// <summary>
    /// Deletes the bucket with the provided hash code.
    /// </summary>
    private void DeleteBucket(int HashCode)
    {
        int index = HashCode % BucketCapacity;
        buckets[index] = null;
        BucketCount--;
    }
    
    /// <summary>
    /// Gets the bucket for items with the given hash code or creates a new one, if necessary.
    /// </summary>
    private ITable<TKey, TValue> GetNewBucket(int HashCode)
    {
        int index = HashCode % BucketCapacity;
        var bucket = buckets[index];
        if (bucket == null)
        {
            BucketCount++;
            
            bucket = BucketFactory.Create(KeyMap);
            buckets[index] = bucket;
        }
        return bucket;
    }
    
    /// <summary>
    /// Finds an item in the given bucket with the given key.
    /// </summary>
    private const TValue FindInBucket(ITable<TKey, TValue> Bucket, TKey Key)
    {
        if (Bucket == null)
            return default(TValue);
        return Bucket[Key];
    }
    
    /// <summary>
    /// Finds out if a bucket contains the given key.
    /// </summary>
    private const bool BucketContainsKey(ITable<TKey, TValue> Bucket, TKey Key)
    {
        return FindInBucket(Bucket, Key) != default(TValue);
    }
    
    /// <summary>
    /// Gets a boolean value that indicates if the hash table contains the given key.
    /// </summary>
    public const bool ContainsKey(TKey Key)
    {
        return BucketContainsKey(GetBucket(hash(Key)), Key);
    }
    
    /// <summary>
    /// Inserts an item in the hash table.
    /// </summary>
    public bool Insert(TValue Item)
    {
        var key = KeyMap.Map(Item);
        int hashCode = hash(key);
        var bucket = GetNewBucket(hashCode);
        if (BucketContainsKey(bucket, key))
        {
            return false;
        }
        bucket.Insert(Item);
        if (BucketLoadFactor > .75)
            ResizeTable();
        return true;
    }
    
    public bool Remove(TKey Key)
    {
        int hashCode = hash(Key);
        var bucket = GetBucket(hashCode);
        if (bucket == null)
            return false;
        
        bool result = bucket.Remove(Key);
        if (bucket.Count == 0)
        {
            DeleteBucket(hashCode);
        }
        return result;
    }
    
    public TValue this[TKey Key] 
    { 
        const get
        {
            var bucket = GetBucket(hash(Key));
            return FindInBucket(bucket, Key);
        }
    }
    
    public const [<TValue>] __iter__()
    {
        foreach (var bucket in buckets)
        if (bucket != null)
        foreach (TValue item in bucket)
            yield return item;
    }
    
    public const IReadOnlyList<TValue> ToList()
    {
        var results = new ArrayList<TValue>();
        foreach (var bucket in buckets)
        if (bucket != null)
        foreach (TValue item in bucket)
        {
            results.Add(item);
        }
        return results;
    }
}