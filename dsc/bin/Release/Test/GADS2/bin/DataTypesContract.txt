// ===========================
// Jonathan Van der Cruysse
// Informatica Ba 1
// Data type contracts
// ===========================

class IReadOnlyCollection<T>
// Describes a generic read-only collection of items.
// Remarks:
// To unify identical functionality across different collection-like ADTs, such as the table, list or sorted list, this interface is introduced.
// ADTs such as these should inherit read-only collection functionality from this, rather than specifying their own version of said functionality.
{

    property Count
    {

        +get() : integer { query }
        // Gets the number of elements in the collection.

    }

}

class ICollection<T> : IReadOnlyCollection<T>
// Describes a generic collection that allows items to be added.
{

    +Add(in Item : T)
    // Adds an item to the collection.
    // Remarks:
    // This method allows items to be added to a collection without knowledge of how the collection organizes itself.
    // It does not specify where the item will be inserted, only that it will be inserted.

}

class IReadOnlyList<T> : IReadOnlyCollection<T>
// Describes a generic read-only list.
// Remarks:
// The read-only list is useful for scenarios where a read-only copy of the data contained in another ADT is to be provided.
// For example, a sorted list implementation that uses the list ADT internally could return an alias of said list, rather than a copy, when a position-oriented list version of its data is requested.
// If the return type of the 'ToList()' method of the sorted list would have been a list, the client could reliably change the internal representation of the sorted list's data, destroying the integrity of the carefully constructed state of the sorted list.
// Because the return type is a read-only list, however, clients know they should not try to (and indeed do not have a reliable way to) change the list's state.
// This increases performance by removing unnecessary list copying without sacrificing encapsulation.
{

    indexer
    {

        +get(in Index : integer) : T { query }
        // Gets the item at the specified position in the list.
        // Pre:
        // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
        // Post:
        // If the index is a valid index in the linked list, the item at said index is returned.
        // Otherwise, an exception is thrown.

    }

}

class IList<T> : IReadOnlyList<T>, ICollection<T>
// Describes a generic list.
// Remarks:
// This list ADT inherits the 'Add(in Item : T)' method from Collection, with the added requirement that items inserted through Add should be placed at the end of the list.
{

    indexer
    {

        +get(in Index : integer) : T { query }
        // Gets the item at the specified position in the list.
        // Pre:
        // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
        // Post:
        // If the index is a valid index in the linked list, the operation on said index is performed.
        // Otherwise, an exception is thrown.

        +set(in Index : integer, in value : T)
        // Sets the item at the specified position in the list.
        // Pre:
        // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
        // Post:
        // If the index is a valid index in the linked list, the operation on said index is performed.
        // Otherwise, an exception is thrown.

    }

    +Insert(in Index : integer, in Item : T) : boolean
    // Inserts an item in the list at the specified position.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, all items from the given index upward are shifted once to the right, and the provided item is inserted at the specified index in the list.

    +RemoveAt(in Index : integer) : boolean
    // Removes the element at the specified index from the list.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, the item at the specified index is removed and the index of all items whose index is greater than the provided index, will be decremented by one.

}

class IRecord<T>
// Describes a generic record.
{

    property Key
    {

        +get() : T { query }
        // Gets the record's search key.

    }

}

class IMap<TSource, TTarget>
// Describes a map, an object that maps source values to their target representation.
// It is essentially a pure mathematical function.
// Remarks:
// This is mainly intended for use in sorting and dictionary purposes, where records are mapped to their keys.
{

    +Map(in Item : TSource) : TTarget { query }
    // Maps the item to its target representation.
    // Post:
    // This function must produce a constant return value, irrespective of external changes.

}

class ITable<TKey, TItem> : IReadOnlyCollection<TItem>
// Describes a slightly modified version of the table ADT.
// Remarks:
// TKey is the type of keys stored in the table, TItem is the type of items.
{

    indexer
    {

        +get(in Key : TKey) : TItem { query }
        // Retrieves the item in the table with the specified key.
        // Pre:
        // For this method to return an item in the table, rather than null, the key must be in the table, i.e.
        // ContainsKey(Key) must return true.
        // Post:
        // The return value of this method will be the item that corresponds with the key, or None, if it is not found.
        // It is recommended to check if the table contains the key by using ContainsKey.

    }

    +Insert(in Item : TItem) : boolean
    // Inserts an item into the table.
    // Post:
    // Returns true if item is successfully inserted, false if the table already contains an item with the same search key.

    +Remove(in Key : TKey) : boolean
    // Removes a key from the table.
    // Post:
    // This method returns true if the key is in the table, false if not.

    +ContainsKey(in Key : TKey) : boolean { query }
    // Finds out if the table contains the specified key.
    // Remarks:
    // The original table ADT does not specify this method.
    // It is added, however, to compensate for the lack of the 'success' out parameter when using the retrieve operation.

    +ToList() : IReadOnlyList<TItem> { query }
    // Gets the table's items as a read-only list.
    // Post:
    // This method returns a read-only list that describes the items in this table.
    // Modifications to this list are not allowed - it is read-only.
    // Furthermore, this list may be an alias to an internal list containing the table's items, or a copy.
    // This list need not be sorted, but must contain every item in the table.

}

class ISortableTable<TKey, TItem> : ITable<TKey, TItem>
// Describes a sortable table.
{

    +Sort()
    // Sorts the table's contents.
    // Pre:
    // The table must not be empty for this method to change the table's state.
    // Post:
    // The table's items will be sorted.
    // After sorting, the table's 'ToList()' method must return a list whose items are sorted.
    // If the table's state is modified after 'Sort()' is called, the list produced by 'ToList()' need no longer be sorted.

}

class ISortedList<T> : ICollection<T>
// Describes a modified version of the Sorted List ADT.
// Remarks:
// Design changes from the original ADT: Rather than allowing the client of sorted lists to access its items through an index, this sorted list uses the ToList() method.
// This change was introduced to improve efficiency for the common case, which is enumerating over the sorted list's items.
// Implementing 'void sortedRetrieve(int index, out T dataItem, out bool success)' would require an increasingly large number of nodes to be counted through inorder traversal before arriving at the desired element when enumerating over a sorted list with a naive binary tree implementation.
// Also, the 'int locatePosition(T anItem, out bool isPresent)' method has been removed, as this is essentially table functionality, and the position of an item cannot be retrieved unambiguously, since sorted lists may contain more than one item with the same search key. 'void sortedInsert(T anItem)' is handled by the inherited 'void Add(T Item)' method in ICollection<T>.
{

    property IsEmpty
    {

        +get() : boolean { query }
        // Gets a boolean value that indicates if the sorted list is empty.
        // Post:
        // Return true if empty, false if not.

    }

    +Remove(in Item : T) : boolean
    // Removes an item from the list.
    // Pre:
    // For Item to be successfully removed from the sorted list, it must have been in the list before removal.
    // Post:
    // Returns true if the sorted list contained the given item, false if not.
    // If this returns true, the item has been removed from the sorted list.

    +Contains(in Item : T) : boolean { query }
    // Finds out if the sorted list contains the given item.

    +ToList() : IReadOnlyList<T> { query }
    // Returns a read-only list that represents this list's contents, for easy enumeration.

}

class ArrayList<T> : IList<T>
// An array-based implementation of a list.
{

    +CreateArrayList() : ArrayList<T> { query }
    // Creates a new instance of a list.

    +CreateArrayList(in data : T[]) : ArrayList<T> { query }
    // Creates a new instance of a list backed by the provided array.

    property Count
    {

        +get() : integer { query }
        // Gets the number of elements in the collection.

    }

    indexer
    {

        +get(in Index : integer) : T { query }
        // Gets the item in the list at the specified position.

        +set(in Index : integer, in value : T)
        // Sets the item in the list at the specified position.

    }

    +Add(in Item : T)
    // Adds an item to the end of the list.

    +Insert(in Index : integer, in Item : T) : boolean
    // Inserts an item in the list at the specified position.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, all items from the given index upward are shifted once to the right, and the provided item is inserted at the specified index in the list.

    +RemoveAt(in Index : integer) : boolean
    // Removes the element at the specified index from the list.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, the item at the specified index is removed and the index of all items whose index is greater than the provided index, will be decremented by one.

    +CopyTo(in Target : T[])
    // Copies the array list's contents to the provided target array.
    // Post:
    // Copies all elements from the list, starting at index 0 up to and including the last index of this list or the target array, whichever comes first.

    +ToArray() : T[] { query }
    // Gets an array with length the number of elements in this list, and the same contents as this list.
    // Remarks:
    // The resulting array is not the backing array for this list, but rather an array whereto the elements of this list are copied.
    // This method was added to make copying an 'ArrayList<T>' easier.
    // Creating a new 'ArrayList<T>' from an array is also faster than creating an empty list and then adding every element from the original list, as the internal array will not need expanding.

}

class ListNode<T>
// Describes a node in a linked list.
// Remarks:
// This class provides low-level access to the internal workings of a linked list.
{

    +CreateListNode(in Value : T) : ListNode<T> { query }
    // Creates a new linked list node instance from the specified value.
    // Post:
    // Value will populate the linked list's Value property.

    property Tail
    {

        +get() : ListNode<T> { query }
        // Gets the "tail" node of this linked chain.
        // Post:
        // The tail of a list node is defined recursively as follows.
        // If the current node has no successor, return the current node.
        // Otherwise, return the current node's successor's tail.

    }

    property Value
    {

        +get() : T { query }
        // Gets the value contained in the list node.

        +set(in value : T)
        // Sets the value contained in the list node.

    }

    property Successor
    {

        +get() : ListNode<T> { query }
        // Gets the list node's successor node.
        // Post:
        // Gets the successor, if any.
        // Otherwise, returns None.

        +set(in value : ListNode<T>)
        // Sets the list node's successor node.
        // Pre and post:
        // Sets the list node's successor to value, which may be either None or a ListNode<T>.

    }

    +InsertAfter(in Value : T)
    // Inserts a node containing the provided value after this node.
    // Post:
    // Creates a new node containing the provided value, sets its successor to this node's successor, and sets this node's successor to the newly created node.
    // Remarks:
    // This operation corresponds to (part of) a list insert for linked lists.

}

class LinkedList<T> : IList<T>
// Describes a linked list.
// Remarks:
// This linked list type inherits all functionality from the list ADT, but also exposes raw linked list access for dedicated classes, which want a finer grain of control and performance than what is offered by the list ADT.
// Such a property may resemble a violation of the principle of access through an interface, but it is in fact not: the linked list instead defines its own, extended interface.
// Access to the linked list's contents adheres to object-oriented principles, and does not require any knowledge of implementation details.
// For example, invoking linked list-specific methods on a generic list is indeed not allowed, but invoking a linked list method on an object that was obtained through a method that publically broadcasts its return type to be a linked list, is allowed.
{

    +CreateLinkedList() : LinkedList<T> { query }
    // Creates an empty linked list.

    property Tail
    {

        +get() : ListNode<T> { query }
        // Gets the linked list's tail node.

    }

    property Count
    {

        +get() : integer { query }
        // Gets the number of elements in the collection.

    }

    indexer
    {

        +get(in Index : integer) : T { query }
        // Gets the item in the linked list at the given index.
        // Pre:
        // The index must be valid index within this linked list: it must be non-negative and less than the list's length, exposed by the Count property.
        // Post:
        // If the index is a valid index in the linked list, the operation on said index is performed.
        // Otherwise, an exception is thrown.

        +set(in Index : integer, in value : T)
        // Sets the item in the linked list at the given index.
        // Pre:
        // The index must be valid index within this linked list: it must be non-negative and less than the list's length, exposed by the Count property.
        // Post:
        // If the index is a valid index in the linked list, the operation on said index is performed.
        // Otherwise, an exception is thrown.

    }

    property Head
    {

        +get() : ListNode<T> { query }
        // Gets the linked list's head node.

        +set(in value : ListNode<T>)
        // Sets the linked list's head node.

    }

    +ToArray() : T[] { query }
    // Gets an array representation of this linked list.
    // Remarks:
    // This method was added to the 'LinkedList<T>' class to allow quick and easy O(n) iteration over its elements.
    // It goes without saying that this method should and can only be safely called if the 'LinkedList<T>' has been procured through a method that specifies its return value to be of said type.

    +NodeAt(in Index : integer) : ListNode<T> { query }
    // Gets the list node at the specified index.
    // Pre:
    // The index must be valid index within this linked list: it must be non-negative and less than the list's length, exposed by the Count property.
    // Post:
    // If the index is a valid index in the linked list, the node at said index is returned.
    // Otherwise, None is returned.

    +ItemAt(in Index : integer) : T { query }
    // Gets the item in the linked list at the given index.
    // Pre:
    // The index must be valid index within this linked list: it must be non-negative and less than the list's length, exposed by the Count property.
    // Post:
    // If the index is a valid index in the linked list, the item at said index is returned.
    // Otherwise, an exception is thrown.

    +Add(in Item : T)
    // Adds an item to the end of the linked list.
    // Pre:
    // Item is the item that will be inserted at the end of the list.
    // Post:
    // If the linked list has a head node, the item is inserted after the linked list's tail node.
    // Otherwise, a new head node containing Item is created, which coincidentally becomes this linked list's head.

    +RemoveAt(in Index : integer) : boolean
    // Removes the item in the linked list at the specified index.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, the item at the specified index is removed and the index of all items whose index is greater than the provided index, will be decremented by one.

    +Insert(in Index : integer, in Item : T) : boolean
    // Inserts an item in the list at the specified position.
    // Pre:
    // Index must be a valid index in the list: it must be non-negative and less than the list's length, as exposed by the Count property.
    // Post:
    // If the provided index was an invalid index in the list, the list's state is not changed, and false is returned.
    // Otherwise, all items from the given index upward are shifted once to the right, and the provided item is inserted at the specified index in the list.

}

class Stack<T> : IReadOnlyCollection<T>
// Represents a generic stack.
// Remarks:
// T is the type of item on the stack.
{

    +CreateStack() : Stack<T> { query }
    // Creates a new stack instance.

    +CreateStack(in dataContainer : IList<T>) : Stack<T> { query }
    // Creates a new stack instance that uses the specified list to store its data.

    property Count
    {

        +get() : integer { query }
        // Gets the number of items on the stack.

    }

    property IsEmpty
    {

        +get() : integer { query }
        // Gets a boolean value that indicates whether the stack is empty or not.

    }

    property Top
    {

        +get() : T { query }
        // Peeks at the item at the top of the stack, without removing it.
        // Pre:
        // The stack may not be empty.
        // Post:
        // If the stack was empty, None will be returned.

    }

    +Push(in Item : T)
    // Pushes an item on the stack.

    +Pop() : T
    // Pops the item at the top of the stack.
    // Pre:
    // The stack may not be empty.
    // Post:
    // If the stack was empty, the stack's state will not change, and None will be returned.

}

class Queue<T> : IReadOnlyCollection<T>
// Represents a generic queue.
// Remarks:
// T is the type of item in the queue.
{

    +CreateQueue() : Queue<T> { query }
    // Creates a new queue instance.

    +CreateQueue(in dataContainer : IList<T>) : Queue<T> { query }
    // Creates a new queue instance that uses the specified list to store its data.

    property Count
    {

        +get() : integer { query }
        // Gets the number of items on the queue.

    }

    property IsEmpty
    {

        +get() : integer { query }
        // Gets a boolean value that indicates whether the queue is empty or not.

    }

    property Front
    {

        +get() : T { query }
        // Peeks at the item at the top of the queue, without removing it.
        // Pre:
        // The queue may not be empty.
        // Post:
        // If the queue was empty, None will be returned.

    }

    +Enqueue(in Item : T)
    // Adds an item to the queue.

    +Dequeue() : T
    // Dequeues an item and returns it.
    // Pre:
    // The queue may not be empty.
    // Post:
    // If the queue was empty, the queue's state will not change, and None will be returned.

}

class BinaryTree<T>
// A link-based implementation of the Binary Tree ADT.
{

    +CreateBinaryTree(in Data : T) : BinaryTree<T> { query }
    // Creates a new binary tree from a data item.

    property Count
    {

        +get() : integer { query }
        // Gets the number of items in the binary tree.

    }

    property Data
    {

        +get() : T { query }
        // Gets the binary tree's data, i.e. the record contained in the root.

        +set(in value : T)
        // Sets the binary tree's data, i.e. the record contained in the root.

    }

    property Left
    {

        +get() : BinaryTree<T> { query }
        // Gets the binary tree's left subtree.

        +set(in value : BinaryTree<T>)
        // Sets the binary tree's left subtree.

    }

    property Right
    {

        +get() : BinaryTree<T> { query }
        // Gets the binary tree's right subtree.

        +set(in value : BinaryTree<T>)
        // Sets the binary tree's right subtree.

    }

    +TraverseInorder(in Target : ICollection<T>)
    // Performs inorder traversal on the binary tree and writes its items to the given target collection.

    +CopyFrom(in Other : BinaryTree<T>)
    // Copies all information in the given binary tree into this binary tree.
    // Pre:
    // Other must either be a 'BinaryTree<T>' or 'None'.
    // Post:
    // If the given tree is not 'None', the Data, Left and Right properties are copied from the target tree into this tree.
    // Note that these copies are shallow: the left and right trees (and possibly Data) will be mere aliases to the information contained in the other tree.
    // If the provided other tree is 'None', Data, Left and Right are all set to 'None'.

}

class BinarySearchTree<T, TKey>
// Describes a binary search tree.
{

    +CreateBinarySearchTree(in KeyMap : IMap<T, TKey>) : BinarySearchTree<T, TKey> { query }

    property Key
    {

        +get() : TKey { query }
        // Gets the binary tree's root key.

    }

    property Left
    {

        +get() : BinarySearchTree<T, TKey> { query }
        // Gets the binary tree's left subtree.

    }

    property Right
    {

        +get() : BinarySearchTree<T, TKey> { query }
        // Gets the binary tree's right subtree.

    }

    property Count
    {

        +get() : integer { query }
        // Gets the number of items in the binary search tree.

    }

    property IsEmpty
    {

        +get() : boolean { query }
        // Gets a boolean value that indicates if the binary search tree is empty.

    }

    property IsLeaf
    {

        +get() : boolean { query }
        // Gets a boolean value that indicates if the binary search tree is either empty, or a leaf.
        // Post:
        // Returns true if this binary search tree is empty or has no children.
        // Otherwise, returns false.

    }

    property KeyMap
    {

        +get() : IMap<T, TKey> { query }
        // Gets the function that maps the binary search tree's records to their search keys.

    }

    +TraverseInorder() : IList<T>
    // Performs inorder traversal on the binary search tree and writes its items to a new list.

    +TraverseInorder(in Target : ICollection<T>)
    // Performs inorder traversal on the binary search tree and writes its items to the given target collection.

    +Insert(in Item : T)
    // Inserts an item in the binary search tree.

    +Retrieve(in Key : TKey) : T { query }
    // Retrieves the item with the specified key.
    // Post:
    // If the binary search tree contains an item with the specified key, said item is returned.
    // If not, None is returned.

    +Remove(in Key : TKey) : boolean
    // Removes the item with the specified key from the binary search tree.

}

class BinaryTreeTable<TKey, TValue> : ITable<TKey, TValue>
// A binary search tree implementation of a table.
// Remarks:
// TKey is the type of keys stored in the table, TValue is the type of values.
{

    +CreateBinaryTreeTable(in KeyMap : IMap<TValue, TKey>) : BinaryTreeTable<TKey, TValue> { query }
    // Creates a new binary tree implementation of a table, using the provided mapping function to map list items to their search keys.

    property KeyMap
    {

        +get() : IMap<TValue, TKey> { query }
        // Gets the mapping function that maps list items to their search keys.

    }

    property Count
    {

        +get() : integer { query }
        // Gets the number of elements in the collection.

    }

    property IsEmpty
    {

        +get() : boolean { query }
        // Gets a boolean value that indicates whether the table is empty or not.

    }

    indexer
    {

        +get(in Key : TKey) : TValue { query }
        // Retrieves the item in the table with the specified key.
        // Pre:
        // For this method to return an item in the table, rather than null, the key must be in the table, i.e.
        // ContainsKey(Key) must return true.
        // Post:
        // The return value of this method will be the item that corresponds with the key, or None, if it is not found.
        // It is recommended to check if the table contains the key by using ContainsKey.

    }

    +Insert(in Item : TValue) : boolean
    // Inserts an item into the table.
    // Post:
    // Returns true if item is successfully inserted, false if the table already contains an item with the same search key.

    +Remove(in Key : TKey) : boolean
    // Removes a key from the table.
    // Post:
    // This method returns true if the key is in the table, false if not.

    +ContainsKey(in Key : TKey) : boolean { query }
    // Finds out if the table contains the specified key.
    // Remarks:
    // The original table ADT does not specify this method.
    // It is added, however, to compensate for the lack of the 'success' out parameter when using the retrieve operation.

    +ToList() : IReadOnlyList<TValue> { query }
    // Gets the table's items as a read-only list.
    // Post:
    // This method returns a read-only list that describes the items in this table.
    // Modifications to this list are not allowed - it is read-only.
    // Furthermore, this list may be an alias to an internal list containing the table's items, or a copy.
    // This list need not be sorted, but must contain every item in the table.

}

class BinaryTreeSortedList<T> : ISortedList<T>
// Describes a binary tree implementation of a sorted list.
{

    +CreateBinaryTreeSortedList(in KeyMap : IMap<T, object>) : BinaryTreeSortedList<T> { query }
    // Creates a new binary tree implementation of a sorted list, using the provided mapping function to map list items to their search keys.

    property KeyMap
    {

        +get() : IMap<T, object> { query }
        // Gets the mapping function that maps list items to their search keys.

    }

    property Count
    {

        +get() : integer { query }
        // Gets the number of elements in the collection.

    }

    property IsEmpty
    {

        +get() : boolean { query }
        // Gets a boolean value that indicates whether the sorted list is empty or not.

    }

    +Add(in Item : T)
    // Adds an item to the collection.
    // Remarks:
    // This method allows items to be added to a collection without knowledge of how the collection organizes itself.
    // It does not specify where the item will be inserted, only that it will be inserted.

    +Remove(in Item : T) : boolean
    // Removes an item from the list.
    // Pre:
    // For Item to be successfully removed from the sorted list, it must have been in the list before removal.
    // Post:
    // Returns true if the sorted list contained the given item, false if not.
    // If this returns true, the item has been removed from the sorted list.

    +Contains(in Item : T) : boolean { query }
    // Finds out if the sorted list contains the given item.

    +ToList() : IReadOnlyList<T> { query }
    // Returns a read-only list that represents this list's contents, for easy enumeration.

}

class Date
// Represents a simple date.
{

    +CreateDate(in Day : integer, in Month : integer, in Year : integer) : Date { query }
    // Creates a new date from a day, month and year.
    // Pre:
    // Day must be a positive integer that represents a valid day for the provided month.
    // Month must be an integer from 1 to 12.
    // Year must be an integer.

    property Day
    {

        +get() : integer { query }
        // Gets the day of this date.

    }

    property Month
    {

        +get() : integer { query }
        // Gets the month of this date.

    }

    property Year
    {

        +get() : integer { query }
        // Gets the year of this date.

    }

}

class Time
// Represents the time of day.
{

    +CreateTime(in Hour : integer, in Minute : integer) : Time { query }
    // Creates a new time based on an hour and minute.
    // Pre:
    // Hour and minute must be non-negative integers.
    // Post:
    // Returns a Time instance that exactly represents the provided hour and minute.

    +CreateTime(in Hour : integer, in Minute : integer, in Second : integer) : Time { query }
    // Creates a new time based on an hour, minute and second.
    // Pre:
    // Hour, minute and second must be non-negative integers.
    // Post:
    // Returns a Time instance that exactly represents the provided hour, minute and second.

    property Second
    {

        +get() : integer { query }
        // Gets the second of this time instance.

    }

    property Minute
    {

        +get() : integer { query }
        // Gets the minute of this time instance.

    }

    property Hour
    {

        +get() : integer { query }
        // Gets the hour of this time instance.

    }

}

class DateTime
// Describes a date and time: a date and the time of day.
{

    +CreateDateTime(in Date : Date, in TimeOfDay : Time) : DateTime { query }
    // Creates a new date-time instance based on the date and time provided.

    property Date
    {

        +get() : Date { query }
        // Gets this timestamp's date.

    }

    property TimeOfDay
    {

        +get() : Time { query }
        // Gets this timestamp's time of day.

    }

}

class Theater
// Represents a movie theater.
{

    +CreateTheater(in Name : string) : Theater { query }
    // Creates a new movie theater instance.

    property Auditoria
    {

        +get() : IReadOnlyList<Auditorium> { query }
        // Gets a read-only list of all auditoria in this movie theater.

    }

    property Timeslots
    {

        +get() : IReadOnlyList<Time> { query }
        // Gets the list of all available timeslots for this movie theater.

    }

    property Movies
    {

        +get() : ISortedList<Movie> { query }
        // Gets the list of all movies known to the movie theater.

    }

    property Showtimes
    {

        +get() : ISortableTable<integer, Showtime> { query }
        // Gets a table containing scheduled showtimes.

    }

    property RegisteredCustomers
    {

        +get() : IReadOnlyList<User> { query }
        // Gets a read-only view of all customers registered with this theater.

    }

    property Name
    {

        +get() : string { query }
        // Gets the movie theater's name.

    }

    property Reservations
    {

        +get() : ReservationManager { query }
        // Gets the reservation manager instance.

    }

    +BuildAuditorium(in NumberOfSeats : integer) : Auditorium
    // Builds and returns a new auditorium with the specified number of seats.
    // Pre:
    // NumberOfSeats must be a nonzero positive integer.
    // Post:
    // This method creates a new Auditorium object, adds it to the current movie theater, and returns it.

    +ScheduleShowtime(in Location : Auditorium, in MoviePlaying : Movie, in StartTime : DateTime) : Showtime
    // Schedules a new showtime at this theater, based on the provided arguments.
    // Pre:
    // The auditorium must not be booked for a showtime yet at that specific time, the movie must be a known movie to this theater, and the start time must correspond to a future, valid timeslot.
    // Post:
    // A new showtime is created and assigned its own unique identifier, it is subsequently added to the theater's list of showtimes and then returned.
    // If any of the provided arguments are invalid, an exception is thrown.

    +RegisterCustomer(in FirstName : string, in LastName : string, in EmailAddress : string) : User
    // Registers a new customer and returns a User instance that describes them.
    // Pre:
    // FirstName and LastName should be the user's first and last name, respectively, and EmailAddress should be the user's e-mail address.
    // Post:
    // Creates a new User instance, assigns it a unique id and the given arguments, adds it to the list of registered users, and returns it.

}

class Auditorium : IRecord<integer>
// Describes an auditorium.
{

    +CreateAuditorium(in Index : integer, in NumberOfSeats : integer) : Auditorium { query }
    // Creates a new auditorium instance for the provided index and number of seats.

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Index
    {

        +get() : integer { query }
        // Gets the auditorium's index, or room number.

    }

    property NumberOfSeats
    {

        +get() : integer { query }
        // Gets the number of seats in the auditorium.

    }

}

class Movie : IRecord<integer>
// Describes a movie.
{

    +CreateMovie(in Id : integer, in Title : string, in Rating : float) : Movie { query }
    // Creates a new movie instance for the given parameters.

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Id
    {

        +get() : integer { query }
        // Gets the movie's identifier.

    }

    property Title
    {

        +get() : string { query }
        // Gets the movie's title.

    }

    property Rating
    {

        +get() : float { query }
        // Gets the movie's rating.

    }

}

class Showtime : IRecord<integer>
// Describes a showtime at the movie theater.
{

    +CreateShowtime(in Id : integer, in Location : Auditorium, in MoviePlaying : Movie, in StartTime : DateTime) : Showtime { query }
    // Creates a new instance of a showtime.
    // Pre:
    // Id must be a valid and unique identifier, the location must be an existing at the theater, the movie must be known to the theater and the start time must correspond to one of the theater's time slots.

    property Date
    {

        +get() : Date { query }
        // Gets the date assigned to the showtime.

    }

    property Timeslot
    {

        +get() : Time { query }
        // Gets the movie's starting time.

    }

    property NumberOfFreeSeats
    {

        +get() : integer { query }
        // Gets the number of remaining free seats for this showtime.

    }

    property AuditoriumIndex
    {

        +get() : integer { query }
        // Gets the index of the auditorium where the showtime will take place.

    }

    property MovieId
    {

        +get() : integer { query }
        // Gets the identifier of the movie that's playing at the showtime instance.

    }

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Id
    {

        +get() : integer { query }
        // Gets the showtime's unique identifier.

    }

    property Location
    {

        +get() : Auditorium { query }
        // Gets the auditorium where the showtime will take place.

    }

    property MoviePlaying
    {

        +get() : Movie { query }
        // Gets the movie that will play at the showtime.

    }

    property StartTime
    {

        +get() : DateTime { query }
        // Gets the date and time for which this showtime is scheduled.

    }

    +MakeReservation(in Id : integer, in Request : ReservationRequest) : Reservation
    // Reserves a ticket for this showtime.
    // Pre:
    // Id should be a unique identifier, and the number of seats in request should be no more than the amount of free seats.
    // The reservation request must always be a reservation for this showtime.
    // Post:
    // If the reservation request demanded more seats than available, None will be returned, and no seats will be reserved.
    // The reservation is in effect considered to be canceled.

    +RedeemTicket(in Theater : Theater, in Customer : User)
    // Have one person redeem their ticket and enter the showtime.
    // Note that a user who reserved more than one ticket must enter the showtime multiple times, once per ticket.
    // Pre:
    // The customer must be a user who has an unredeemed ticket for this showtime.
    // The theater must be the theater containing this showtime.
    // Post:
    // If the customer does not have an unredeemed ticket for this showtime, this method does nothing.
    // If, on the other hand, the user does, their ticket is redeemed, and their absence will no longer delay the showtime.
    // If the last ticket was redeemed, the showtime begins, and is be removed from the theater's showtime list.

}

class User : IRecord<integer>
// Describes a registered customer at a movie theater.
{

    +CreateUser(in Id : integer, in FirstName : string, in LastName : string, in EmailAddress : string) : User { query }
    // Creates a new instance of a user with the provided information.

    property Name
    {

        +get() : string { query }
        // Gets the user's full name.

    }

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Id
    {

        +get() : integer { query }
        // Gets the user's unique identifier.

    }

    property FirstName
    {

        +get() : string { query }
        // Gets the user's first name.

    }

    property LastName
    {

        +get() : string { query }
        // Gets the user's last name.

    }

    property EmailAddress
    {

        +get() : string { query }
        // Gets the user's email address.

    }

}

class ReservationRequest
// A request for a reservation.
// Reservation requests are not permanent and do not have an ID.
// Remarks:
// Reservation requests are intended to be an easy way to create a reservation: the client only has to fill in the data fields, and need not concern itself with the number of remaining seats or the hassle of generating a unique identifier.
// Also, their none-permanent nature allows them to be disposed of without consequences if anything goes wrong while processing the reservation.
{

    +CreateReservationRequest(in Customer : User, in Showtime : Showtime, in NumberOfSeats : integer, in Timestamp : DateTime) : ReservationRequest { query }
    // Creates a new reservation request.

    property Customer
    {

        +get() : User { query }
        // Gets the user who placed this request.

    }

    property Showtime
    {

        +get() : Showtime { query }
        // Gets the showtime request this reservation was placed for.

    }

    property NumberOfSeats
    {

        +get() : integer { query }
        // Gets the number of seats this reservation requests.

    }

    property Timestamp
    {

        +get() : DateTime { query }
        // Gets this reservation's timestamp.

    }

}

class ReservationManager
// Manages reservations for a movie theater.
{

    +CreateReservationManager() : ReservationManager { query }
    // Creates a new instance of the reservation manager.

    property Reservations
    {

        +get() : IReadOnlyList<Reservation> { query }
        // Gets the movie theater's processed and accepted reservations.

    }

    +QueueReservation(in Request : ReservationRequest)
    // Queues a reservation for a showtime for processing.

    +ProcessReservations()
    // Processes all queued reservations.

}

class Reservation : IRecord<integer>
// Describes a reservation at a movie theater by a registered customer.
{

    +CreateReservation(in Id : integer, in Customer : User, in Showtime : Showtime, in Timestamp : DateTime, in NumberOfSeats : integer) : Reservation { query }

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Id
    {

        +get() : integer { query }
        // Gets the reservation's unique identifier.

    }

    property Customer
    {

        +get() : User { query }
        // Gets the customer that has reserved a seat.

    }

    property Timestamp
    {

        +get() : DateTime { query }
        // Gets the date and time at which the reservation was processed.

    }

    property Showtime
    {

        +get() : Showtime { query }
        // Gets the showtime associated with this reservation.

    }

    property NumberOfSeats
    {

        +get() : integer { query }
        // Gets the number of seats reserved by the user.

    }

}

class Ticket : IRecord<integer>
// Describes a ticket at a movie theater.
{

    +CreateTicket(in Customer : User) : Ticket { query }
    // Creates a new ticket instance based on the customer it belongs to.

    property CustomerId
    {

        +get() : integer { query }
        // Gets the identifier of the user that is associated with this ticket.

    }

    property Key
    {

        +get() : integer { query }
        // Gets the record's search key.

    }

    property Customer
    {

        +get() : User { query }
        // Gets the user that is associated with this ticket.

    }

}