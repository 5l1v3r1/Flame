/// <summary>
/// Represents a generic stack.
/// </summary>
/// <remarks>
/// T is the type of item on the stack.
/// </remarks>
public class Stack<T> : IReadOnlyCollection<T>
{
    /// <summary>
    /// Creates a new stack instance.
    /// </summary>
    public const this() dataContainer = new LinkedList<T>();
    /// <summary>
    /// Creates a new stack instance that uses the specified list to store its data.
    /// </summary>
    public const this(set IList<T> dataContainer);

    private IList<T> dataContainer;

    /// <summary>
    /// Pushes an item on the stack.
    /// </summary>
    public void Push(T Item)
    {
        dataContainer.Insert(0, Item);
    }
    
    /// <summary>
    /// Gets the number of items on the stack.
    /// </summary>
    public int Count { const get return dataContainer.Count; }
    
    /// <summary>
    /// Gets a boolean value that indicates whether the stack is empty or not.
    /// </summary>
    public bool IsEmpty { const get return Count == 0; }
    
    /// <summary>
    /// Peeks at the item at the top of the stack, without removing it.
    /// </summary>
    /// <pre>
    /// The stack may not be empty.
    /// </pre>
    /// <post>
    /// If the stack was empty, None will be returned.
    /// </post>
    public T Top
    {
        const get
            if (IsEmpty)
                return null;
            else
                return dataContainer[0];
    }
    
    /// <summary>
    /// Pops the item at the top of the stack.
    /// </summary>
    /// <pre>
    /// The stack may not be empty.
    /// </pre>
    /// <post>
    /// If the stack was empty, the stack's state will not change, and None will be returned.
    /// </post>
    public T Pop()
    {
        if (IsEmpty)
        {
            return null;
        }
        var value = dataContainer[0];
        dataContainer.RemoveAt(0);
        return value;
    }
    
    public const [<T>] __iter__()
    {
        return dataContainer.__iter__();
    }
}

/// <summary>
/// Represents a generic queue.
/// </summary>
/// <remarks>
/// T is the type of item in the queue.
/// </remarks>
public class Queue<T> : IReadOnlyCollection<T>
{
    /// <summary>
    /// Creates a new queue instance.
    /// </summary>
    public const this() dataContainer = new ArrayList<T>();
    /// <summary>
    /// Creates a new queue instance that uses the specified list to store its data.
    /// </summary>
    public const this(set IList<T> dataContainer);

    private IList<T> dataContainer;

    /// <summary>
    /// Adds an item to the queue.
    /// </summary>
    public void Enqueue(T Item)
    {
        dataContainer.Add(Item);
    }
    
    /// <summary>
    /// Gets the number of items on the queue.
    /// </summary>
    public int Count { const get return dataContainer.Count; }
    
    /// <summary>
    /// Gets a boolean value that indicates whether the queue is empty or not.
    /// </summary>
    public bool IsEmpty { const get return Count == 0; }
    
    /// <summary>
    /// Peeks at the item at the top of the queue, without removing it.
    /// </summary>
    /// <pre>
    /// The queue may not be empty.
    /// </pre>
    /// <post>
    /// If the queue was empty, None will be returned.
    /// </post>
    public const T Front 
    { 
        const get
        {
            if (IsEmpty)
                return null;
            else
                return dataContainer[0]; 
        }
    }
    
    /// <summary>
    /// Dequeues an item and returns it.
    /// </summary>
    /// <pre>
    /// The queue may not be empty.
    /// </pre>
    /// <post>
    /// If the queue was empty, the queue's state will not change, and None will be returned.
    /// </post>
    public T Dequeue()
    {
        if (IsEmpty)
        {
            return null;
        }
        var value = dataContainer[0];
        dataContainer.RemoveAt(0);
        return value;
    }
    
    public const [<T>] __iter__()
    {
        return dataContainer.__iter__();
    }
}