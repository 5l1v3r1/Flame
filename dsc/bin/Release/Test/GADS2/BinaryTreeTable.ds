/// <summary>
/// A search tree implementation of a table.
/// </summary>
/// <remarks>
/// TKey is the type of keys stored in the table, TValue is the type of values.
/// </remarks>
public class TreeTable<TKey, TValue> : ITable<TKey, TValue>
{
    // <summary>
    // Creates a new tree implementation of a table, using the provided mapping function to map list items to their search keys.
    // </summary>
    //public const this(IMap<TValue, TKey> KeyMap) 
    //{
    //    tree = new BinarySearchTree<TValue, TKey>(KeyMap);
    //}
    
    /// <summary>
    /// Creates a new tree implementation of a table, using the provided tree as backing storage.
    /// </summary>
    public const this(set ITree<TValue, TKey> tree);

    private ITree<TValue, TKey> tree;
    
    /// <summary>
    /// Gets the mapping function that maps list items to their search keys.
    /// </summary>
    public IMap<TValue, TKey> KeyMap { const get return tree.KeyMap; }
    
    public int Count { const get return tree.Count; }
    
    /// <summary>
    /// Gets a boolean value that indicates whether the table is empty or not.
    /// </summary>
    public bool IsEmpty { const get return tree.IsEmpty; }

    public bool Insert(TValue Item)
    {
        if (!ContainsKey(KeyMap.Map(Item)))
        {
            tree.Insert(Item);
            return true;
        }
        else return false;
    }
    
    public TValue this[TKey Key] { const get return tree.Retrieve(Key); } 
    
    public bool Remove(TKey Key)
    {
        return tree.Remove(Key);
    }
    
    public const bool ContainsKey(TKey Key)
    {
        return this[Key] != null;
    }
    
    public const IReadOnlyList<TValue> ToList()
    {
        return tree.TraverseInorder();
    }
    
    public const [<TValue>] __iter__()
    {
        return tree.__iter__();
    }
}