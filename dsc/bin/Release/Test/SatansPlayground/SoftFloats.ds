using System.Text;

/// <summary>
/// Describes an IEEE-754 single precision floating point number implemented in software.
/// </summary>
public class SoftFloat32
{
    public const this(bool IsPositive, bit32 MantissaData, bit32 SignificandData)
    {
        bit32 bits = (MantissaData << 23) | SignificandData;
        if (!IsPositive)
        {
            bits |= (bit32)int32.MinValue;
        }
        this.Data = bits;
    }
    public const this(set bit32 Data);
    public const this(set float32 HardFloat);

    /// <summary>Gets the raw data describing the IEEE-754 single-precision number.</summary>
    public bit32 Data { const get; private set; }
    public float32 HardFloat 
    { 
        const get
        {
            return (float32)Data;
        }
        private set
        {
            this.Data = (bit32)value;
        }
    }
    
    public const string BinaryDataString
    {
        const get
        {
            StringBuilder result = new StringBuilder();
            bit32 d = Data;
            for (int i = 0; i < 32; i++)
            {
                bit32 target = (d >> i) & (bit32)(uint32)0x1;
                if (target == (bit32)(uint32)0x1)
                {
                    result.Insert(0, '1');
                }
                else
                {
                    result.Insert(0, '0');
                }
            }
            return result.ToString();
        }
    }
    
    public const string FloatString
    {
        const get
        {
            StringBuilder sb = new StringBuilder();
            if (!IsPositive)
            {
                sb.Append('-');
            }
            sb.Append(Significand);
            sb.Append(" * 2^");
            sb.Append(Mantissa);
            return sb.ToString();
        }
    }
    
    public bool IsPositive
    {
        const get
        {
            return (Data & (bit32)0x80000000) == 0b0;
        }
    }
    
    public int Sign
    {
        const get
        {
            if (IsPositive) return 1;
            else return -1;
        }
    }
    
    public bit32 SignificandData
    {
        const get return Data & (bit32)(uint32)0x7FFFFF;
    }
    
    public bit32 MantissaData
    {
        const get return (Data & (bit32)0x7F800000) >> 23;
    }
    
    public double Significand
    {
        const get
        {
            double result = 1.0;
            double factor = .5;
            bit32 sData = SignificandData;
            for (int i = 22; i >= 0; i--)
            {
                bit32 targetBit = (sData >> i) & (bit32)(uint32)0x1;
                if (targetBit == (bit32)(uint32)0x1)
                {
                    result += factor;
                }
                factor *= 0.5;
            }
            return result;
        }
    }
    
    public int Mantissa
    {
        const get return (int)MantissaData - 127;
    }
    
    public const string operator cast()
    {
        return FloatString;
    }
    
    private static int32 Shr(int32 Value, int32 Amount)
    {
        var result = Value;
        for (int i = 0; i < Amount; i++)
        {
            result = result / 2;
        }
        return result;
    }
    
    public const SoftFloat32 Add(SoftFloat32 Other)
    {
        return Add(this, Other);
    }
    
    /// <summary>
    /// Calculates the sum of two IEEE-754 single precision numbers.
    /// </summary>
    public static const SoftFloat32 Add(SoftFloat32 A, SoftFloat32 B)
    {
        int32 sA = (int32)A.SignificandData;
        int32 sB = (int32)B.SignificandData;
        int32 mA = A.Mantissa;
        int32 mB = B.Mantissa;
        if (mB > mA)
        {
            sA = Shr(sA, mB - mA);
            var temp = mA;
            mA = mB;
            mB = temp;
        }
        else
        {
            sB = Shr(sB, mA - mB);
        }
        int32 sResult = sA * A.Sign + sB * B.Sign;
        bool isPos = sResult >= 0;
        if (!isPos)
        {
            sResult = -sResult;
        }
        while (sResult >= 1 << 23)
        {
            sResult = sResult / 2;
            mA++;
        }
        return new SoftFloat32(isPos, (bit32)(mA + 127), (bit32)sResult);
    }
}