using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Expressions
{
    public class NotExpression : UnaryExpression
    {
        public const this(set IExpression Value);

        public override IBoundObject Evaluate()
        {
            if (Value.Type.Equals(PrimitiveTypes.Boolean))
            {
            	var boundObject = Value.Evaluate();
                return new BooleanExpression(!boundObject.GetPrimitiveValue<bool>());
            }
            /*else if (Value.Type.Equals(PrimitiveTypes.Int8))
            {
                return ~Value.Evaluate<int8>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt8))
            {
                return ~Value.Evaluate<uint8>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int16))
            {
                return ~Value.Evaluate<int16>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt16))
            {
                return ~Value.Evaluate<uint16>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int32))
            {
                return ~Value.Evaluate<int32>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt32))
            {
                return ~Value.Evaluate<uint32>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int64))
            {
                return ~Value.Evaluate<int64>();
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt64))
            {
                return ~Value.Evaluate<uint64>();
            }*/
            else
            {
                return null;
            }
        }

        public override IExpression Optimize()
        {
            var optVal = Value.Optimize();
            var optExpr = new NotExpression(optVal);
            /*if (optExpr.IsConstant && optExpr.Type.IsCompileableType())
            {
                return NodeExtensions.ToExpression(optExpr.Evaluate());
            }
            else*/
            if (optVal is NotExpression)
            {
                return ((NotExpression)optVal).Value;
            }
            else if (optVal is EqualityExpression)
            {
            	var ceq = ((EqualityExpression)optVal);
            	return new InequalityExpression(ceq.LeftOperand, ceq.RightOperand);
            }
            else if (optVal is InequalityExpression)
            {
            	var cne = ((InequalityExpression)optVal);
            	return new EqualityExpression(cne.LeftOperand, cne.RightOperand);
            }
            else if (optVal is LessThanExpression)
            {
                var clt = (LessThanExpression)optVal;
                return new GreaterThanOrEqualsExpression(clt.LeftOperand, clt.RightOperand);
            }
            else if (optVal is GreaterThanExpression)
            {
                var cgt = (GreaterThanExpression)optVal;
                return new LessThanOrEqualsExpression(cgt.LeftOperand, cgt.RightOperand);
            }
            else if (optVal is GreaterThanOrEqualsExpression)
            {
                var cge = (GreaterThanOrEqualsExpression)optVal;
                return new LessThanExpression(cge.LeftOperand, cge.RightOperand);
            }
            else if (optVal is LessThanOrEqualsExpression)
            {
                var cle = (LessThanOrEqualsExpression)optVal;
                return new GreaterThanExpression(cle.LeftOperand, cle.RightOperand);
            }
            else
            {
                return optExpr;
            }
        }

        public override ICodeBlock Emit(ICodeGenerator Generator)
        {
            return Generator.EmitNot(Value.Emit(Generator));
        }
    }
}