using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Expressions
{
	public class ConcatExpression : IExpression
    {
    	public const this(set IExpression[] Operands);
        public const this(IExpression LeftOperand, IExpression RightOperand)
        {
        	this.Operands = new IExpression[] { LeftOperand, RightOperand };
        }

		public IExpression[] Operands { const get; private set; }

        public const IBoundObject Evaluate()
        {
    		return EvaluateExpression();
        }
        
        public IType Type
        {
        	const get
        	{
        		return Operands[0].Type;
        	}
        }
        
        public const StringExpression EvaluateExpression()
        {
    		StringBuilder result = new StringBuilder();
    		foreach (var item in Operands)
    		{
    			result.Append(item.Evaluate().GetValue<string>());
    		}
    		return new StringExpression(result.ToString());
        }
        
        public bool IsConstant
		{
			const get
			{
				foreach (var item in Operands)
				if (!item.IsConstant || !item.Type.Equals(PrimitiveTypes.String))
				{
					return false;
				}
				return true;
			}
		}

        public override const IExpression Optimize()
        {
        	var optOperands = new List<IExpression>();
        	foreach (var item in Operands)
        	{
        		var optOp = item.Optimize();
        		if (optOp is ConcatExpression)
        			optOperands.AddRange((IEnumerable<IExpression>)((ConcatExpression)optOp).Operands);
        		else
        			optOperands.Add(optOp);
        	}
        	
        	int i = 1;
        	while (i < optOperands.Count)
        	{
        		if (optOperands[i].IsConstant && optOperands[i].Type.Equals(PrimitiveTypes.String) && optOperands[i - 1].IsConstant && optOperands[i - 1].Type.Equals(PrimitiveTypes.String))
        		{
        			optOperands[i - 1] = new StringExpression(optOperands[i - 1].Evaluate().GetValue<string>() + optOperands[i].Evaluate().GetValue<string>());
        			optOperands.RemoveAt(i);
        		}
        		else
        		{
        			i++;
        		}
        	}
        	
        	var optExpr = new ConcatExpression(optOperands.ToArray());
        	
        	if (optExpr.IsConstant) return optExpr.EvaluateExpression();
        	else return optExpr;
        }
        
        /// <summary>
        /// Reduces the binary concatenation expression to a simpler expression.
        /// </summary>
        public static const IExpression ReduceBinary(IExpression LeftOperand, IExpression RightOperand)
        {
        	if (LeftOperand.Type.Equals(PrimitiveTypes.String) && RightOperand.Type.Equals(PrimitiveTypes.String))
            {
                var concatMethod = PrimitiveTypes.String.GetMethod("Concat", true, PrimitiveTypes.String, new IType[] { PrimitiveTypes.String, PrimitiveTypes.String });
                return new InvocationExpression(concatMethod, null, (IEnumerable<IExpression>)new IExpression[] { LeftOperand, RightOperand });
            }
            else
            {
            	return null; // Not implemented yet
            }
        }
        
        /// <summary>
        /// Reduces the concatenation expression to a simpler expression.
        /// </summary>
        public const IExpression Reduce()
        {
        	IExpression aggregate = Operands[0];
        	for (int i = 1; i < Operands.Length; i++)
        	{
        		aggregate = ReduceBinary(aggregate, Operands[i]);
        	}
        	return aggregate;
        }

        public override const ICodeBlock Emit(ICodeGenerator Generator)
        {
            return Reduce().Emit(Generator);
        }
    }
}