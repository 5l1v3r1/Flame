using System;
using System.Collections.Generic;

namespace Flame.Compiler
{
	public static class NodeExtensions
	{
		#region IsConstant
	
		public static bool AreConstant[this IEnumerable<IExpression> Expressions]
		{
			const get
			{
				foreach (var expr in Expressions)
				{
					if (!expr.IsConstant)
					{
						return false;
					}
				}
				return true;
			}
		}
	
		public static bool IsConstantOrNull[this IExpression Expression]
		{
			const get
			{
				if (Expression == null)
				{
					return true;
				}
				else
				{
					return Expression.IsConstant;
				}
			}
		}
		
		#endregion
		
		#region Optimize
		
		public static IEnumerable<IExpression> OptimizeAll(this IEnumerable<IExpression> Expressions)
		{
			List<IExpression> exprs = new List<IExpression>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Optimize());
			}
			return exprs;
		}
	
		public static IExpression OptimizeOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Optimize();
			}
		}
		public static IStatement OptimizeOrNull(this IStatement Statement)
		{
			if (Statement == null)
			{
				return null;
			}
			else
			{
				return Statement.Optimize();
			}
		}
		
		#endregion
		
		#region Evaluate
		
		public static IBoundObject EvaluateOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;	
			}
			else
			{
				return Expression.Evaluate();
			}
		}
		
		public static IEnumerable<IBoundObject> EvaluateAll(this IEnumerable<IExpression> Expressions)
		{
			List<IBoundObject> exprs = new List<IBoundObject>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Evaluate());
			}
			return exprs;
		}
		
		#endregion
		
		#region Emit
	
		public static ICodeBlock EmitOrNull(this IExpression Expression, ICodeGenerator Generator)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Emit(Generator);
			}
		}
		
		public static IEnumerable<ICodeBlock> EmitAll(this IEnumerable<IExpression> Expressions, ICodeGenerator Generator)
		{
			List<ICodeBlock> exprs = new List<ICodeBlock>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Emit(Generator));
			}
			return exprs;
		}
		
		#endregion
		
		#region Types
		
		public static IType[] Types[this IEnumerable<IExpression> Expressions]
		{
			const get
			{
				List<IType> types = new List<IType>();
				foreach (var item in Expressions)
				{
					types.Add(item.Type);
				}
				return types.ToArray();
			}
		}
		
		#endregion
		
		#region EvaluatesTo
		
		public static bool EvaluatesTo<T>(this IExpression Expression, T Value)
			where T : object
		{
			if (Expression.IsConstant)
			{
				var result = Expression.Evaluate();
				if (result != null)
				{
					if (result is IBoundPrimitive<T>)
					{
						return result.GetValue<T>().Equals(Value);
					}
				}
			}
			return false;
		}
		
		#endregion
	}
}