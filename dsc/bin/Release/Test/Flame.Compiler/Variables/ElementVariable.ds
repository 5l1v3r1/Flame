using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;

namespace Flame.Compiler.Variables
{
	public class ElementVariable : IUnmanagedVariable
	{
        public const this(set IExpression Target, set IEnumerable<IExpression> IndexArguments);

        public IExpression Target { const get; private set; }
        public IEnumerable<IExpression> IndexArguments { const get; private set; }
        
        private IType[] indexerArgTypes;
        protected IType[] IndexArgumentTypes
        {
        	const get
        	{
        		if (indexerArgTypes == null)
        		{
	        		List<IType> types = new List<IType>();
	        		foreach (var item in IndexArguments)
	        		{
	        			types.Add(item.Type);	
	               	}
	               	indexerArgTypes = types.ToArray();
               	}
               	return indexerArgTypes;
        	}
        }

		private bool indexerFound;
		private IProperty indexerProp;
        protected IProperty IndexerProperty
        {
            const get
            {
            	if (!indexerFound)
            	{
                	indexerProp = Target.Type.GetBestIndexer(false, (IEnumerable<IType>)IndexArgumentTypes);
                	indexerFound = true;
                }
                return indexerProp;
            }
        }
        
        public static IType GetElementType(IType TargetType, IEnumerable<IType> ArgumentTypes)
        {
            if (TargetType.IsContainerType)
           	{
           		return TargetType.AsContainerType().GetElementType();
           	}
           	else
          	{
          		var indexerProp = TargetType.GetBestIndexer(false, ArgumentTypes);
	       		return indexerProp.PropertyType;
          	}
        }
        
        public bool CanResolve
        {
        	const get
        	{
        		if (IsContainerElement)
				{
					return true;
				}
				else
				{
					return IndexerProperty != null;
				}
        	}
        }
        
        public bool IsContainerElement
        {
        	const get
        	{
        		return Target.Type.IsContainerType;
        	}
        }

        public IType Type
        {
            const get
            {
            	var targetType = Target.Type;
	            if (targetType.IsContainerType)
	           	{
	           		return targetType.AsContainerType().GetElementType();
	           	}
	           	else
	          	{
		       		return IndexerProperty.PropertyType;
	          	}
            }
        }

        public IExpression CreateAddressOfExpression()
        {
            if (IsContainerElement)
            {
            	return new ContainerElementAddressOfExpression(Target, IndexArguments); 
            }
            else
            {
            	// Create a temporary variable
                var temp = new LateBoundVariable(IndexerProperty.PropertyType);
                return new InitializedExpression(temp.CreateSetStatement(CreateGetExpression()), temp.CreateAddressOfExpression(), temp.CreateReleaseStatement());
            }
        }

        public IExpression CreateGetExpression()
        {
            if (IsContainerElement)
            {
            	return new ContainerElementGetExpression(Target, IndexArguments);
            }
            else
            {
                return new InvocationExpression(IndexerProperty.GetGetAccessor(), Target, IndexArguments);
            }
        }

        public IStatement CreateSetStatement(IExpression Value)
        {
            if (IsContainerElement)
            {
            	return new ContainerElementSetStatement(this, Value);
            }
            else
            {
            	var args = Enumerable.Concat<IExpression>(IndexArguments, (IEnumerable<IExpression>)new IExpression[] { Value });
                return new ExpressionStatement(new InvocationExpression(IndexerProperty.GetSetAccessor(), Target, args));
            }
        }

        public IStatement CreateReleaseStatement()
        {
        	return new EmptyStatement();
        }
	}
}