using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler
{
    public class CodeBuilder
    {
        public const this()
        {
			Init();
        }
        public const this(string Code)
        {
        	Init();
            string[] codeLines = Code.Replace("\r", "").Split(new char[] { '\n' });
            string indentString = GetIndentationString(codeLines);
            this.IndentationString = indentString;
            foreach (var item in codeLines)
            {
            	AddFormattedLine(item);
            }
        }
        private void Init()
        {
        	indentation = 0;
            lines = new List<CodeLine>();
            IndentationString = "\t";
        }

        private List<CodeLine> lines;
        private int indentation;
        public string IndentationString { const get; set; }

        #region Increase/Decrease Indentation

        public void IncreaseIndentation()
        {
            indentation++;
        }
        public void DecreaseIndentation()
        {
            if (indentation > 0)
            {
                indentation--;
            }
        }

        #endregion

        #region Append

        public void Append(char Character)
        {
            Append(Character.ToString());
        }
        public void Append(string Text)
        {
            if (lines.Count == 0)
            {
                AddLine();
            }
            string[] splitText = Text.Replace("\r", "").Split(new char[] { '\n' });
            var oldLine = lines[lines.Count - 1];
            lines[lines.Count - 1] = new CodeLine(oldLine.Text + splitText[0], oldLine.Indentation);
            for (int i = 1; i < splitText.Length; i++)
            {
	        	AddLine(splitText[i]);
	        }
        }
        public void Append(CodeBuilder Builder)
        {
        	var builderLines = Builder.lines;
            if (builderLines.Count > 0)
            {
                if (lines.Count == 0)
                {
                    AddLine();
                }
                var oldLine = lines[lines.Count - 1];
                string firstLineText = builderLines[0].Text;
                lines[lines.Count - 1] = new CodeLine(oldLine.Text + firstLineText, oldLine.Indentation);
                for (int i = 1; i < builderLines.Count; i++)
                {
                    CodeLine item = builderLines[i];
                    AddLine(new CodeLine(item.Text, item.Indentation + indentation));
                }
            }
        }
        public void AppendLine(string Text)
        {
            Append(Text);
            AddLine();
        }
        public void AppendLine()
        {
            AddLine();
        }

        #endregion

        #region AddLine

        public void AddLine()
        {
            AddLine("");
        }
        public void AddEmptyLine()
        {
            AddLine("\0");
        }
        public void AddLine(string Text)
        {
            lines.Add(new CodeLine(Text, indentation));
        }
        public void AddLine(CodeLine Line)
        {
            lines.Add(Line);
        }
        public void AddCodeBuilder(CodeBuilder Builder)
        {
            foreach (var item in Builder.lines)
            {
                AddLine(new CodeLine(item.Text, item.Indentation + indentation));
            }
        }
        /// <summary>
        /// Adds a line to the code builder that has already been formatted.
        /// The current indentation is adjusted to fit the line.
        /// </summary>
        public void AddFormattedLine(string Text)
        {
        	if (string.IsNullOrEmpty(Text))
        	{
        		AddEmptyLine();
        	}
        	else
        	{
        		if (IndentationString.StartsWith(" "))
        		{
        			Text = Untabify(Text);
        		}
	        	int indent = 0;
	        	while (IndentationString.Length > 0 && LongestCommonSubstring(IndentationString, Text, 0, indent * IndentationString.Length).Length == IndentationString.Length)
	        	{
	        		indent++;
	        	}
	        	this.indentation = indent;
	        	AddLine(Text.Substring(indent * IndentationString.Length));
        	}
        }

        #endregion
        
        #region Properties

        public int LineCount
        {
            const get
            {
                return lines.Count;
            }
        }
        
        public bool IsWhitespace
        {
        	const get
        	{
        		foreach (var item in lines)
				{
					if (!item.IsWhitespace)
						return false;
				}
				return true;
        	}
        }
        
        public CodeLine this[int index]
        {
            const get { return lines[index]; }
            set { lines[index] = value; }
        }
        
        #endregion

        public void InsertLine(int Index, CodeLine Line)
        {
            lines.Insert(Index, Line);
        }
        
        public const char CharacterAt(int Index)
        {
        	int count = 0;
            for (int i = 0; i < lines.Count; i++)
            {
            	StringBuilder sb = new StringBuilder();
                var line = lines[i];
                if (line.IsEmpty)
                {
                	for (int32 j = 0; i < line.Indentation; j++)
                	{
                		sb.Append(IndentationString);
                	}
                	sb.AppendLine();
                }
                else if (!line.IsWhitespace)
                {
                    sb.AppendLine(lines[i].ToString(IndentationString));
                }
                
                if (Index < count + sb.Length)
                {
                	return sb[Index - count];
                }
                else
                {
                	count += sb.Length;
                }
            }
            return default(char);
        }

        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < lines.Count; i++)
            {
                var line = lines[i];
                if (line.IsEmpty)
                {
                	for (int32 j = 0; i < line.Indentation; j++)
                	{
                		sb.Append(IndentationString);
                	}
                	sb.AppendLine();
                }
                else if (!line.IsWhitespace)
                {
                    sb.AppendLine(lines[i].ToString(IndentationString));
                }
            }
            return sb.ToString().TrimEnd(new char[] { '\r', '\n', '\t', ' ' });
        }
        
        #region Static
        
        private static const string Untabify(string Value)
        {
        	return Value.Replace("\t", "    ");
        }
        
        private static const string LongestCommonSubstring(string First, string Second, int FirstOffset, int SecondOffset)
        {
    	    int i = FirstOffset;
    	    int j = SecondOffset;
    		while (i < First.Length && j < Second.Length)
    		{
    			if (First[i] != Second[j])
    			{
    				break;
    			}
    			i++;
    			j++;
    		}
    		return First.Substring(FirstOffset, i - FirstOffset);
        }
        
        private static const string LongestCommonSubstring(string First, string Second)
        {
        	return LongestCommonSubstring(First, Second, 0, 0);
        }
        
        private static const string GetIndentationString(string IndentString, string Line)
        {
        	if (IndentString.Length == 0)
        	{
        		int i = 0;
        		while (i < Line.Length && (Line[i] == '\t' || Line[i] == ' '))
        		{
        			i++;
        		}
        		return Line.Substring(0, i);
        	}
        	else if (Line.StartsWith(IndentString))
        	{
        		return IndentString;
        	}        	
        	else if (Line.StartsWith("\t") && IndentString.StartsWith(" ") && Line[0] != IndentString[0])
        	{
        		return GetIndentationString(Untabify(IndentString), Untabify(Line));
        	}
        	else
        	{
        		string lcs = LongestCommonSubstring(IndentString, Line);
        		
        		if (lcs.Length > 0) return lcs;
        		else
        		{
        			return IndentString;
        		}
        	}
        }
        
        /// <summary>
        /// Gets the best match for an indentation that suits the given indented lines.
        /// An indentation string is defined as a sequence of tab or space characters that precede every line in the given sequence zero or more times.
        /// </summary>
        public static const string GetIndentationString([string] IndentedLines)
        {
        	string bestMatch = "";
        	foreach (var item in IndentedLines)
        	{
        		bestMatch = GetIndentationString(bestMatch, item);
        	}
        	return bestMatch;
        }
        
        #endregion
    }
}