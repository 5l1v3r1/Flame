using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler.Variables;

namespace Flame.Compiler.Flow
{
	/// <summary>
	/// Defines a control flow graph: a self-contained sequence of basic
	/// blocks, with an entry point.
	/// </summary>
	public class FlowGraph
	{
		/// <summary>
		/// Creates a new flow graph from the given entry point tag and
		/// tag-basic block mapping.
		/// </summary>
		public const this(
			set UniqueTag EntryPointTag,
			IReadOnlyDictionary<UniqueTag, BasicBlock> Blocks)
		{
			this.allBlocks = Blocks;
		}

		/// <summary>
		/// Creates a new flow graph from the given entry point tag and sequence
		/// of basic blocks.
		/// </summary>
		public const this(set UniqueTag EntryPointTag, [BasicBlock] Blocks)
		{
			var blockDict = new Dictionary<UniqueTag, BasicBlock>();
			foreach (var item in Blocks)
			{
				blockDict.Add(item.Tag, item);
			}
			this.allBlocks = blockDict;
		}

		private IReadOnlyDictionary<UniqueTag, BasicBlock> allBlocks;

		/// <summary>
		/// Gets the unique tag that identifies the entry point block in
		/// this control flow graph.
		/// </summary>
		public UniqueTag EntryPointTag { const get; private set; }

		/// <summary>
		/// Gets the sequence of all blocks in this control flow graph.
		/// </summary>
		public [BasicBlock] Blocks { get { return allBlocks.Values; } }

		/// <summary>
		/// Gets the sequence of all block tags in this control flow graph.
		/// </summary>
		public [UniqueTag] BlockTags { get { return allBlocks.Keys; } }

		/// <summary>
		/// Gets this control flow graph's entry point graph.
		/// </summary>
		public BasicBlock EntryPointBlock
		{
			get { return GetBlock(EntryPointTag); }
		}

		/// <summary>
		/// Gets the block associated with the given tag in this control flow
		/// graph.
		/// </summary>
		public BasicBlock GetBlock(UniqueTag Tag)
		{
			return allBlocks[Tag];
		}

		/// <summary>
		/// Checks if this control-flow graph contains a block that is
		/// identified by the given unique tag.
		/// </summary>
		public bool ContainsBlock(UniqueTag Tag)
		{
			return allBlocks.ContainsKey(Tag);
		}

		/// <summary>
		/// Accepts the given node visitor.
		/// </summary>
		public FlowGraph Accept(INodeVisitor Visitor)
		{
			var newBlocks = new Dictionary<UniqueTag, BasicBlock>();
			foreach (var item in Blocks)
			{
				var visitedBlock = item.Accept(Visitor);
				newBlocks[visitedBlock.Tag] = visitedBlock;
			}
			return new FlowGraph(EntryPointTag, newBlocks);
		}

		/// <summary>
		/// Accepts the given predicate node visitor.
		/// </summary>
		public void AcceptPredicate(INodeVisitor Visitor)
		{
			foreach (var item in Blocks)
			{
				item.Accept(Visitor);
			}
		}

		/// <summary>
		/// Converts all SSA parameter/argument types in the flow graph.
		/// Additionally, any members that are encoded in the control-flow
		/// graph's flow instructions are also converted.
		/// </summary>
		public FlowGraph ConvertMembers(MemberConverter Converter)
		{
			var visitor = new BlockTypeVisitor(Converter);
			var newBlocks = new Dictionary<UniqueTag, BasicBlock>();
			foreach (var item in Blocks)
			{
				var visitedBlock = item.ConvertMembers(visitor);
				newBlocks[visitedBlock.Tag] = visitedBlock;
			}
			return new FlowGraph(EntryPointTag, newBlocks);
		}

		/// <summary>
		/// Applies simple optimizations to this control flow graph.
		/// </summary>
		public FlowGraph Optimize()
		{
			var newBlocks = new Dictionary<UniqueTag, BasicBlock>();
			foreach (var item in Blocks)
			{
				var visitedBlock = item.Optimize();
				newBlocks[visitedBlock.Tag] = visitedBlock;
			}
			return new FlowGraph(EntryPointTag, newBlocks).EliminateUnreachable();
		}

		alias PredecessorPair = Tuple<UniqueTag, IReadOnlyList<SSAVariable>>;

		/// <summary>
		/// Creates a dictionary that maps basic block tags to sequences of
		/// (predecessor block tag, argument list) pairs.
		/// </summary>
		/// <remarks>
		/// This is O(n*m), where n represents the number of blocks,
		/// and m is equal to the number of branches per block.
		/// </remarks>
		public IReadOnlyDictionary<UniqueTag, [PredecessorPair]> GetPredecessors()
		{
			var results = new Dictionary<UniqueTag, [PredecessorPair]>();
			foreach (var item in Blocks)
			{
				foreach (var branch in item.Flow.Branches)
				{
					[PredecessorPair] preds;
					if (!results.TryGetValue(branch.TargetTag, &preds))
					{
						preds = new HashSet<PredecessorPair>();
						results[branch.TargetTag] = preds;
					}
					var predList = (HashSet<PredecessorPair>)preds;
					// Add the (predecessor block tag, argument list) to the
					// list of predecessors for the target block.
					predList.Add(new PredecessorPair(item.Tag, branch.Arguments));
				}
			}
			return results;
		}

		/// <summary>
		/// Marks all blocks that are reachable from this block as
		/// reachable by adding them to the given set.
		/// </summary>
		private void MarkStrictlyReachable(UniqueTag Tag, HashSet<UniqueTag> Results)
		{
			// Mark all blocks that are reachable from this block
			// as reachable.
			foreach (var item in GetBlock(Tag).Flow.Branches)
			{
				MarkReachable(item.TargetTag, Results);
			}
		}

		/// <summary>
		/// Marks the block identified by the given tag - and all blocks that
		/// are reachable from this block - as reachable by adding them to
		/// the given set.
		/// </summary>
		private void MarkReachable(UniqueTag Tag, HashSet<UniqueTag> Results)
		{
			// Mark this block as reachable.
			if (Results.Add(Tag))
			{
				// Mark all blocks that are reachable strictly from this block
				// as reachable.
				MarkStrictlyReachable(Tag, Results);
			}
		}

		/// <summary>
		/// Computes the set of all blocks in this flow graph that are reachable
		/// from the given block tag.
		/// </summary>
		public [UniqueTag] FindReachableBlocks(UniqueTag Tag)
		{
			var results = new HashSet<UniqueTag>();
			MarkReachable(Tag, results);
			return results;
		}

		/// <summary>
		/// Computes the set of all blocks in this flow graph that are strictly reachable
		/// from the given block tag: this does not include the given block if
		/// there is no (cyclic) path that reaches it.
		/// </summary>
		public [UniqueTag] FindStrictlyReachableBlocks(UniqueTag Tag)
		{
			var results = new HashSet<UniqueTag>();
			MarkStrictlyReachable(Tag, results);
			return results;
		}

		/// <summary>
		/// Computes the set of all reachable blocks in this flow graph.
		/// </summary>
		public [UniqueTag] FindReachableBlocks()
		{
			return FindReachableBlocks(EntryPointTag);
		}

		/// <summary>
		/// Creates a flow graph that contains all blocks that are
		/// reachable in this flow graph.
		/// </summary>
		public FlowGraph EliminateUnreachable()
		{
			var reachable = new HashSet<UniqueTag>();
			MarkReachable(EntryPointTag, reachable);
			var results = new Dictionary<UniqueTag, BasicBlock>();
			foreach (var item in Blocks)
			{
				if (reachable.Contains(item.Tag))
				{
					results[item.Tag] = item;
				}
			}
			return new FlowGraph(EntryPointTag, results);
		}

		/// <summary>
		/// Adds all block tags that are reachable from the given tag,
		/// and are part of the 'finally' region,
		/// to the set of 'finally' region tags.
		/// </summary>
		private void ExploreFinallyRegion(
			UniqueTag Tag, HashSet<UniqueTag> FinallyRegionBlocks,
			Dictionary<UniqueTag, ExceptionFlowGraph> Subgraphs)
		{
			if (FinallyRegionBlocks.Add(Tag))
			{
				var block = GetBlock(Tag);
				assert(!(block.Flow is FinallyFlow));
				if (block.Flow is LeaveFlow)
				{
					// All right. We're done here.
					return;
				}
				else if (block.Flow is TryFlow)
				{
					// We've encountered the start of another exception handling
					// subgraph. Handle it separately.
					var target = ((TryFlow)block.Flow).Branch.TargetTag;
					ExploreExceptionFlowGraph(target, Subgraphs);
					var result = Subgraphs[target];
					foreach (var tag in result.FinallyRegion.FindLeaveTags(this))
					{
						ExploreFinallyRegion(tag, FinallyRegionBlocks, Subgraphs);
					}
				}
				else
				{
					// Explore all successor tags.
					foreach (var tag in block.Flow.SuccessorTags)
					{
						ExploreFinallyRegion(tag, FinallyRegionBlocks, Subgraphs);
					}
				}
			}
		}

		/// <summary>
		/// Adds all block tags that are reachable from the given tag,
		/// and are part of the 'catch' region, to the set of 'catch' region tags.
		/// </summary>
		private void ExploreCatchRegion(
			UniqueTag Tag, HashSet<UniqueTag> CatchRegionBlocks,
			Dictionary<UniqueTag, ExceptionFlowGraph> Subgraphs)
		{
			if (CatchRegionBlocks.Add(Tag))
			{
				var block = GetBlock(Tag);
				assert(!(block.Flow is LeaveFlow));
				if (block.Flow is FinallyFlow)
				{
					// All right. We're done here.
					return;
				}
				else if (block.Flow is TryFlow)
				{
					// We've encountered the start of another exception handling
					// subgraph. Handle it separately.
					var target = ((TryFlow)block.Flow).Branch.TargetTag;
					ExploreExceptionFlowGraph(target, Subgraphs);
					var result = Subgraphs[target];
					foreach (var tag in result.FinallyRegion.FindLeaveTags(this))
					{
						ExploreCatchRegion(tag, CatchRegionBlocks, Subgraphs);
					}
				}
				else
				{
					// Explore all successor tags.
					foreach (var tag in block.Flow.SuccessorTags)
					{
						ExploreCatchRegion(tag, CatchRegionBlocks, Subgraphs);
					}
				}
			}
		}

		/// <summary>
		/// Adds all block tags that are reachable from the given tag,
		/// and are part of the 'try' region, to the set of
		/// 'try' region tags. 'Catch' regions are also analyzed.
		/// </summary>
		private UniqueTag ExploreTryRegion(
			UniqueTag Tag, HashSet<UniqueTag> TryRegionBlocks,
			List<UniqueTag> ExceptionHandlers,
			Dictionary<UniqueTag, ExceptionHandlerRegion> HandlerRegions,
			Dictionary<UniqueTag, ExceptionFlowGraph> Subgraphs)
		{
			if (TryRegionBlocks.Add(Tag))
			{
				var block = GetBlock(Tag);
				assert(!(block.Flow is LeaveFlow));
				if (block.Flow is FinallyFlow)
				{
					// All right. We're done here.
					return ((FinallyFlow)block.Flow).Branch.TargetTag;
				}
				else if (block.Flow is TryFlow)
				{
					// We've encountered the start of another exception handling
					// subgraph. Handle it separately.
					var target = ((TryFlow)block.Flow).Branch.TargetTag;
					ExploreExceptionFlowGraph(target, Subgraphs);
					var ehGraph = Subgraphs[target];
					UniqueTag result = null;
					foreach (var tag in ehGraph.FinallyRegion.FindLeaveTags(this))
					{
						var finallyTag = ExploreTryRegion(
							tag, TryRegionBlocks, ExceptionHandlers,
							HandlerRegions, Subgraphs);

						if (finallyTag != null)
							result = finallyTag;
					}
					return result;
				}
				else if (block.Flow is ExceptionFlow)
				{
					var flow = (ExceptionFlow)block.Flow;
					ExploreTryRegion(
						flow.SuccessBranch.TargetTag, TryRegionBlocks,
						ExceptionHandlers, HandlerRegions, Subgraphs);

					foreach (var br in flow.ExceptionBranches)
					{
						var target = br.Branch.TargetTag;
						if (!HandlerRegions.ContainsKey(target))
						{
							ExceptionHandlers.Add(target);
							HandlerRegions[target] = null;
							var catchRegionBlocks = new HashSet<UniqueTag>();
							ExploreCatchRegion(
								target, catchRegionBlocks, Subgraphs);
							HandlerRegions[target] = new ExceptionHandlerRegion(
								br.ExceptionType, new ExceptionFlowRegion(
									target, catchRegionBlocks));
						}
					}
					return flow.FinallyBranch.TargetTag;
				}
				else
				{
					// Explore all successor tags.
					UniqueTag result = null;
					foreach (var tag in block.Flow.SuccessorTags)
					{
						var finallyTag = ExploreTryRegion(
							tag, TryRegionBlocks, ExceptionHandlers,
							HandlerRegions, Subgraphs);

						if (finallyTag != null)
							result = finallyTag;
					}
					return result;
				}
			}
			else
			{
				return null;
			}
		}

		/// <summary>
		/// Explores the exception flow graph with the given tag as entry point,
		/// and adds it to the set of exception flow subgraphs.
		/// </summary>
		private void ExploreExceptionFlowGraph(
			UniqueTag Tag, Dictionary<UniqueTag, ExceptionFlowGraph> Subgraphs)
		{
			if (Subgraphs.ContainsKey(Tag))
				return;

			// Set this to null, to make sure we don't accidentally
			// compute the same exception flow subgraph twice.
			Subgraphs[Tag] = null;

			var tryRegionBlocks = new HashSet<UniqueTag>();
			var ehBlocks = new List<UniqueTag>();
			var ehRegions = new Dictionary<UniqueTag, ExceptionHandlerRegion>();

			var finallyTag = ExploreTryRegion(
				Tag, tryRegionBlocks, ehBlocks, ehRegions, Subgraphs);

			var tryRegion = new ExceptionFlowRegion(Tag, tryRegionBlocks);

			var finallyBlocks = new HashSet<UniqueTag>();
			if (finallyTag != null)
				ExploreFinallyRegion(finallyTag, finallyBlocks, Subgraphs);
			var finallyRegion = new ExceptionFlowRegion(finallyTag, finallyBlocks);

			var catchRegions = new List<ExceptionHandlerRegion>(ehBlocks.Count);
			foreach (var tag in ehBlocks)
			{
				catchRegions.Add(ehRegions[tag]);
			}

			Subgraphs[Tag] = new ExceptionFlowGraph(tryRegion, finallyRegion, catchRegions);
		}

		/// <summary>
		/// Finds the set of all exception flow graphs
		/// in this basic block.
		/// </summary>
		public [ExceptionFlowGraph] FindExceptionFlowGraphs()
		{
			var results = new Dictionary<UniqueTag, ExceptionFlowGraph>();
			foreach (var block in Blocks)
			{
				if (block.Flow is TryFlow)
				{
					var flow = (TryFlow)block.Flow;
					ExploreExceptionFlowGraph(flow.Branch.TargetTag, results);
				}
			}
			return results.Values;
		}
	}
}
