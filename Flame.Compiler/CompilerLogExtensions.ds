using System;
using System.Collections.Generic;
using System.Text;
using Pixie;

namespace Flame.Compiler
{
    public static class CompilerLogExtensions
    {
        /// <summary>
        /// Logs an error to the compiler log based on the given error message.
        /// </summary>
        public static void LogError(this ICompilerLog Log, string Message)
        {
            Log.LogError(new LogEntry(Message));
        }

        /// <summary>
        /// Logs an event to the compiler log based on the given event name.
        /// </summary>
        public static void LogEvent(this ICompilerLog Log, string EventName)
        {
            Log.LogEvent(new LogEntry(EventName));
        }

        /// <summary>
        /// Logs an exception to the compiler log as an error.
        /// </summary>
        public static void LogException(this ICompilerLog Log, Exception ex)
        {
            var entry = new LogEntry("Exception", ex.ToString());
            Log.LogError(entry);
        }

        /// <summary>
        /// "Concatenates" two source locations.
        /// The resulting source location is a source location that contains every
        /// position the argument locations contain, as well as every position inbetween.
        /// The resulting location's source document is the right-hand argument's document
        /// if the left-hand's document is null. Otherwise, it is the left-hand argument's
        /// document.
        /// </summary>
        public static const SourceLocation Concat(this SourceLocation Location, SourceLocation Other)
        {
            if (Location == null || Location.Position < 0) return Other;
            else if (Other == null || Other.Position < 0) return Location;

            int pos = Math.Min(Location.Position, Other.Position);
            int len = Math.Max(Location.Position + Location.Length, Other.Position + Other.Length) - pos;
            if (Location.Document == null)
            {
                return new SourceLocation(Other.Document, pos, len);
            }
            else
            {
                return new SourceLocation(Location.Document, pos, len);
            }
        }

        /// <summary>
        /// Creates a source code diagnostics node.
        /// </summary>
        public static const IMarkupNode CreateDiagnosticsNode(this SourceLocation Location)
        {
            if (Location == null)
            {
                return new MarkupNode(NodeConstants.TextNodeType, "");
            }

            var doc = Location.Document;
            var gridPos = Location.GridPosition;
            var posNode = CreateLineNumberNode(doc, gridPos);
            if (gridPos.Line < 0)
            {
                return posNode;
            }

            var srcNode = CreateSourceNode(doc, gridPos, Location.Length);

            var totalNode = new MarkupNode(NodeConstants.DiagnosticsNodeType, new IMarkupNode[]
            {
                srcNode, posNode
            });

            return totalNode;
        }

        public static const IMarkupNode CreateSourceNode(this SourceLocation Location)
        {
            var doc = Location.Document;
            var gridPos = Location.GridPosition;
            if (gridPos.Line < 0)
            {
                return new MarkupNode(NodeConstants.TextNodeType, "");
            }

            return CreateSourceNode(doc, gridPos, Location.Length);
        }

        public static const IMarkupNode CreateSourceNode(ISourceDocument doc, SourceGridPosition gridPos, int Length)
        {
            string lineText = doc.GetLine(gridPos.Line);
            int offset = gridPos.Offset;
            int length = Math.Min(Length, lineText.Length - offset);
            var preTextNode = new MarkupNode(NodeConstants.TextNodeType, lineText.Substring(0, offset));
            string highlightedText = lineText.Substring(offset, length);
            if (string.IsNullOrWhiteSpace(highlightedText))
            {
                highlightedText = " "; // Make sure we have at least a whitespace
                                       // character to highlight.
            }
            var highlightTextNode = new MarkupNode(NodeConstants.HighlightNodeType, highlightedText);
            var postTextNode = new MarkupNode(NodeConstants.TextNodeType, lineText.Substring(offset + length));

            var srcNode = new MarkupNode(NodeConstants.SourceNodeType, new IMarkupNode[]
            {
                preTextNode, highlightTextNode, postTextNode
            });

            return srcNode;
        }

        public static const IMarkupNode CreateLineNumberNode(this SourceLocation Location)
        {
            return Location.CreateLineNumberNode(NodeConstants.RemarksNodeType);
        }

        public static const IMarkupNode CreateLineNumberNode(this SourceLocation Location, string NodeType)
        {
            var doc = Location.Document;
            var gridPos = Location.GridPosition;
            return CreateLineNumberNode(doc, gridPos, NodeType);
        }

        public static const IMarkupNode CreateLineNumberNode(ISourceDocument Document, SourceGridPosition Position)
        {
            return CreateLineNumberNode(Document, Position, NodeConstants.RemarksNodeType);
        }

        public static const IMarkupNode CreateLineNumberNode(ISourceDocument Document, SourceGridPosition Position, string NodeType)
        {
            var text = new StringBuilder();
            text.Append("In '");
            text.Append(Document.Identifier);
            text.Append("'");
            if (Position.Line > -1)
            {
                text.Append(" on line ");
                text.Append(Position.Line + 1);
                if (Position.Offset > -1)
                {
                    text.Append(", column ");
                    text.Append(Position.Offset + 1);
                }
            }
            text.Append('.');
            return new MarkupNode(NodeType, text.ToString());
        }
    }
}
