using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Expressions
{
    public class NotExpression : UnaryOperatorExpression
    {
        public const this(IExpression Value)
            : base(Value);

        public override Operator Op { const get return Operator.Not; }

        protected override IExpression Create(IExpression Operand)
        {
            return new NotExpression(Operand);
        }

        public override IBoundObject Evaluate()
        {
            var boundObject = Value.Evaluate();
            if (boundObject == null)
                return null;
            if (Value.Type.Equals(PrimitiveTypes.Boolean))
            {
                return new BooleanExpression(!boundObject.GetPrimitiveValue<bool>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int8))
            {
                return new Int8Expression(~boundObject.GetPrimitiveValue<int8>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt8))
            {
                return new UInt8Expression(~boundObject.GetPrimitiveValue<uint8>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Bit8))
            {
                return new Bit8Expression(~boundObject.GetPrimitiveValue<bit8>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int16))
            {
                return new Int16Expression(~boundObject.GetPrimitiveValue<int16>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt16))
            {
                return new UInt16Expression(~boundObject.GetPrimitiveValue<uint16>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Bit16))
            {
                return new Bit16Expression(~boundObject.GetPrimitiveValue<bit16>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int32))
            {
                return new Int32Expression(~boundObject.GetPrimitiveValue<int32>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt32))
            {
                return new UInt32Expression(~boundObject.GetPrimitiveValue<uint32>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Bit32))
            {
                return new Bit32Expression(~boundObject.GetPrimitiveValue<bit32>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Int64))
            {
                return new Int64Expression(~boundObject.GetPrimitiveValue<int64>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.UInt64))
            {
                return new UInt64Expression(~boundObject.GetPrimitiveValue<uint64>());
            }
            else if (Value.Type.Equals(PrimitiveTypes.Bit64))
            {
                return new Bit64Expression(~boundObject.GetPrimitiveValue<bit64>());
            }
            else
            {
                return null;
            }
        }

        public override IExpression Optimize()
        {
            var optVal = Value.Optimize();
            var optExpr = new NotExpression(optVal);
            if (optExpr.IsConstant && optExpr.Type.IsPrimitiveExpressionType())
            {
                var evalExpr = optExpr.Evaluate();
                if (evalExpr != null)
                   return evalExpr.ToExpression();
            }
            if (optVal is NotExpression)
            {
                return ((NotExpression)optVal).Value;
            }
            else if (optVal is EqualityExpression)
            {
            	var ceq = ((EqualityExpression)optVal);
            	return new InequalityExpression(ceq.LeftOperand, ceq.RightOperand);
            }
            else if (optVal is InequalityExpression)
            {
            	var cne = ((InequalityExpression)optVal);
            	return new EqualityExpression(cne.LeftOperand, cne.RightOperand);
            }
            else if (optVal is LessThanExpression)
            {
                var clt = (LessThanExpression)optVal;
                return new GreaterThanOrEqualsExpression(clt.LeftOperand, clt.RightOperand);
            }
            else if (optVal is GreaterThanExpression)
            {
                var cgt = (GreaterThanExpression)optVal;
                return new LessThanOrEqualsExpression(cgt.LeftOperand, cgt.RightOperand);
            }
            else if (optVal is GreaterThanOrEqualsExpression)
            {
                var cge = (GreaterThanOrEqualsExpression)optVal;
                return new LessThanExpression(cge.LeftOperand, cge.RightOperand);
            }
            else if (optVal is LessThanOrEqualsExpression)
            {
                var cle = (LessThanOrEqualsExpression)optVal;
                return new GreaterThanExpression(cle.LeftOperand, cle.RightOperand);
            }
            else
            {
                return optExpr;
            }
        }
    }
}
