using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
	public abstract class BinaryExpression : IExpression, IPredicateNode
	{
		public const this();
		public const this(set IExpression LeftOperand, set IExpression RightOperand);

		public IExpression LeftOperand { const get; protected set; }
		public IExpression RightOperand { const get; protected set; }

		protected virtual IType GetExpressionType() { return LeftOperand.Type; }

		private IType cachedType;
		public virtual IType Type
		{
			virtual const get
			{
				if (cachedType == null)
				{
					cachedType = GetExpressionType();
				}
				return cachedType;
			}
		}

		public virtual bool IsConstant
		{
			virtual const get
			{
				return LeftOperand.IsConstant && RightOperand.IsConstant && LeftOperand.Type.IsPrimitiveExpressionType() && RightOperand.Type.IsPrimitiveExpressionType();
			}
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(LeftOperand);
			Visitor.Visit(RightOperand);
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			var transLeft = Visitor.Visit(LeftOperand);
			var transRight = Visitor.Visit(RightOperand);
			if (transLeft == LeftOperand && transRight == RightOperand)
			{
				return this;
			}
			else
			{
				return Create(transLeft, transRight);
			}
		}

		protected abstract const IExpression Create(IExpression Left, IExpression Right);

		public abstract const IBoundObject Evaluate();
		public abstract const IExpression Optimize();
		public abstract const ICodeBlock Emit(ICodeGenerator Generator);
	}

	public abstract class BinaryOperatorExpression : BinaryExpression, IMemberNode
	{
		public const this();
		public const this(set IExpression LeftOperand, set IExpression RightOperand);

		protected abstract Operator GetOperator();
		public Operator Op { const get return GetOperator(); }

		public IMemberNode ConvertMembers(MemberConverter Converter)
		{
			if (OperatorOverload != null)
			{
				Converter.Convert(OperatorOverload); // We are really just doing the
													 // member converter a favor here.
													 // Visiting the operator overload
													 // should not and cannot change
													 // the binary expression.
													 // It is, however, useful for
													 // recompilation.
			}
			return this;
		}

		/// <summary>
		/// Gets the operator overload for this binary expression if an overload exists. Otherwise, null.
		/// </summary>
		protected virtual IMethod GetOpOverload()
		{
			return Op.GetOperatorOverload(new IExpression[] { LeftOperand, RightOperand });
		}

		private IMethod opOverload;
		/// <summary>
		/// Gets the operator overload for this binary expression if an overload exists. Otherwise, null.
		/// </summary>
		public IMethod OperatorOverload
		{
			const get
			{
				if (opOverload == null)
				{
					opOverload = GetOpOverload();
				}
				return opOverload;
			}
		}

		protected IExpression OverloadInvocation
		{
			const get
			{
				if (OperatorOverload == null) return null;
				else return new RelaxedInvocation(OperatorOverload, new IExpression[] { LeftOperand, RightOperand });
			}
		}

		protected virtual override IType GetExpressionType()
		{
			if (OperatorOverload != null) return OperatorOverload.ReturnType;
			else return LeftOperand.Type;
		}

		protected virtual const ICodeBlock EmitPrimitive(ICodeBlock Left, ICodeBlock Right, ICodeGenerator Generator)
		{
			return Generator.EmitBinary(Left, Right, Op);
		}

		protected override const IExpression Create(IExpression Left, IExpression Right)
		{
			return new DirectBinaryExpression(Left, Op, Right).LoweredExpression;
		}

		public virtual override const ICodeBlock Emit(ICodeGenerator Generator)
		{
			var lBlock = LeftOperand.Emit(Generator);
			var rBlock = RightOperand.Emit(Generator);
			var primBlock = EmitPrimitive(lBlock, rBlock, Generator);
			if (primBlock != null)
			{
				return primBlock;
			}
			else if (OperatorOverload != null)
			{
				return OverloadInvocation.Emit(Generator);
			}
			else
			{
				return null;
			}
		}

		public override const string ToString()
		{
			return "binary(\"" + Op + "\", " + LeftOperand + ", " + RightOperand + ")"; 
		}
	}

	public class PrimitiveBinaryExpression : BinaryExpression
	{
		public const this(set IExpression LeftOperand, set Operator Op, set IExpression RightOperand, set IType exprType);

		public Operator Op { const get; private set; }

		private IType exprType;
		public override IType Type
		{
			override const get
			{
				return exprType;
			}
		}

		public override bool IsConstant
		{
			override const get
			{
				return false;
			}
		}

		protected override const IExpression Create(IExpression Left, IExpression Right)
		{
			return new PrimitiveBinaryExpression(Left, Op, Right, exprType);
		}

		public override const IBoundObject Evaluate()
		{
			return null;
		}
		public override const IExpression Optimize()
		{
			return new PrimitiveBinaryExpression(LeftOperand.Optimize(), Op, RightOperand.Optimize(), Type);
		}
		public override const ICodeBlock Emit(ICodeGenerator Generator)
		{
			return Generator.EmitBinary(LeftOperand.Emit(Generator), RightOperand.Emit(Generator), Op);
		}
	}

	/// <summary>
	/// Defines a binary expression that selects the most appropriate operator
	/// or overload for the given arguments, and will try to lower itself to
	/// a more primitive expression if possible.
	/// </summary>
	public class DirectBinaryExpression : BinaryOperatorExpression
	{
		public const this(set IExpression LeftOperand, Operator Op, set IExpression RightOperand)
		{
			this.oper = Op;
		}

		private Operator oper;
		protected override Operator GetOperator() { return oper; }

		protected override IType GetExpressionType()
		{
			if (CanLower) return LoweredExpression.Type;
			else if (OperatorOverload != null) return OperatorOverload.ReturnType;
			else return LeftOperand.Type;
		}

		public override bool IsConstant
		{
			override const get
			{
				if (CanLower) return LoweredExpression.IsConstant;
				else return OperatorOverload.IsConstant && LeftOperand.IsConstant && RightOperand.IsConstant;
			}
		}

		private IExpression loweredExpr;
		public IExpression LoweredExpression
		{
			const get
			{
				if (loweredExpr == null)
					loweredExpr = ToBinaryExpression(LeftOperand, Op, RightOperand);
				return loweredExpr;
			}
		}

		public bool CanLower
		{
			const get return !(LoweredExpression is DirectBinaryExpression);
		}

		public static const IExpression ToBinaryExpression(IExpression LeftOperand, Operator Op, IExpression RightOperand)
		{
			if (Op == Operator.Add)
				return new AddExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Subtract)
				return new SubtractExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Multiply)
				return new MultiplyExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Divide)
				return new DivideExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Remainder)
				return new RemainderExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Or)
				return new OrExpression(LeftOperand, RightOperand);
			else if (Op == Operator.And)
				return new AndExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Xor)
				return new XorExpression(LeftOperand, RightOperand);
			else if (Op == Operator.LogicalOr)
				return new LazyOrExpression(LeftOperand, RightOperand);
			else if (Op == Operator.LogicalAnd)
				return new LazyAndExpression(LeftOperand, RightOperand);
			else if (Op == Operator.RightShift)
				return new RightShiftExpression(LeftOperand, RightOperand);
			else if (Op == Operator.LeftShift)
				return new LeftShiftExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckEquality)
				return new EqualityExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckInequality)
				return new InequalityExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckGreaterThan)
				return new GreaterThanExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckLessThan)
				return new LessThanExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckGreaterThanOrEqual)
				return new GreaterThanOrEqualsExpression(LeftOperand, RightOperand);
			else if (Op == Operator.CheckLessThanOrEqual)
				return new LessThanOrEqualsExpression(LeftOperand, RightOperand);
			else if (Op == Operator.Concat)
				return new ConcatExpression(LeftOperand, RightOperand);
			else
				return new DirectBinaryExpression(LeftOperand, Op, RightOperand);
		}

		public override const IBoundObject Evaluate()
		{
			if (CanLower) return LoweredExpression.Evaluate();
			else if (OperatorOverload == null) return null;
			else
			{
				return OverloadInvocation.Evaluate();
			}
		}
		public override const IExpression Optimize()
		{
			if (CanLower) return LoweredExpression.Optimize();
			else return new DirectBinaryExpression(LeftOperand.Optimize(), Op, RightOperand.Optimize());
		}
		public override const ICodeBlock Emit(ICodeGenerator Generator)
		{
			if (CanLower) return LoweredExpression.Emit(Generator);
			else
			{
				var lblock = LeftOperand.Emit(Generator);
				var rblock = RightOperand.Emit(Generator);
				var primBlock = EmitPrimitive(lblock, rblock, Generator);
				if (primBlock != null)
				{
					return primBlock;
				}
				else if (OperatorOverload != null)
				{
					return OverloadInvocation.Emit(Generator);
				}
				else
				{
					return null;
				}
			}
		}
	}
}
