using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// Defines an is-expression, which is an expression that tests if a value
    /// is an instance of a given type.
    /// </summary>
    public class IsExpression : IExpression, IMemberNode, IPredicateNode
    {
        /// <summary>
        /// Creates an is-expression from the given expression and type.
        /// </summary>
        public const this(set IExpression Target, set IType TestType);

        /// <summary>
        /// Gets the value that is tested against the given type.
        /// </summary>
        public IExpression Target { const get; private set; }

        /// <summary>
        /// Gets the type to test against.
        /// </summary>
        public IType TestType { const get; private set; }

        public IMemberNode ConvertMembers(MemberConverter Converter)
        {
            var convType = Converter.Convert(TestType);
            if (object.ReferenceEquals(convType, TestType))
            {
                return this;
            }
            else return new IsExpression(Target, convType);
        }

        public void AcceptPredicate(INodeVisitor Visitor)
        {
            Visitor.Visit(Target);
        }

        public IExpression Accept(INodeVisitor Visitor)
        {
            var transVal = Visitor.Visit(Target);

            if (transVal == Target)
            {
                return this;
            }
            else
            {
                return new IsExpression(transVal, TestType);
            }
        }

        public IType Type
        {
            const get { return PrimitiveTypes.Boolean; }
        }

        public bool IsConstantNode
        {
            const get { return true; }
        }

        public IBoundObject Evaluate()
        {
        	var eval = Target.Evaluate();
        	if (eval == null)
                return null;

        	var evalType = eval.Type;
        	if (evalType.Equals(PrimitiveTypes.Null))
                return new BooleanExpression(TestType.Equals(PrimitiveTypes.Null));
            else
                return new BooleanExpression(evalType.Is(TestType));
        }

        public IExpression Optimize()
        {
            var optTarget = Target.Optimize();
            if (optTarget.IsConstant)
            {
                var evalTarget = optTarget.Evaluate();
                if (evalTarget != null)
                    return new BooleanExpression(evalTarget.Type.Is(TestType));
            }
            var targetType = optTarget.Type;
            if (targetType.IsReferenceType && targetType.Is(TestType))
            {
                // `x is T` is equivalent to `x != null` if `typeof(x) : T`
                return new InequalityExpression(
                    optTarget,
                    new ReinterpretCastExpression(NullExpression, targetType));
            }
            else
            {
                return new IsExpression(optTarget, TestType);
            }
        }

        public ICodeBlock Emit(ICodeGenerator Generator)
        {
            var targetBlock = Target.Emit(Generator);
            var isInst = Generator.EmitTypeBinary(targetBlock, TestType, Operator.IsInstance);
            if (isInst == null)
            {
                // We can always try to create an `as_instance(value, type) != null` block
                // if the code generator refuses to create an
                // `is_instance(value, type)` block.
                var asInst = Generator.EmitTypeBinary(targetBlock, TestType, Operator.AsInstance);
                if (asInst != null)
                {
                    return Generator.EmitNotEquals(asInst, Generator.EmitNull());
                }
            }
            return isInst;
        }

        public override const string ToString()
        {
            return "is_instance(" + Target + ", " + TestType.ToString() + ")";
        }
    }
}
