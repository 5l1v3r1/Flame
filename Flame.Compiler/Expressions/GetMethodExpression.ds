using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Expressions
{
	public class GetMethodExpression : IDelegateExpression
	{
		public const this(set IMethod Target, set IExpression Caller);

		public IExpression Caller { const get; private set; }
		public IMethod Target { const get; private set; }

		public [IType] ParameterTypes { const get return Target.GetParameters().GetTypes(); }

		public IType ReturnType
		{
			const get return Target.ReturnType;
		}

		public const IExpression CreateInvocationExpression([IExpression] Arguments)
		{
			return new InvocationExpression(this, Arguments);
		}

		public const IDelegateExpression MakeGenericExpression([IType] TypeArguments)
		{
			return new GetMethodExpression(Target.MakeGenericMethod(TypeArguments), Caller);
		}

		public IMemberNode ConvertMembers(MemberConverter Converter)
		{
			var convMethod = Converter.Convert(Target);
			if (object.ReferenceEquals(Target, convMethod))
			{
				return this;
			}
			else return new GetMethodExpression(convMethod, Caller);
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			if (Caller == null) return this;

			var transCaller = Visitor.Visit(Caller);

			if (transCaller == Caller)
			{
				return this;
			}
			else
			{
				return new GetMethodExpression(Target, transCaller);
			}
		}

		public IType Type
		{
			const get
			{
				return MethodType.Create(Target);
			}
		}

		public bool IsConstant
		{
			const get
			{
				return Target.IsConstant && Caller.IsConstantOrNull;
			}
		}

		public const IBoundObject Evaluate()
		{
			return new BoundMethod(Target, Caller.EvaluateOrNull());
		}

		public IExpression Optimize()
		{
			var callerExpr = Caller.OptimizeOrNull();
			return new GetMethodExpression(Target, callerExpr);
		}

		public ICodeBlock Emit(ICodeGenerator Generator)
		{
			return Generator.EmitMethod(Target, Caller.EmitOrNull(Generator));
		}
	}
}
