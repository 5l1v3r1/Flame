using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
	/// <summary>
	/// A type of expression that invokes a delegate expression by passing
	/// it a list of arguments.
	/// </summary>
	public class InvocationExpression : IExpression, IPredicateNode
	{
		/// <summary>
		/// Creates an invocation expression that invokes the given delegate
		/// expression with the given argument list.
		/// </summary>
		public const this(set IExpression Target, set [IExpression] Arguments);

		/// <summary>
		/// Creates an invocation expression that calls the given method
		/// with the given argument list. Virtual methods will be called
		/// through dynamic invocation, nonvirtual methods will result in a
		/// direct call.
		/// </summary>
		public const this(IMethod Target, IExpression Caller, set [IExpression] Arguments)
		{
			this.Target = new GetMethodExpression(Target, Caller);
		}

		/// <summary>
		/// Gets the delegate expression that is invoked by passing it
		/// an argument list.
		/// </summary>
		public IExpression Target { const get; private set; }

		/// <summary>
		/// Gets the argument list to invoke the delegate with.
		/// </summary>
		public [IExpression] Arguments { const get; private set; }

		/// <summary>
		/// Gets the method signature of the delegate expression to invoke.
		/// </summary>
		public IMethod Method
		{
			get { return MethodType.GetMethod(Target.Type); }
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(Target);
			Visitor.VisitAll(Arguments);
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			var transTarget = Visitor.Visit(Target);
			var transArgs = Visitor.VisitAll(Arguments);

			return new InvocationExpression(transTarget, transArgs);
		}

		private bool HasNullObject
		{
			get
			{
				var target = Target.GetEssentialExpression();
				if (target is GetMethodExpression)
					return ((GetMethodExpression)target).Caller == null;
				else
					return false;
			}
		}

		private bool IsNewObjectCall
		{
			get
			{
				return Method.IsConstructor && HasNullObject;
			}
		}

		public IType Type
		{
			const get
			{
				if (IsNewObjectCall)
					return Method.DeclaringType;
				else
					return Method.ReturnType;
			}
		}

		public bool IsConstantNode
		{
			get
			{
				// Invocations of constant methods are always constant.
				// Invocations of constant constructors are constant only if
				// the call object is null.
				return Method.IsConstant && (!Method.IsConstructor || HasNullObject);
			}
		}

		public IBoundObject Evaluate()
		{
			var targetObj = Target.Evaluate();
			if (!(targetObj is IBoundMethod)) return null;

			var allArgs = Arguments.EvaluateAll();
			foreach (var item in allArgs)
				if (item == null)
			{
				return null;
			}
			return ((IBoundMethod)targetObj).Invoke(allArgs);
		}

		private IExpression GetInnerExpression(IExpression Expression)
		{
			if (Expression is ConversionExpressionBase)
				return GetInnerExpression(((ConversionExpressionBase)Expression).Value);
			else if (Expression is IMetadataNode<IExpression>)
				return GetInnerExpression(((IMetadataNode<IExpression>)Expression).Value);
			else
				return Expression;
		}

		private IExpression RemoveRedundantConversions(IExpression Expression)
		{
			var innerExpr = GetInnerExpression(Expression);
			if (innerExpr is IDelegateExpression)
				return innerExpr;
			else
				return Expression;
		}

		public InvocationExpression Simplify()
		{
			return new InvocationExpression(
				RemoveRedundantConversions(Target), Arguments);
		}

		public IExpression Optimize()
		{
			var targetExpr = RemoveRedundantConversions(Target.Optimize());
			var argExprs = Arguments.OptimizeAll();

			return new InvocationExpression(targetExpr, argExprs);
		}

		public ICodeBlock Emit(ICodeGenerator Generator)
		{
			return Generator.EmitInvocation(Target.Emit(Generator), Arguments.EmitAll(Generator));
		}
	}
}
