using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
	public class InvocationExpression : IExpression, IPredicateNode
	{
		public const this(set IExpression Target, set [IExpression] Arguments);
		public const this(IMethod Target, IExpression Caller, set [IExpression] Arguments)
		{
			this.Target = new GetMethodExpression(Target, Caller);
		}

		public IExpression Target { const get; private set; }
		public [IExpression] Arguments { const get; private set; }

		public IMethod Method
		{
			const get return MethodType.GetMethod(Target.Type);
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(Target);
			Visitor.VisitAll(Arguments);
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			var transTarget = Visitor.Visit(Target);
			var transArgs = Visitor.VisitAll(Arguments);

			return new InvocationExpression(transTarget, transArgs);
		}

		public IType Type
		{
			const get
			{
				if (Method.IsConstructor)
				{
					return Method.DeclaringType;
				}
				else
				{
					return Method.ReturnType;
				}
			}
		}

		public bool IsConstant
		{
			const get
			{
				return Target.IsConstant && Arguments.AreConstant;
			}
		}

		public IBoundObject Evaluate()
		{
			var targetObj = Target.Evaluate();
			if (!(targetObj is IBoundMethod)) return null;

			var allArgs = Arguments.EvaluateAll();
			foreach (var item in allArgs)
				if (item == null)
			{
				return null;
			}
			return ((IBoundMethod)targetObj).Invoke(allArgs);
		}

		private const IExpression GetInnerExpression(IExpression Expression)
		{
			if (Expression is ConversionExpressionBase)
				return GetInnerExpression(((ConversionExpressionBase)Expression).Value);
			else
				return Expression;
		}

		private const IExpression RemoveRedundantConversions(IExpression Expression)
		{
			var innerExpr = GetInnerExpression(Expression);
			if (innerExpr is IDelegateExpression)
				return innerExpr;
			else
				return Expression;
		}

		public IExpression Optimize()
		{
			var targetExpr = RemoveRedundantConversions(Target.Optimize());
			var argExprs = Arguments.OptimizeAll();

			return new InvocationExpression(targetExpr, argExprs);
		}

		public ICodeBlock Emit(ICodeGenerator Generator)
		{
			return Generator.EmitInvocation(Target.Emit(Generator), Arguments.EmitAll(Generator));
		}
	}
}
