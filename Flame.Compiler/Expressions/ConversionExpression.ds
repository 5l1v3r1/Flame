using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
    public class ConversionExpression : IExpression
    {
        public const this(set IExpression Value)
        {
            this.Type = Value.Type;
        }
        public const this(set IExpression Value, set IType Type);

        public IExpression Value { const get; private set; }
        public IType Type { const get; private set; }

        public IExpression Accept(INodeVisitor Visitor)
        {
            var transVal = Visitor.Visit(Value);

            if (transVal == Value)
            {
                return this;
            }
            else
            {
                return new ConversionExpression(transVal, Type);
            }
        }

        public static const IExpression Create(IExpression Value, IType Type)
        {
            var interExpr = IntersectionExpression.FilterIntersection(Value, Type);

            if (!RequiresConversion(interExpr.Type, Type))
            {
                return interExpr;
            }
            else
            {
                return new ConversionExpression(interExpr, Type);
            }
        }

        public bool IsConstant
        {
            const get
            {
            	if (!ConversionNeeded)
            		return Value.IsConstant;
            	else
            		return Value.IsConstant && Value.Type.IsPrimitiveExpressionType() && Type.IsPrimitiveExpressionType();
           	}
        }

        /// <summary>
        /// Gets a boolean value that indicates whether the given source type must be converted to legally be assigned to a variable of the target type.
        /// </summary>
        public static const bool RequiresConversion(IType SourceType, IType TargetType)
        {
        	if (SourceType.Equals(TargetType) || (SourceType.Equals(PrimitiveTypes.Null) && (TargetType.IsReferenceType || TargetType.IsPointer)))
        	{
        		return false;
        	}
        	else if (SourceType.IsValueType || TargetType.IsValueType ||
        		    SourceType.IsGenericParameter || TargetType.IsGenericParameter ||
        		    SourceType.IsPrimitive || TargetType.IsPrimitive ||
                    SourceType.IsDelegate && TargetType.IsDelegate ||
                    SourceType.IsIntersectionType)
        	{
        		return true;
        	}
        	else
        	{
        		return !SourceType.Is(TargetType);
        	}
        }

        private bool ConversionNeeded
        {
        	const get
            {
            	if (Type == null)
            	{
            		return false;
            	}
            	else
            	{
            		return RequiresConversion(Value.Type, Type);
            	}
        	}
        }

        public IBoundObject Evaluate()
        {
            var normalVal = Value.Evaluate();
            if (!ConversionNeeded)
            {
                return normalVal;
            }
            else
            {
            	object objVal = normalVal.GetObjectValue();
            	if (Type.Equals(PrimitiveTypes.UInt8))
	            {
	            	return new UInt8Expression(Convert.ToByte(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Int8))
	            {
	            	return new Int8Expression(Convert.ToSByte(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Bit8))
	            {
	            	return new Bit8Expression((bit8)Convert.ToByte(objVal));
	            }
            	else if (Type.Equals(PrimitiveTypes.UInt16))
	            {
	            	return new UInt16Expression(Convert.ToUInt16(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Int16))
	            {
	            	return new Int16Expression(Convert.ToInt16(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Bit16))
	            {
	            	return new Bit16Expression((bit16)Convert.ToUInt16(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.UInt32))
	            {
	            	return new UInt32Expression(Convert.ToUInt32(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Int32))
	            {
	            	return new Int32Expression(Convert.ToInt32(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Bit32))
	            {
	            	return new Bit32Expression((bit32)Convert.ToUInt32(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.UInt64))
	            {
	            	return new UInt64Expression(Convert.ToUInt64(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Int64))
	            {
	            	return new Int64Expression(Convert.ToInt64(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Bit64))
	            {
	            	return new Bit64Expression((bit64)Convert.ToUInt64(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Float32))
	            {
	            	return new Float32Expression(Convert.ToSingle(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Float64))
	            {
	            	return new Float64Expression(Convert.ToDouble(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Boolean))
	            {
	            	return new BooleanExpression(Convert.ToBoolean(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.Char))
	            {
	            	return new CharExpression(Convert.ToChar(objVal));
	            }
	            else if (Type.Equals(PrimitiveTypes.String))
	            {
	            	return new StringExpression(objVal.ToString());
	            }
	            else
	            {
	            	return null;
	            }
            }
        }

        public const IExpression Optimize()
        {
            var optVar = Value.Optimize();
            if (!ConversionNeeded)
            {
                return optVar;
            }
            var optExpr = new ConversionExpression(optVar, Type);
            if (optExpr.IsConstant)
            {
            	return optExpr.Evaluate().ToExpression();
            }
            return optExpr;
        }

        public ICodeBlock Emit(ICodeGenerator Generator)
        {
            var valueBlock = Value.Emit(Generator);
            if (!ConversionNeeded)
            {
                return valueBlock;
            }
            else
            {
                return Generator.EmitConversion(valueBlock, Type);
            }
        }
    }
}
