using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// A base class for conversion expressions.
    /// </summary>
    public abstract class ConversionExpressionBase : IExpression, IMemberNode, IPredicateNode
    {
        /// <summary>
        /// Creates a conversion expression that converts the given value
        /// to the given type.
        /// </summary>
        public const this(set IExpression Value, set IType TargetType);

        /// <summary>
        /// Gets the value that is to be converted to the given type.
        /// </summary>
        public IExpression Value { const get; private set; }

        /// <summary>
        /// Gets the type the value is to be converted to.
        /// </summary>
        public IType TargetType { const get; private set; }

        /// <summary>
        /// Gets the conversion expression's type, which is the same as its
        /// target type.
        /// </summary>
        public IType Type { const get { return TargetType; } }

        /// <summary>
        /// Creates a new conversion expression that converts the given
        /// value to the given type.
        /// </summary>
        protected abstract ConversionExpressionBase Create(IExpression NewValue, IType NewType);

        /// <summary>
        /// Tells if this conversion expression does not have side-effects.
        /// </summary>
        public abstract bool IsConstantNode { get; }

        /// <summary>
        /// Evaluates this conversion expression at compile-time.
        /// </summary>
        public abstract IBoundObject Evaluate();

        /// <summary>
        /// Creates a code block for this conversion expression.
        /// </summary>
        public abstract ICodeBlock Emit(ICodeGenerator CodeGenerator);

        public IMemberNode ConvertMembers(MemberConverter Converter)
        {
            var elemType = Converter.Convert(Type);
            if (object.ReferenceEquals(elemType, Type))
                return this;
            else
                return Create(Value, elemType);
        }

        public void AcceptPredicate(INodeVisitor Visitor)
        {
            Visitor.Visit(Value);
        }

        public IExpression Accept(INodeVisitor Visitor)
        {
            var transVal = Visitor.Visit(Value);

            if (transVal == Value)
                return this;
            else
                return Create(transVal, TargetType);
        }

        /// <summary>
        /// Optimizes this conversion expression.
        /// </summary>
        public virtual IExpression Optimize()
        {
            var optVal = Value.Optimize();
            if (optVal.Type.IsEquivalent(TargetType))
                return optVal;

            var optExpr = Create(optVal, Type).Simplify();
            if (optExpr.IsConstant)
            {
                var evalExpr = optExpr.Evaluate();
                if (evalExpr != null)
                    return evalExpr.ToExpression();
            }

            return optExpr;
        }

        /// <summary>
        /// Tries to apply simple node-based simplifications.
        /// </summary>
        public virtual IExpression Simplify()
        {
            return this;
        }
    }

    /// <summary>
    /// A helper class that creates conversion expressions.
    /// </summary>
    public static class ConversionExpression
    {
        /// <summary>
        /// Creates an expression that converts the given value to the given type.
        /// </summary>
        public IExpression Create(IExpression Value, IType Type)
        {
            var interExpr = IntersectionExpression.FilterIntersection(Value, Type);
            var interType = interExpr.Type;
            if (interType.IsEquivalent(Type))
            {
                return interExpr;
            }
            else if (UseDynamicCast(interType, Type))
            {
                if (UseReinterpretAsDynamicCast(interType, Type))
                {
                    return new ReinterpretCastExpression(interExpr, Type);
                }
                else
                {
                    return new DynamicCastExpression(interExpr, Type);
                }
            }
            else
            {
                return new StaticCastExpression(interExpr, Type);
            }
        }

        private bool IsSpecialType(IType Type)
        {
            return Type.IsDelegate || Type.IsPrimitive || Type.IsIntersectionType;
        }

        /// <summary>
        /// Tests if a value of the given source type can be cast dynamically to a value
        /// of the given target type.
        /// </summary>
        public bool UseDynamicCast(IType SourceType, IType TargetType)
        {
            return (SourceType.Equals(PrimitiveTypes.Null)
                    || SourceType.IsReferenceType
                    || SourceType.IsPointer
                    || (SourceType.IsGenericParameter && !SourceType.Is(TargetType)))
                && !IsSpecialType(SourceType) && !IsSpecialType(TargetType);
        }

        /// <summary>
        /// Tests if a value of the given source type can safely be cast to a value
        /// of the given target type using a reinterpret cast, provided that it
        /// can already be used in the context of a dynamic cast.
        /// </summary>
        public bool UseReinterpretAsDynamicCast(IType SourceType, IType TargetType)
        {
            return SourceType.Is(TargetType);
        }

        /// <summary>
        /// Tests if a value of the given source type can safely be cast to a value
        /// of the given target type using a reinterpret cast.
        /// </summary>
        public bool UseReinterpretCast(IType SourceType, IType TargetType)
        {
            return UseDynamicCast(SourceType, TargetType)
                && UseReinterpretAsDynamicCast(SourceType, TargetType);
        }
    }
}
