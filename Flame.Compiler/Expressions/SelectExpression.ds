using System;
using System.Collections.Generic;

namespace Flame.Compiler.Expressions
{
	public class SelectExpression : IExpression, IFlowExpression
	{
		public this(set IExpression Condition, set IExpression TrueValue, set IExpression FalseValue);

		public IExpression Condition { const get; private set; }
		public IExpression TrueValue { const get; private set; }
		public IExpression FalseValue { const get; private set; }

        public IType Type
        {
            const get return TrueValue.Type;
        }

		private const SelectExpression CreateSelect(IExpression NewCond, IExpression NewIf, IExpression NewElse)
		{
			if (this.Condition == NewCond && this.TrueValue == NewIf &&
				this.FalseValue == NewElse)
			{
				return this;
			}
			else
			{
				return new SelectExpression(NewCond, NewIf, NewElse);
			}
		}

		public IExpression AcceptFlow<TState, TFlow>(IFlowVisitor<TState, TFlow> Visitor)
			: IFlowExpression.AcceptFlow<TState, TFlow>
		{
			var transCond = Visitor.Visit(Condition);
			var startState = Visitor.CurrentFlow;

			var transIf = Visitor.Visit(TrueValue);
			var ifFlow = Visitor.CreateDeltaFlow(startState, Visitor.CurrentFlow);

			Visitor.CurrentFlow = startState; // Reset flow to create else flow
			var transElse = Visitor.Visit(FalseValue);

			var elseFlow = Visitor.CreateDeltaFlow(startState, Visitor.CurrentFlow);

			Visitor.CurrentFlow = Visitor.CreateCollapsedFlow(startState, Visitor.CreateSelectFlow(ifFlow, elseFlow));

			return CreateSelect(transCond, transIf, transElse);
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			var cond = Visitor.Visit(Condition);
			var trueVal = Visitor.Visit(TrueValue);
			var falseVal = Visitor.Visit(FalseValue);

			return CreateSelect(cond, trueVal, falseVal);
		}

        public bool IsConstant
        {
            const get
            {
				var condVal = Condition.EvaluateConstant();
                if (condVal.EvaluatesTo<bool>(true))
                {
                    return TrueValue.IsConstant;
                }
                else if (condVal.EvaluatesTo<bool>(false))
                {
                    return FalseValue.IsConstant;
                }
                else return false;
            }
        }

        public IBoundObject Evaluate()
        {
			var condVal = Condition.EvaluateConstant();
            if (condVal.EvaluatesTo<bool>(true))
            {
                return TrueValue.Evaluate();
            }
            else if (condVal.EvaluatesTo<bool>(false))
            {
                return FalseValue.Evaluate();
            }
            else return null;
        }

		public IExpression Optimize() : IExpression.Optimize
		{
			var optCond = Condition.Optimize();
			var condVal = optCond.EvaluateConstant();

            if (condVal.EvaluatesTo<bool>(true))
            {
                return TrueValue.Optimize();
            }
            else if (condVal.EvaluatesTo<bool>(false))
            {
                return FalseValue.Optimize();
            }

			var optTrue = TrueValue.Optimize();
            var optFalse = FalseValue.Optimize();
            return new SelectExpression(optCond, optTrue, optFalse);
		}

		public ICodeBlock Emit(ICodeGenerator Generator) : IExpression.Emit
		{
			var conditionBlock = Condition.Emit(Generator);
            var trueBlock = TrueValue.Emit(Generator);
            var falseBlock = FalseValue.Emit(Generator);
			return Generator.EmitIfElse(conditionBlock, trueBlock, falseBlock);
		}
	}
}
