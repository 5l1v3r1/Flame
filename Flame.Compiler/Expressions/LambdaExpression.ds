using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler.Emit;
using Flame.Compiler.Visitors;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// Represents a lambda's "header": its signature and capture list.
    /// </summary>
    public class LambdaHeader
    {
        public const this(set IMethod Signature, set IReadOnlyList<IExpression> CaptureList);

        /// <summary>
        /// Gets this lambda expression's signature.
        /// </summary>
        public IMethod Signature { const get; private set; }

        /// <summary>
        /// Gets the lambda expression's list of captured variables.
        /// </summary>
        public IReadOnlyList<IExpression> CaptureList { const get; private set; }

        public LambdaHeader Apply(IExpression(IExpression) Func)
        {
            bool changes = false;
            var newCaptures = new IExpression[CaptureList.Count];
            foreach (var from in CaptureList, var to in newCaptures)
            {
                to = Func(from);
                if (to != from)
                    changes = true;
            }

            if (changes)
                return new LambdaHeader(Signature, (IReadOnlyList<IExpression>)newCaptures);
            else
                return this;
        }

        private IExpression OptimizeExpr(IExpression Value)
        {
            return Value.Optimize();
        }

        public LambdaHeader Optimize()
        {
            return Apply(OptimizeExpr);
        }

        public LambdaHeader Accept(INodeVisitor Visitor)
        {
            return Apply(Visitor.Visit);
        }

        public LambdaHeader ConvertMembers(MemberConverter Converter)
        {
            var newMethod = Converter.Convert(Signature);
            if (Signature == newMethod)
                return this;
            else
                return new LambdaHeader(newMethod, CaptureList);
        }

        public ILambdaHeaderBlock Emit(ILambdaCodeGenerator Generator)
        {
            return Generator.EmitLambdaHeader(Signature, CaptureList.EmitAll(Generator));
        }
    }

    /// <summary>
    /// A type that contains a bound emit lambda header block.
    /// </summary>
    public class LambdaBoundHeaderBlock
    {
        /// <summary>
        /// Creates a bound header block that has not been bound to any block.
        /// </summary>
        public const this();

        /// <summary>
        /// Creates a bound header block that is already bound to the given block.
        /// </summary>
        public const this(set ILambdaHeaderBlock BoundBlock);

        /// <summary>
        /// Gets this lambda expression's bound header block, which is non-null
        /// only during a call to `Emit`.
        /// </summary>
        public ILambdaHeaderBlock BoundBlock { const get; set; }

        /// <summary>
        /// Tests if an emit lambda header block has been bound to this instance.
        /// </summary>
        public bool IsBound { const get return BoundBlock != null; }

        /// <summary>
        /// Binds the given emit lambda header block to this instance.
        /// </summary>
        public ILambdaHeaderBlock Bind(ILambdaHeaderBlock Block)
        {
            this.BoundBlock = Block;
            return Block;
        }

        /// <summary>
        /// Releases the bound emit lambda header block.
        /// </summary>
        public void Release()
        {
            this.BoundBlock = null;
        }
    }

    /// <summary>
    /// A type of expression that describes an anonymous function with explicit,
    /// by-value capture: variables outside the lambda are not permitted within.
    /// </summary>
    public class LambdaExpression : IExpression, ICopyableNode<IExpression>,
                                    IMemberNode, IFlowExpression,
                                    ILambdaNode<IExpression>
    {
        public const this(set LambdaHeader Header, set IStatement Body)
        {
            this.BoundHeaderBlock = new LambdaBoundHeaderBlock();
        }
        public const this(set LambdaHeader Header, set IStatement Body, set LambdaBoundHeaderBlock BoundHeaderBlock);

        /// <summary>
        /// Gets the lambda expression's header.
        /// </summary>
        public LambdaHeader Header { const get; private set; }

        /// <summary>
        /// Gets the lambda expression's body.
        /// </summary>
        public IStatement Body { const get; private set; }

        /// <summary>
        /// Gets this lambda expression's bound header block, which is non-null
        /// only during a call to `Emit`.
        /// </summary>
        public LambdaBoundHeaderBlock BoundHeaderBlock { const get; private set; }

        public IMethod Signature { const get return Header.Signature; }

        public bool IsConstant
        {
            const get return Header.CaptureList.AreConstant;
        }

        public IType Type
        {
            const get return MethodType.Create(Header.Signature);
        }

        public const IBoundObject Evaluate()
        {
            return null;
        }

        private const LambdaExpression CreateLambda(LambdaHeader NewHeader,
            IStatement NewBody, LambdaBoundHeaderBlock NewBoundHeader)
        {
            if (Header == NewHeader && Body == NewBody && BoundHeaderBlock == NewBoundHeader)
            {
                return this;
            }
            else
            {
                return new LambdaExpression(NewHeader, NewBody, NewBoundHeader);
            }
        }

        public IExpression Optimize()
        {
            return CreateLambda(Header.Optimize(), Body.Optimize(), BoundHeaderBlock);
        }

        private IStatement VisitBody(INodeVisitor Visitor)
        {
            if (Visitor is ILambdaVisitor)
            {
                return ((ILambdaVisitor)Visitor).VisitBody(Body, Header.Signature);
            }
            else
            {
                return Body;
            }
        }

        public IExpression Accept(INodeVisitor Visitor)
        {
            return CreateLambda(Header.Accept(Visitor), VisitBody(Visitor), BoundHeaderBlock);
        }

        /// <summary>
        /// Accepts and interacts with a flow visitor.
        /// </summary>
        public IExpression AcceptFlow<TState, TFlow>(IFlowVisitor<TState, TFlow> Visitor)
            : IFlowExpression.AcceptFlow<TState, TFlow>
        {
            return CreateLambda(Header.Accept(Visitor), VisitBody(Visitor), BoundHeaderBlock);
        }

        /// <summary>
        /// Tests if the given argument is a captured value expression
        /// that gets one of this lambda expression's captured values.
        /// </summary>
        public const bool IsCapturedValueExpression(IExpression Value)
        {
            if (Value is LambdaCapturedValueExpression)
            {
                var captValExpr = (LambdaCapturedValueExpression)Value;
                return captValExpr.BoundHeaderBlock == BoundHeaderBlock;
            }
            else
            {
                return false;
            }
        }

        private const IExpression TransformGetValueExpr(IExpression Value)
        {
            var captValExpr = (LambdaCapturedValueExpression)Value;
            return new LambdaCapturedValueExpression(captValExpr.Header, BoundHeaderBlock, captValExpr.Index);
        }

        /// <summary>
        /// Creates a copy of this lambda expression that is not dependent on
        /// any of this expression instance's data.
        /// </summary>
        public IExpression Copy()
        {
            var newLambda = new LambdaExpression(Header, Body);

            if (Header.CaptureList.Count == 0)
                return newLambda; // No dependencies to get rid of in the body.

            var rewriter = new ExpressionRewriter(this.IsCapturedValueExpression, newLambda.TransformGetValueExpr);
            newLambda.Body = rewriter.Visit(Body);
            return newLambda;
        }

        /// <summary>
        /// Converts the node's members with the given member converter.
        /// </summary>
        public IMemberNode ConvertMembers(MemberConverter Converter)
        {
            var newLambda = CreateLambda(Header.ConvertMembers(Converter), Body, BoundHeaderBlock);
            if (newLambda == this)
                return newLambda;
            else
                return (IMemberNode)newLambda.Copy(); // Copy the lambda to remove dependencies on
                                                      // the previous lambda header.
        }

        public ICodeBlock Emit(ICodeGenerator Generator)
        {
            var lambdaGen   = (ILambdaCodeGenerator)Generator;

            var headerBlock = BoundHeaderBlock.Bind(Header.Emit(lambdaGen));
            var bodyBlock   = Body.Emit(headerBlock.LambdaCodeGenerator);

            var result = lambdaGen.EmitLambda(headerBlock, bodyBlock);

            BoundHeaderBlock.Release();

            return result;
        }
    }

    public class LambdaCapturedValueExpression : IExpression
    {
        public const this(set LambdaHeader Header,
                          set LambdaBoundHeaderBlock BoundHeaderBlock,
                          set int Index);

        public LambdaHeader Header { const get; private set; }
        public LambdaBoundHeaderBlock BoundHeaderBlock { const get; private set; }
        public int Index { const get; private set; }

        public IExpression CapturedValue { const get return Header.CaptureList[Index]; }

        public bool IsConstant { const get return CapturedValue.IsConstant; }
        public IType Type { const get return CapturedValue.Type; }
        public IBoundObject Evaluate()
        {
            return CapturedValue.Evaluate();
        }

        public IExpression Optimize()
        {
            if (CapturedValue.IsConstant &&
                CapturedValue.Type.IsPrimitiveExpressionType())
            {
                var eval = CapturedValue.Evaluate();
                if (eval != null)
                {
                    return eval.ToExpression();
                }
            }

            return this;
        }

        public IExpression Accept(INodeVisitor Visitor)
        {
            return this;
        }

        public ICodeBlock Emit(ICodeGenerator CodeGenerator)
        {
            return BoundHeaderBlock.BoundBlock.GetCapturedValue(Index);
        }
    }
}
