using System;
using System.Numerics;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// An expression that represents a static cast.
    /// </summary>
    public class StaticCastExpression : ConversionExpressionBase
    {
        /// <summary>
        /// Creates a static cast from the given value and type.
        /// </summary>
        public const this(IExpression Value, IType TargetType)
            : base(Value, TargetType);

        /// <summary>
        /// Creates a new conversion expression that converts the given
        /// value to the given type.
        /// </summary>
        protected override ConversionExpressionBase Create(IExpression NewValue, IType NewType)
        {
            return new StaticCastExpression(NewValue, NewType);
        }

        public override bool IsConstantNode
        {
            get
            {
            	return true;
           	}
        }

        /// <summary>
        /// Tries to simplify this static_cast expression.
        /// </summary>
        public IExpression Simplify()
        {
            var valTy = Value.Type;
            if (valTy.IsEquivalent(TargetType))
                return Value;

            if (valTy.IsPrimitiveExpressionType() && TargetType.IsPrimitiveExpressionType())
            {
                var evalExpr = Evaluate();
                if (evalExpr != null)
                    return evalExpr.ToExpression();
            }

            return this;
        }

        /// <summary>
        /// Evaluates this conversion expression at compile-time.
        /// </summary>
        public override IBoundObject Evaluate()
        {
            var normalVal = Value.Evaluate();
            if (normalVal == null)
                return null;

            object objVal = normalVal.GetObjectValue();
            if (objVal == null)
                return null;

            if (TargetType.IsInteger)
            {
                var spec = PrimitiveTypes.GetIntegerSpec(TargetType);
                // Don't do this, because it's dependent on the machine's
                // endianness.
                //     if (objVal is BitValue)
                //         return ((BitValue)objVal).ToInteger().Cast(spec);
                if (objVal is IntegerValue)
                    return new IntegerExpression(
                        ((IntegerValue)objVal).Cast(spec));
                else if (objVal is bool)
                    return new IntegerExpression(
                        new IntegerValue((bool)objVal).Cast(spec));
                else if (objVal is char)
                    return new IntegerExpression(
                        new IntegerValue((char)objVal).Cast(spec));
                else
                    // TODO: maybe convert float/double constants to integers
                    // here.
                    return null;
            }
            else if (TargetType.IsBit)
            {
                // Don't do bit-to-bit casts, because they are sort of undefined.
                //     if (objVal is BitValue)
                //         return new BitExpression(((BitValue)objVal).ToInteger().Cast(spec));
                // Don't do integer-to-bit casts, because they are dependent on
                // the machine's endianness.
                //     else if (objVal is IntegerValue)
                //         return new BitExpression(((IntegerValue)objVal).Cast(spec));
                //     else
                // TODO: maybe convert float/double constants to bit values
                // here. This is only safe if we can do so in a
                // platform-independent manner, though.
                return null;
            }
            // TODO: re-implement this for IntegerValue.
            // else if (TargetType.Equals(PrimitiveTypes.Float32))
            // {
            //     return new Float32Expression(Convert.ToSingle(objVal));
            // }
            // else if (TargetType.Equals(PrimitiveTypes.Float64))
            // {
            //     return new Float64Expression(Convert.ToDouble(objVal));
            // }
            else if (TargetType.Equals(PrimitiveTypes.Boolean))
            {
                if (objVal is bool)
                    return new BooleanExpression((bool)objVal);
                else if (objVal is char)
                    return new BooleanExpression((char)objVal != (char)0);
                else if (objVal is IntegerValue)
                    return new BooleanExpression(
                        !((IntegerValue)objVal).Value.Equals(BigInteger.Zero));
                else
                    return null;
            }
            else if (TargetType.Equals(PrimitiveTypes.Char))
            {
                if (objVal is bool)
                {
                    if ((bool)objVal)
                        return new CharExpression((char)0);
                    else
                        return new CharExpression((char)1);
                }
                else if (objVal is char)
                    return new CharExpression((char)objVal);
                else if (objVal is IntegerValue)
                    return new CharExpression((char)((IntegerValue)objVal).ToInt16());
                else
                    return null;
            }
            else if (TargetType.Equals(PrimitiveTypes.String))
            {
                return new StringExpression(objVal.ToString());
            }
            else
            {
                return null;
            }
        }

        public override ICodeBlock Emit(ICodeGenerator Generator)
        {
            return Generator.EmitTypeBinary(Value.Emit(Generator), TargetType, Operator.StaticCast);
        }

        public override string ToString()
        {
            return "static_cast(" + Value + ", " + TargetType.ToString() + ")";
        }
    }
}
