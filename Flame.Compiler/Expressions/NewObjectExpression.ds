using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// A type of expression that creates new object instances,
    /// based on a type and a sequence of arguments.
    /// </summary>
    public class NewObjectExpression : IExpression
    {
        /// <summary>
        /// Creates an expression that produces an instance of the given
        /// type, by invoking its parameterless constructor (or by taking its
        /// default value, if the type is a value type).
        /// </summary>
        public const this(IType ConstructedType)
        {
            this.Type = ConstructedType;
            this.Arguments = Enumerable.Empty<IExpression>();
        }

        /// <summary>
        /// Creates an expression that produces an instance of the given
        /// type, by invoking one of its constructors with the given arguments
        /// (or by taking its default value, if the type is a value type,
        /// and the sequence of arguments is empty).
        /// </summary>
        public const this(IType ConstructedType, set [IExpression] Arguments)
        {
            this.Type = ConstructedType;
        }

        public [IExpression] Arguments { const get; private set; }
        public IType Type { const get; private set; }

        public IExpression Accept(INodeVisitor Visitor)
        {
            return Visitor.Visit(Lower());
        }

        public bool IsConstant
        {
            const get
            {
                if (!Arguments.AreConstant)
                {
                	return false;
                }
                return Constructor == null || Constructor.IsConstant;
            }
        }

        public const IBoundObject Evaluate()
        {
            return Lower().Evaluate();
        }

        private IMethod Constructor
        {
            const get
            {
                return Type.GetConstructors().GetBestMethod(Type, Arguments.Types);
            }
        }

        /// <summary>
        /// Attempts to lower this new-object expression.
        /// If that cannot be done, then this instance
        /// is simply returned.
        /// </summary>
        public IExpression LowerSoft()
        {
            var ctor = Constructor;
            if (ctor != null)
            {
                return new InvocationExpression(ctor, null, Arguments);
            }
            else
            {
                if (Type.IsValueType && Enumerable.Count<IExpression>(Arguments) == 0)
                {
                    return new DefaultValueExpression(Type);
                }
                else
                {
                    return this;
                }
            }
        }

        /// <summary>
        /// Lowers this new-object expression.
        /// If that cannot be done, then an exception is thrown.
        /// </summary>
        public IExpression Lower()
        {
             var result = LowerSoft();
             if (result is NewObjectExpression)
                throw new InvalidOperationException(
                "Could not lower new-object expression '" +
                ToString() + "': no appropriate constructor could be found");

            return result;
        }

        public const IExpression Optimize()
        {
            return Lower().Optimize();
        }

        public const ICodeBlock Emit(ICodeGenerator Generator)
        {
            return Lower().Emit(Generator);
        }

        public override string ToString()
        {
            var result = new StringBuilder();
            result.Append("new(");
            result.Append(Type.ToString());
            foreach (var item in Arguments)
            {
                result.Append(", ");
                result.Append(item.ToString());
            }
            result.Append(")");
            return (string)result;
        }
    }
}
