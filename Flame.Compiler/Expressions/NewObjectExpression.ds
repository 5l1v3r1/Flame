using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Compiler.Expressions
{
    /// <summary>
    /// A type of expression that creates new object instances,
    /// based on a type and a sequence of arguments.
    /// </summary>
    public class NewObjectExpression : IExpression
    {
        /// <summary>
        /// Creates an expression that produces an instance of the given
        /// type, by invoking its parameterless constructor (or by taking its
        /// default value, if the type is a value type).
        /// </summary>
        public const this(IType ConstructedType)
        {
            this.Type = ConstructedType;
            this.Arguments = Enumerable.Empty<IExpression>();
            this.lazyCtor = new Lazy<IMethod>(getCtor);
        }

        /// <summary>
        /// Creates an expression that produces an instance of the given
        /// type, by invoking one of its constructors with the given arguments
        /// (or by taking its default value, if the type is a value type,
        /// and the sequence of arguments is empty).
        /// </summary>
        public const this(IType ConstructedType, set [IExpression] Arguments)
        {
            this.Type = ConstructedType;
            this.lazyCtor = new Lazy<IMethod>(getCtor);
        }

        /// <summary>
        /// Gets this new-object expression's argument list.
        /// </summary>
        public [IExpression] Arguments { const get; private set; }

        /// <summary>
        /// Gets the type this new-object expression will create an instance
        /// of.
        /// </summary>
        public IType Type { const get; private set; }

        public IExpression Accept(INodeVisitor Visitor)
        {
            return Visitor.Visit(Lower());
        }

        public bool IsConstant
        {
            const get
            {
                if (!Arguments.AreConstant)
                {
                	return false;
                }
                var ctor = Constructor;
                return ctor == null || ctor.IsConstant;
            }
        }

        public const IBoundObject Evaluate()
        {
            return Lower().Evaluate();
        }

        // Memoizes the constructor's value.
        private Lazy<IMethod> lazyCtor;

        /// <summary>
        /// Gets the constructor this new-object expression will use when
        /// lowering itself. If no such constructor can be found, then null
        /// is returned.
        /// </summary>
        /// <remarks>
        /// This expression can still be semantically valid, even if the
        /// constructor is null, provided the instance type is a value type,
        /// and the argument list is empty.
        /// </remarks>
        public IMethod Constructor
        {
            get { return lazyCtor.Value; }
        }

        private IMethod getCtor()
        {
            return Type.GetConstructors().GetBestMethod(Type, Arguments.Types);
        }

        /// <summary>
        /// Tests if this new-object expression will be lowered to a constructor
        /// call expression.
        /// </summary>
        public bool IsConstructorCall
        {
            get { return Constructor != null; }
        }

        /// <summary>
        /// Tests if this new-object expression will be lowered to a default
        /// value expression.
        /// </summary>
        public bool IsDefaultValue
        {
            get
            {
                return !IsConstructorCall && Type.IsValueType &&
                       !Enumerable.Any<IExpression>(Arguments);
           }
        }

        /// <summary>
        /// Tests if this new-object expression is erroneous: it cannot be
        /// lowered to another expression.
        /// </summary>
        public bool IsError
        {
            get { return !IsConstructorCall && !IsDefaultValue; }
        }

        /// <summary>
        /// Attempts to lower this new-object expression.
        /// If that cannot be done, then this instance
        /// is simply returned.
        /// </summary>
        public IExpression LowerSoft()
        {
            if (IsConstructorCall)
                return new InvocationExpression(Constructor, null, Arguments);
            else if (IsDefaultValue)
                return new DefaultValueExpression(Type);
            else
                return this;
        }

        /// <summary>
        /// Lowers this new-object expression.
        /// If that cannot be done, then an exception is thrown.
        /// </summary>
        public IExpression Lower()
        {
             var result = LowerSoft();
             if (result is NewObjectExpression)
                throw new InvalidOperationException(
                "Could not lower new-object expression '" +
                ToString() + "': no appropriate constructor was found.");

            return result;
        }

        public const IExpression Optimize()
        {
            return Lower().Optimize();
        }

        public const ICodeBlock Emit(ICodeGenerator Generator)
        {
            return Lower().Emit(Generator);
        }

        public override string ToString()
        {
            var result = new StringBuilder();
            result.Append("new(");
            result.Append(Type.ToString());
            foreach (var item in Arguments)
            {
                result.Append(", ");
                result.Append(item.ToString());
            }
            result.Append(")");
            return (string)result;
        }
    }
}
