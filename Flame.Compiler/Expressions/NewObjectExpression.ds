using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Compiler.Expressions
{
    public class NewObjectExpression : IExpression, IMemberNode
    {
        public const this(IType ConstructedType)
        {
            this.Type = ConstructedType;
            this.Arguments = Enumerable.Empty<IExpression>();
        }
        public const this(IType ConstructedType, set [IExpression] Arguments)
        {
            this.Type = ConstructedType;
        }

        public [IExpression] Arguments { const get; private set; }
        public IType Type { const get; private set; }

        public IMemberNode ConvertMembers(MemberConverter Converter)
        {
            var elemType = Converter.Convert(Type);
            if (object.ReferenceEquals(elemType, Type))
            {
                return this;
            }
            else return new NewObjectExpression(elemType, Arguments);
        }

        public IExpression Accept(INodeVisitor Visitor)
        {
            var transArgs = Visitor.VisitAll(Arguments);

            return new NewObjectExpression(Type, transArgs);
        }

        public bool IsConstant
        {
            const get
            {
                if (!Arguments.AreConstant)
                {
                	return false;
                }
                var clrCtor = Constructor;
                return clrCtor == null || clrCtor.IsConstant;
            }
        }

        public const IBoundObject Evaluate()
        {
            var clrCtor = Constructor;
            if (clrCtor != null)
            {
                var args = Arguments.EvaluateAll();
                return clrCtor.Invoke(null, args);
            }
            else
            {
                return null;
            }
        }

        private IMethod Constructor
        {
            const get
            {
                return Type.GetConstructors().GetBestMethod(Type, Arguments.Types);
            }
        }

        public const IExpression Optimize()
        {
            var clrCtor = Constructor;
            if (clrCtor != null)
            {
                //return new ConstructorCallExpression(clrCtor, Arguments).Optimize();
                return new InvocationExpression(clrCtor, null, Arguments).Optimize();
            }
            else
            {
                var optArgs = Arguments.OptimizeAll();
                var newFunc = new NewObjectExpression(Type, optArgs);
                /*if (newFunc.IsConstant && newFunc.Type.IsCompileableType)
                {
                    return NodeExtensions.ToExpression(newFunc.Evaluate());
                }
                else */
                if (newFunc.Type.IsValueType && Enumerable.Count<IExpression>(newFunc.Arguments) == 0 && newFunc.Constructor == null)
                {
                    return new DefaultValueExpression(newFunc.Type);
                }
                else
                {
                    return new NewObjectExpression(Type, optArgs);
                }
            }
        }

        public const ICodeBlock Emit(ICodeGenerator Generator)
        {
            var ctor = Constructor;
            if (ctor == null && Type.IsValueType && Enumerable.Count<IExpression>(Arguments) == 0)
            {
                return Generator.EmitDefaultValue(Type);
            }
            else
            {
                return Generator.EmitInvocation(ctor, null, Arguments.EmitAll(Generator));
            }
        }
    }
}
