using System;

namespace Flame.Compiler.Visitors
{
    /// <summary>
    /// Describes an environment for body passes.
    /// </summary>
    public interface IBodyPassEnvironment
    {
        /// <summary>
        /// Gets the target environment.
        /// </summary>
        IEnvironment Environment { const get; }

        /// <summary>
        /// Gets the body pass environment's log.
        /// </summary>
        ICompilerLog Log { const get; }

        /// <summary>
        /// Tries to retrieve the method body of the given method.
        /// If this cannot be done, null is returned.
        /// </summary>
        IStatement GetMethodBody(IMethod Method);
    }

    /// <summary>
    /// Contains a body pass' arguments.
    /// </summary>
    public class BodyPassArgument
    {
        /// <summary>
        /// Creates a new body pass argument from the given values.
        /// </summary>
        public const this(set IBodyPassEnvironment PassEnvironment, set ITypeBuilder Type,
                          set IMethodBuilder Method, set IStatement Body);

        /// <summary>
        /// Creates a new body pass argument from the given previous body
        /// pass argument and new method body.
        /// </summary>
        public const this(BodyPassArgument Previous, set IStatement Body)
        {
            this.PassEnvironment = Previous.PassEnvironment;
            this.Type = Previous.Type;
            this.Method = Previous.Method;
        }

        /// <summary>
        /// Gets the body pass' environment.
        /// </summary>
        public IBodyPassEnvironment PassEnvironment { const get; private set; }
        /// <summary>
        /// Gets the target method's environment.
        /// </summary>
        public IEnvironment Environment { const get return PassEnvironment.Environment; }
        /// <summary>
        /// Gets the target method's declaring type.
        /// </summary>
        public ITypeBuilder Type { const get; private set; }
        /// <summary>
        /// Gets the target method.
        /// </summary>
        public IMethodBuilder Method { const get; private set; }
        /// <summary>
        /// Gets the target method's body statement.
        /// </summary>
        public IStatement Body { const get; private set; }
    }

    /// <summary>
    /// Defines a base class for method body passes.
    /// A method body pass is allowed to create new members within the
    /// method's declaring type, but cannot remove, rename or otherwise
    /// modify members.
    /// </summary>
    public abstract class BodyPassBase : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// Creates a new body pass.
        /// </summary>
        public const this();

        /// <summary>
        /// Applies this pass to the given method, method body, type builder and environment.
        /// </summary>
        public abstract IStatement Apply(IEnvironment Environment, ITypeBuilder Type, IMethodBuilder Method, IStatement Body);

        /// <summary>
        /// Applies this pass to the given method, method body, type builder and environment.
        /// </summary>
        public IStatement Apply(BodyPassArgument Value)
        {
            return Apply(Value.Environment, Value.Type, Value.Method, Value.Body);
        }
    }

    /// <summary>
    /// Defines a "fat" body pass: a pass that executes a body pass, and subsequently
    /// combines the pass' output statement with the pass' other arguments.
    /// </summary>
    public class FatBodyPass : IPass<BodyPassArgument, BodyPassArgument>
    {
        /// <summary>
        /// Creates a new fat bpdy pass based on the given body pass.
        /// </summary>
        public const this(set IPass<BodyPassArgument, IStatement> Pass);

        /// <summary>
        /// Gets the fat body pass' inner body pass.
        /// </summary>
        public IPass<BodyPassArgument, IStatement> Pass { const get; private set; }

        public BodyPassArgument Apply(BodyPassArgument Value)
        {
            return new BodyPassArgument(Value, Pass.Apply(Value));
        }
    }

    /// <summary>
    /// Defines a "slim" body pass: a body pass that uses a "fat" body
    /// pass under the hood.
    /// </summary>
    public class SlimBodyPass : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// Creates a new slim body pass based on the given fat body pass.
        /// </summary>
        public const this(set IPass<BodyPassArgument, BodyPassArgument> Pass);

        /// <summary>
        /// Gets the slim body pass' inner fat body pass.
        /// </summary>
        public IPass<BodyPassArgument, BodyPassArgument> Pass { const get; private set; }

        public IStatement Apply(BodyPassArgument Value)
        {
            return Pass.Apply(Value).Body;
        }
    }

    /// <summary>
    /// Defines an aggregate body pass.
    /// </summary>
    public class AggregateBodyPass : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// Creates a new aggregate pass from the given passes.
        /// </summary>
        public const this(set IPass<BodyPassArgument, IStatement> First,
                          set IPass<BodyPassArgument, IStatement> Second);

        /// <summary>
        /// Gets the first body pass to apply to the input.
        /// </summary>
        public IPass<BodyPassArgument, IStatement> First { const get; private set; }
        /// <summary>
        /// Gets the second body pass to apply to the input.
        /// </summary>
        public IPass<BodyPassArgument, IStatement> Second { const get; private set; }

        /// <summary>
        /// Applies this pass to the given value.
        /// </summary>
        public const IStatement Apply(BodyPassArgument Value)
        {
            return Second.Apply(new BodyPassArgument(Value, First.Apply(Value)));
        }
    }
}
