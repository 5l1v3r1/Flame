using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;

namespace Flame.Compiler.Visitors
{
    /// <summary>
    /// Lowers `LambdaExpression`s to closure classes.
    /// </summary>
    public static class LowerLambdaPass : IPass<BodyPassArgument, IStatement>
    {
        // Lower `[cap_type0 cap_var0, ...] ret_type(args) => stmt` to:
        //
        //       private class __lambda_closure$xxx
        //       {
        //            public const this(capture_list);
        //            private cap_type0 cap_var0;
        //            ...
        //            public lambda_invoke(args) stmt;
        //       }
        //
        // and lower the special case of `[] ret_type(args) => stmt` to
        //
        //       private __lambda_invoke$xxx(args) stmt;

        public override IStatement Apply(BodyPassArgument Args)
        {
            var visitor = new LowerLambdaVisitor(Args);
            return visitor.Visit(Args.Body);
        }
    }

    public class LowerLambdaVisitor : NodeVisitorBase
    {
        public const this(set BodyPassArgument Args);

        public BodyPassArgument Args { const get; private set; }
        public IEnvironment Environment { const get return Args.Environment; }
        public ITypeBuilder DeclaringType { const get return Args.Type; }
        public IMethodBuilder DeclaringMethod { const get return Args.Method; }
        public IRandomAccessOptions TypeMetadata { const get return Args.Metadata.TypeMetadata; }

        private int nameCounter
        {
            const get return TypeMetadata.GetOption<int>("lambda-counter", 0);
            set TypeMetadata.SetOption<int>("lambda-counter", value);
        }

        public override const bool Matches(IExpression Value)
        {
            return Value is LambdaExpression;
        }
        public override const bool Matches(IStatement Value)
        {
            return false;
        }

        private string GenerateName(string Prefix)
        {
            int count = nameCounter;
            string result = Prefix + "$" + count;
            nameCounter = count + 1;
            return result;
        }

        private DescribedMethod CopySignature(IMethod Signature, string Name, IType DeclType, bool IsStatic, bool IsPrivate, MemberConverter Converter)
        {
            var descMethod = new DescribedMethod(Name, DeclType, Converter.Convert(Signature.ReturnType), IsStatic);
            foreach (var item in Signature.GetParameters())
            {
                var convParam = new DescribedParameter(item.Name, Converter.Convert(item.ParameterType));
                foreach (var attr in item.Attributes)
                {
                    convParam.AddAttribute(attr);
                }
                descMethod.AddParameter(convParam);
            }

            foreach (var item in Signature.Attributes)
                descMethod.AddAttribute(item);

            if (IsPrivate)
                descMethod.AddAttribute(new AccessAttribute(AccessModifier.Private));
            else
                descMethod.AddAttribute(new AccessAttribute(AccessModifier.Public));

            return descMethod;
        }

        private DescribedMethod CopySignature(IMethod Signature, string Name, IType DeclType, bool IsStatic)
        {
            var typeConv = new MemberConverter(new EmptyConverter<IType>(),
                                               new EmptyConverter<IMethod>(),
                                               new EmptyConverter<IField>());
            return CopySignature(Signature, Name, DeclType, IsStatic, true, typeConv);
        }

        private Tuple<MemberConverter, IStatement> ConvertGenerics(IGenericMember Owner, IStatement Body)
        {
            if (!Owner.IsGeneric)
            {
                var typeConv = new MemberConverter(new EmptyConverter<IType>(),
                                                   new EmptyConverter<IMethod>(),
                                                   new EmptyConverter<IField>());
                return Tuple.Create<MemberConverter, IStatement>(typeConv, Body);
            }
            else
            {
                var typeConv = MemberNodeVisitor.CreateMemberConverter(new TypeParameterConverter(Owner));
                var newBody = MemberNodeVisitor.ConvertMembers(typeConv, Body);
                return Tuple.Create<MemberConverter, IStatement>(typeConv, newBody);
            }
        }

        private IExpression LowerCapturelessLambda(LambdaExpression Lambda, IStatement LambdaBody)
        {
            // Special case where capture list is empty.

            string name    = GenerateName("__lambda_invoke");
            var descMethod = CopySignature(Lambda.Signature, name, DeclaringType, true);
            foreach (var item in DeclaringMethod.GenericParameters)
            {
                descMethod.AddGenericParameter(item);
            }

            var lambdaMethod = DeclaringType.DeclareMethod(descMethod);
            var convGenerics = ConvertGenerics(lambdaMethod, LambdaBody);

            var lambdaHeader = new EmptyCaptureLambdaHeaderBlock(lambdaMethod.GetBodyGenerator());
            Lambda.BoundHeaderBlock.Bind(lambdaHeader);
            var lambdaBody   = convGenerics.Item2.Emit(lambdaHeader.LambdaCodeGenerator);
            Lambda.BoundHeaderBlock.Release();
            lambdaMethod.SetMethodBody(lambdaBody);
            lambdaMethod.Build();

            if (lambdaMethod.IsGeneric)
                return new GetMethodExpression(lambdaMethod.MakeGenericMethod(lambdaMethod.GenericParameters), null);
            else
                return new GetMethodExpression(lambdaMethod, null);
        }

        private IMethod GetGenericConstructor(IType Type, IMethod Ctor)
        {
            if (!Type.IsGeneric)
            {
                return Ctor;
            }
            else
            {
                var inst = Type.MakeGenericType(DeclaringMethod.GenericParameters);
                return Enumerable.Single<IMethod>(inst.GetConstructors());
            }
        }

        private IMethod GetGenericInvokeMethod(IType Type, IMethod InvokeMethod)
        {
            if (!Type.IsGeneric)
            {
                return InvokeMethod;
            }
            else
            {
                var inst = Type.MakeGenericType(DeclaringMethod.GenericParameters);
                return Enumerable.Single<IMethod>(inst.GetMethods());
            }
        }

        private IExpression LowerCapturingLambda(LambdaExpression Lambda, IStatement LambdaBody)
        {
            var nsBuilder = (INamespaceBuilder)DeclaringType;
            string name = GenerateName("__lambda_closure");
            var descType = new DescribedType(name, nsBuilder);
            descType.AddAttribute(new AccessAttribute(AccessModifier.Private));
            if (Environment.RootType != null)
            {
                descType.AddBaseType(Environment.RootType);
            }
            foreach (var item in DeclaringMethod.GenericParameters)
            {
                descType.AddGenericParameter(item);
            }

            var closureType  = nsBuilder.DeclareType(descType);
            var convGenerics  = ConvertGenerics(closureType, LambdaBody);
            var typeConverter = convGenerics.Item1;

            var descCtor = new DescribedMethod("this", closureType, PrimitiveTypes.Void, false);
            descCtor.IsConstructor = true;

            var closureThis = ThisReferenceVariable.Create(closureType).CreateGetExpression();

            var ctorBody = new List<IStatement>();
            if (Environment.RootType != null)
            {
                var rootCtor = Environment.RootType.GetConstructor(new IType[] { }, false);
                ctorBody.Add(new ExpressionStatement(
                    new InvocationExpression(rootCtor, closureThis, Enumerable.Empty<IExpression>())));
            }

            var capturedValues = new List<IExpression>();

            foreach (var item in Lambda.Header.CaptureList)
            {
                var descField = new DescribedField("captured_" + capturedValues.Count,
                                                   closureType,
                                                   typeConverter.Convert(item.Type),
                                                   false);
                descField.AddAttribute(new AccessAttribute(AccessModifier.Private));

                var captField = closureType.DeclareField(descField);
                captField.Build();
                var ctorParam = new DescribedParameter(descField.Name, descField.FieldType);
                var ctorArg   = new ArgumentVariable(ctorParam, capturedValues.Count);

                var genCaptField = ThisVariable.GetThisType(closureType).GetField(captField.Name, captField.IsStatic);
                var captVal = new FieldVariable(genCaptField, closureThis);

                descCtor.AddParameter(ctorParam);
                capturedValues.Add(captVal.CreateGetExpression());
                ctorBody.Add(captVal.CreateSetStatement(ctorArg.CreateGetExpression()));
            }

            ctorBody.Add(new ReturnStatement());

            var ctorBodyStatement = new BlockStatement(ctorBody);
            var closureCtor       = closureType.DeclareMethod(descCtor);
            closureCtor.SetMethodBody(ctorBodyStatement.Emit(closureCtor.GetBodyGenerator()));
            closureCtor.Build();

            var descInvoke   = CopySignature(Lambda.Signature, "lambda_invoke", closureType, false, false, typeConverter);
            var invokeMethod = closureType.DeclareMethod(descInvoke);

            var lambdaHeader = new ExpressionCaptureLambdaHeaderBlock(invokeMethod.GetBodyGenerator(), capturedValues);
            Lambda.BoundHeaderBlock.Bind(lambdaHeader);
            var lambdaBody   = convGenerics.Item2.Emit(lambdaHeader.LambdaCodeGenerator);
            Lambda.BoundHeaderBlock.Release();
            invokeMethod.SetMethodBody(lambdaBody);
            invokeMethod.Build();
            closureType.Build();

            var genericCtor = GetGenericConstructor(closureType, closureCtor);
            var genericInv  = GetGenericInvokeMethod(closureType, invokeMethod);

            return new GetMethodExpression(genericInv, new InvocationExpression(genericCtor, null, Lambda.Header.CaptureList));
        }

        private IExpression LowerLambda(LambdaExpression Lambda)
        {
            // Lower nested lambdas first
            var newBody = Visit(Lambda.Body);
            if (Lambda.Header.CaptureList.Count == 0)
                return LowerCapturelessLambda(Lambda, newBody);
            else
                return LowerCapturingLambda(Lambda, newBody);
        }

        protected override IExpression Transform(IExpression Value)
        {
            return LowerLambda((LambdaExpression)Value);
        }

        protected override IStatement Transform(IStatement Value)
        {
            return Value.Accept(this);
        }
    }

    public class EmptyCaptureLambdaHeaderBlock : ILambdaHeaderBlock
    {
        public const this(set ICodeGenerator LambdaCodeGenerator);

        public ICodeGenerator LambdaCodeGenerator { const get; private set; }

        public ICodeBlock GetCapturedValue(int Index)
        {
            throw new InvalidOperationException("Cannot get a captured value belonging to a lambda header with an empty capture list.");
        }
    }

    public class ExpressionCaptureLambdaHeaderBlock : ILambdaHeaderBlock
    {
        public const this(set ICodeGenerator LambdaCodeGenerator, set IReadOnlyList<IExpression> CapturedValues);

        public ICodeGenerator LambdaCodeGenerator { const get; private set; }
        public IReadOnlyList<IExpression> CapturedValues { const get; private set; }

        public ICodeBlock GetCapturedValue(int Index)
        {
            return CapturedValues[Index].Emit(LambdaCodeGenerator);
        }
    }
}
