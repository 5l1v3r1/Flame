using System;
using System.Collections.Generic;

namespace Flame.Compiler
{
	public static class NodeExtensions
	{
		private static T GetEssentialNode<T>(this T Node)
		{
			if (Node is IMetadataNode<T>)
				return GetEssentialNode<T>(((IMetadataNode<T>)Node).Value);
			else
				return Node;
		}

		/// <summary>
		/// Gets this expression's "essential" inner expression, i.e. its inner
		/// non-metadata expression.
		/// </summary>
		public static IExpression GetEssentialExpression(this IExpression Expression)
		{
			return GetEssentialNode<IExpression>(Expression);
		}

		/// <summary>
		/// Gets this statement's "essential" inner statement, i.e. its inner
		/// non-metadata statement.
		/// </summary>
		public static IStatement GetEssentialStatement(this IStatement Statement)
		{
			return GetEssentialNode<IStatement>(Statement);
		}

		#region IsConstant

		public static bool AreConstant[this IEnumerable<IExpression> Expressions]
		{
			const get
			{
				foreach (var expr in Expressions)
				{
					if (!expr.IsConstant)
					{
						return false;
					}
				}
				return true;
			}
		}

		public static bool IsConstantOrNull[this IExpression Expression]
		{
			const get
			{
				if (Expression == null)
				{
					return true;
				}
				else
				{
					return Expression.IsConstant;
				}
			}
		}

		#endregion

		#region Optimize

		public static [IExpression] OptimizeAll(this [IExpression] Expressions)
		{
			var exprs = new List<IExpression>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Optimize());
			}
			return exprs;
		}

		public static IExpression OptimizeOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Optimize();
			}
		}
		public static IStatement OptimizeOrNull(this IStatement Statement)
		{
			if (Statement == null)
			{
				return null;
			}
			else
			{
				return Statement.Optimize();
			}
		}

		#endregion

		#region Evaluate

		public static IBoundObject EvaluateOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Evaluate();
			}
		}

		public static [IBoundObject] EvaluateAll(this [IExpression] Expressions)
		{
			var exprs = new List<IBoundObject>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Evaluate());
			}
			return exprs;
		}

		#endregion

		#region Emit

		public static ICodeBlock EmitOrNull(this IExpression Expression, ICodeGenerator Generator)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Emit(Generator);
			}
		}

		public static [ICodeBlock] EmitAll(this [IExpression] Expressions, ICodeGenerator Generator)
		{
			var exprs = new List<ICodeBlock>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Emit(Generator));
			}
			return exprs;
		}

		#endregion

		#region Types

		public static IType[] Types[this [IExpression] Expressions]
		{
			const get
			{
				var types = new List<IType>();
				foreach (var item in Expressions)
				{
					types.Add(item.Type);
				}
				return types.ToArray();
			}
		}

		#endregion

		#region EvaluateConstant

		public static const IBoundObject EvaluateConstant(this IExpression Expression)
		{
			if (Expression.IsConstant)
			{
				return Expression.Evaluate();
			}
			return null;
		}

		#endregion

		#region EvaluatesTo

		public static const bool EvaluatesTo<T>(this IExpression Expression, T Value)
			where T : object
		{
			return Expression.EvaluateConstant().EvaluatesTo<T>(Value);
		}

		public static const bool EvaluatesTo<T>(this IBoundObject BoundObject, T Value)
			where T : object
		{
			if (BoundObject is IBoundPrimitive<T>) // This also performs an implicit null-check.
			{
				return BoundObject.GetValue<T>().Equals(Value);
			}
			return false;
		}

		#endregion

		#region TypeOrNull

		public static const IType TypeOrNull[this IExpression Expression]
		{
			const get
			{
				if (Expression == null)
					return null;
				else
					return Expression.Type;
			}
		}

		#endregion
	}
}
