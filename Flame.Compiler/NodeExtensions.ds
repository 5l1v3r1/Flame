using System;
using System.Collections.Generic;

namespace Flame.Compiler
{
	public static class NodeExtensions
	{
		#region IsConstant

		public static bool AreConstant[this IEnumerable<IExpression> Expressions]
		{
			const get
			{
				foreach (var expr in Expressions)
				{
					if (!expr.IsConstant)
					{
						return false;
					}
				}
				return true;
			}
		}

		public static bool IsConstantOrNull[this IExpression Expression]
		{
			const get
			{
				if (Expression == null)
				{
					return true;
				}
				else
				{
					return Expression.IsConstant;
				}
			}
		}

		#endregion

		#region Optimize

		public static IEnumerable<IExpression> OptimizeAll(this IEnumerable<IExpression> Expressions)
		{
			List<IExpression> exprs = new List<IExpression>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Optimize());
			}
			return exprs;
		}

		public static IExpression OptimizeOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Optimize();
			}
		}
		public static IStatement OptimizeOrNull(this IStatement Statement)
		{
			if (Statement == null)
			{
				return null;
			}
			else
			{
				return Statement.Optimize();
			}
		}

		#endregion

		#region Evaluate

		public static IBoundObject EvaluateOrNull(this IExpression Expression)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Evaluate();
			}
		}

		public static IEnumerable<IBoundObject> EvaluateAll(this IEnumerable<IExpression> Expressions)
		{
			List<IBoundObject> exprs = new List<IBoundObject>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Evaluate());
			}
			return exprs;
		}

		#endregion

		#region Emit

		public static ICodeBlock EmitOrNull(this IExpression Expression, ICodeGenerator Generator)
		{
			if (Expression == null)
			{
				return null;
			}
			else
			{
				return Expression.Emit(Generator);
			}
		}

		public static IEnumerable<ICodeBlock> EmitAll(this IEnumerable<IExpression> Expressions, ICodeGenerator Generator)
		{
			List<ICodeBlock> exprs = new List<ICodeBlock>();
			foreach (var item in Expressions)
			{
				exprs.Add(item.Emit(Generator));
			}
			return exprs;
		}

		#endregion

		#region Types

		public static IType[] Types[this IEnumerable<IExpression> Expressions]
		{
			const get
			{
				var types = new List<IType>();
				foreach (var item in Expressions)
				{
					types.Add(item.Type);
				}
				return types.ToArray();
			}
		}

		#endregion

		#region EvaluateConstant

		public static const IBoundObject EvaluateConstant(this IExpression Expression)
		{
			if (Expression.IsConstant)
			{
				return Expression.Evaluate();
			}
			return null;
		}

		#endregion

		#region EvaluatesTo

		public static const bool EvaluatesTo<T>(this IExpression Expression, T Value)
			where T : object
		{
			return Expression.EvaluateConstant().EvaluatesTo<T>(Value);
		}

		public static const bool EvaluatesTo<T>(this IBoundObject BoundObject, T Value)
			where T : object
		{
			if (BoundObject is IBoundPrimitive<T>) // This also performs an implicit null-check.
			{
				return BoundObject.GetValue<T>().Equals(Value);
			}
			return false;
		}

		#endregion
	}
}
