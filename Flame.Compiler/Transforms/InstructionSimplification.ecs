#importMacros(FlameMacros);

using System.Collections.Generic;
using Flame.Constants;
using Flame.Compiler.Analysis;
using Flame.Compiler.Instructions;
using Flame.TypeSystem;

namespace Flame.Compiler.Transforms
{
    /// <summary>
    /// Looks for transforms that simplify instructions.
    /// </summary>
    public #rewriteRuleAnalysis(InstructionSimplificationAnalysis, {
        // Nop casts can be replaced by copies.
        #rule({
            result = intrinsic("arith.convert", T, #(T))(value);
        }, {
            result = copy(T)(value);
        });

        // The 'unbox_any' intrinsic can be replaced with its implementation
        // if we know for sure that the target type is a value type.
        #rule({
            result = intrinsic("object.unbox_any", To, #(From))(value);
        }, {
            box_contents_ptr = unbox(To)(value);
            result = load(To)(box_contents_ptr);
        }, !(To is IGenericParameter) && !(To is PointerType));

        // A sign or zero extension followed by a truncation can be
        // simplified to either an extension or a truncation.
        #rule({
            temp_cast = intrinsic("arith.convert", Intermediate, #(From))(value);
            result = intrinsic("arith.convert", To, #(Intermediate))(temp_cast);
        }, {
            result = intrinsic("arith.convert", To, #(From))(value);
        }, From.IsIntegerType()
            && Intermediate.IsIntegerType()
            && To.IsIntegerType()
            && Intermediate.GetIntegerSpecOrNull().Size >= From.GetIntegerSpecOrNull().Size
            && From.GetIntegerSpecOrNull().Size >= To.GetIntegerSpecOrNull().Size);

        // Multiplication by two is equivalent to adding something
        // to itself.
        #rule({
            two = constant(c, TConst)();
            result = intrinsic("arith.mul", T, #(T, TConst))(a, two);
        }, {
            result = intrinsic("arith.add", T, #(T, T))(a, a);
        }, T.IsIntegerType() && c is IntegerConstant && c.Equals(new IntegerConstant(2).Cast(((IntegerConstant)c).Spec)));
    });

    /// <summary>
    /// An intraprocedural transform that greedily applies instruction
    /// simplifications.
    /// </summary>
    public sealed class InstructionSimplification : IntraproceduralOptimization
    {
        private InstructionSimplification()
        { }

        /// <summary>
        /// An instance of the instruction simplification transform.
        /// </summary>
        public static readonly InstructionSimplification Instance = new InstructionSimplification();

        /// <inheritdoc/>
        public override FlowGraph Apply(FlowGraph graph)
        {
            var builder = graph.ToBuilder();
            if (!builder.HasAnalysisFor<InstructionSimplificationAnalysis.Results>())
            {
                builder.AddAnalysis(new InstructionSimplificationAnalysis());
            }

            while (true)
            {
                var transforms = builder.GetAnalysisResult<InstructionSimplificationAnalysis.Results>();
                if (transforms.ApplicableRules.Count == 0)
                {
                    return builder.ToImmutable();
                }
                else
                {
                    transforms.ApplicableRules[0].Apply(builder);
                }
            }
        }
    }
}
