using System;
using System.Collections.Generic;
using Flame.Compiler.Expressions;

namespace Flame.Compiler.Statements
{
	public class WhileStatement : IStatement, IFlowStatement
	{
		public const this(set IExpression Condition, set IStatement Body)
		{
			this.Tag = new UniqueTag();
		}
		public const this(set UniqueTag Tag, set IExpression Condition, set IStatement Body);

		public UniqueTag Tag { const get; private set; }
		public IExpression Condition { const get; private set; }
		public IStatement Body { const get; private set; }

		public bool IsEmpty : IStatement.IsEmpty
		{
			const get
			{
				return Condition.EvaluatesTo<bool>(false);
			}
		}

		private const WhileStatement CreateWhile(IExpression NewCondition, IStatement NewBody)
		{
			if (NewCondition == Condition && NewBody == Body)
			{
				return this;
			}
			else
			{
				return new WhileStatement(Tag, NewCondition, NewBody);
			}
		}

		public IStatement AcceptFlow<TState, TFlow>(IFlowVisitor<TState, TFlow> Visitor)
			: IFlowStatement.AcceptFlow<TState, TFlow>
		{
			var startFlow = Visitor.CurrentFlow;

			var transCond = Visitor.Visit(Condition);

			var transBody = Visitor.Visit(Body);
			var bodyFlow = Visitor.CreateDeltaFlow(startFlow, Visitor.CurrentFlow);

			Visitor.CurrentFlow = Visitor.CreateCollapsedFlow(startFlow, Visitor.CreateLoopFlow(Tag, bodyFlow));

			return CreateWhile(transCond, transBody);
		}

		public IStatement Accept(INodeVisitor Visitor)
		{
			var transCond = Visitor.Visit(Condition);
			var transBody = Visitor.Visit(Body);

			return CreateWhile(transCond, transBody);
		}

		public IStatement Optimize() : IStatement.Optimize
		{
			var optCond = Condition.Optimize();
			if (optCond.EvaluatesTo<bool>(false))
			{
				return EmptyStatement;
			}

			var optBody = Body.Optimize();
			return CreateWhile(optCond, optBody);
		}

		/// <summary>
		/// Lowers this while block to an equivalent tagged block IR tree.
		/// </summary>
		public IStatement Lower()
		{
			// "Lower" a while block like this:
			//
			// while (cond) stmt;
			//
			// ==>
			//
			// block:
			// {
			//     if (!cond) break block;
			//     stmt;
			//     continue block;
			// }

			var ifBreak = new IfElseStatement(new NotExpression(Condition),
										      new BreakStatement(Tag));
			var loopBody = new BlockStatement(new IStatement[]
			{
				ifBreak.Simplify(),
				Body,
				new ContinueStatement(Tag)
			});
			return new TaggedStatement(Tag, loopBody);
		}

		public ICodeBlock Emit(ICodeGenerator Generator) : INode.Emit
		{
			if (Generator is IWhileCodeGenerator)
			{
				var whileCg = (IWhileCodeGenerator)Generator;
				var conditionBlock = Condition.Emit(whileCg);
				var bodyBlock = Body.Emit(whileCg);
				return whileCg.EmitWhile(Tag, conditionBlock, bodyBlock);
			}
			else
			{
				return Lower().Emit(Generator);
			}
		}
	}
}
