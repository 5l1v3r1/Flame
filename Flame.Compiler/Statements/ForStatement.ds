using System;
using System.Collections.Generic;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;

namespace Flame.Compiler.Statements
{
    public class ForStatement : ComplexStatement
    {
    	public const this(set IStatement Setup, set IExpression Condition, set IStatement Change, set IStatement Body, set IStatement End);
    	public const this(set IStatement Setup, set IExpression Condition, set IStatement Change, set IStatement Body)
        {
        	this.End = new EmptyStatement();
        }
        public const this(set IExpression Condition, set IStatement Change, set IStatement Body)
        {
        	this.Setup = new EmptyStatement();
        	this.End = new EmptyStatement();
        }
        public const this()
        {
            this.Setup = new EmptyStatement();
            this.Condition = new BooleanExpression(false);
            this.Body = new EmptyStatement();
            this.Change = new EmptyStatement();
            this.End = new EmptyStatement();
        }

        public IStatement Setup { const get; private set; }
        public IExpression Condition { const get; private set; }
        public IStatement Body { const get; private set; }
        public IStatement Change { const get; private set; }
        public IStatement End { const get; private set; }
        
        public override virtual IStatement Optimize()
        {
            var stmt = new ForStatement(Setup.Optimize(), Condition.Optimize(), Change.Optimize(), Body.Optimize(), End.Optimize());
            if (stmt.IsEmpty)
            {
            	return new EmptyStatement();
            }
            return stmt;
        }

        public override virtual void Emit(IBlockGenerator Generator)
        {
        	if (Generator.CodeGenerator is IForCodeGenerator)
        	{
        		var cg = (IForCodeGenerator)Generator.CodeGenerator;
        		var setupBlock = cg.CreateBlock();
        		Setup.Emit(setupBlock);
        		var condBlock = Condition.Emit(cg);
        		var deltaBlock = cg.CreateBlock();
        		Change.Emit(deltaBlock);
        		var forBlock = cg.CreateForBlock(setupBlock, condBlock, deltaBlock);
        		if (forBlock != null) // Code generator may choose to refuse our for block if it so chooses
        		{
        			Body.Emit(forBlock);
        			Generator.EmitBlock(forBlock);
        			if (!End.IsEmpty)
        			{
        				End.Emit(Generator);
        			}
        			return;
        		}
        	}
            Peel().Emit(Generator);
        }

        public override IStatement Peel()
        {
        	var list = new List<IStatement>();
            list.Add(Setup);
            
            var loopBody = new List<IStatement>();
            loopBody.Add(Body);
            loopBody.Add(Change);
            WhileStatement loop = new WhileStatement(Condition, new BlockStatement(loopBody));
            list.Add(loop);
            
            list.Add(End);
            BlockStatement block = new BlockStatement(list);
            return block;
        }
    }
}