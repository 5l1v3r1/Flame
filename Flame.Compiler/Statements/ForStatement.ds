using System;
using System.Collections.Generic;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;

namespace Flame.Compiler.Statements
{
    public class ForStatement : ComplexStatement
    {
    	public const this(set IStatement Setup, set IExpression Condition, set IStatement Change, set IStatement Body, set IStatement End);
    	public const this(set IStatement Setup, set IExpression Condition, set IStatement Change, set IStatement Body)
        {
        	this.End = new EmptyStatement();
        }
        public const this(set IExpression Condition, set IStatement Change, set IStatement Body)
        {
        	this.Setup = new EmptyStatement();
        	this.End = new EmptyStatement();
        }
        public const this()
        {
            this.Setup = new EmptyStatement();
            this.Condition = new BooleanExpression(false);
            this.Body = new EmptyStatement();
            this.Change = new EmptyStatement();
            this.End = new EmptyStatement();
        }

        public IStatement Setup { const get; private set; }
        public IExpression Condition { const get; private set; }
        public IStatement Body { const get; private set; }
        public IStatement Change { const get; private set; }
        public IStatement End { const get; private set; }

        public override virtual IStatement Optimize()
        {
            var stmt = new ForStatement(Setup.Optimize(), Condition.Optimize(), Change.Optimize(), Body.Optimize(), End.Optimize());
            if (stmt.IsEmpty)
            {
            	return new EmptyStatement();
            }
            return stmt;
        }

        public override virtual ICodeBlock Emit(ICodeGenerator Generator)
        {
        	if (Generator is IForCodeGenerator)
        	{
        		var cg = (IForCodeGenerator)Generator;
        		var setupBlock = Setup.Emit(cg);
        		var condBlock = Condition.Emit(cg);
        		var deltaBlock = Change.Emit(cg);
                var bodyBlock = Body.Emit(cg);
        		var forBlock = cg.EmitForBlock(setupBlock, condBlock, deltaBlock, bodyBlock);
        		if (forBlock != null) // Code generator may choose to refuse our
                                      // painstakingly constructed for block if it so chooses
        		{
        			if (!End.IsEmpty)
        			{
        				var endBlock = End.Emit(cg);
                        return cg.EmitSequence(forBlock, endBlock);
        			}
                    else
                    {
                        return forBlock;
                    }
        		}
        	}
            return Lower().Emit(Generator);
        }

        public override IStatement Lower()
        {
        	var list = new List<IStatement>();
            list.Add(Setup);

            var loopBody = new List<IStatement>();
            loopBody.Add(Body);
            loopBody.Add(Change);
            WhileStatement loop = new WhileStatement(Condition, new BlockStatement(loopBody));
            list.Add(loop);

            list.Add(End);
            BlockStatement block = new BlockStatement(list);
            return block;
        }
    }
}
