using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler.Emit;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Compiler.Statements
{
	public class CatchClause
	{
		private const this(set ManuallyBoundVariable exVariable, set IStatement Body);
		public const this(IVariableMember Member, set IStatement Body)
		{
			this.exVariable = new ManuallyBoundVariable(Member);
		}
		public const this(IVariableMember Member)
		{
			this.exVariable = new ManuallyBoundVariable(Member);
			this.Body = EmptyStatement;
		}

		private ManuallyBoundVariable exVariable;

		public IVariable ExceptionVariable { const get return exVariable; }
		public IStatement Body { const get; set; }

		public CatchClause ConvertType(MemberConverter Converter)
		{
			if (exVariable.IsBound)
			{
				return this; // Too bad. We can't safely convert this exception variable's type.
			}

			var exType = exVariable.Type;
			var convExType = Converter.Convert(exType);
			if (object.ReferenceEquals(exType, convExType))
			{
				return this;
			}
			else
			{
				var convExVariable = new ManuallyBoundVariable(new RetypedVariableMember(exVariable.Member, convExType));
				var convMapping = new Dictionary<IVariable, IVariable>();
				convMapping[exVariable] = convExVariable;
				var variableSubst = new VariableSubstitutingVisitor(convMapping);
				var visitedBody = variableSubst.Visit(Body);
				return new CatchClause(convExVariable, visitedBody);
			}
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(Body);
		}

		public CatchClause Accept(INodeVisitor Visitor)
		{
			var visitedBody = Visitor.Visit(Body);

			if (visitedBody == Body)
			{
				return this;
			}
			else
			{
				return new CatchClause(exVariable, EmptyStatement);
			}
		}

		public const CatchClause Optimize()
		{
			return new CatchClause(exVariable, Body.Optimize());
		}

		public ICatchClause Emit(IExceptionCodeGenerator Generator)
		{
			var header = Generator.EmitCatchHeader(exVariable.Member);
			exVariable.BindVariable(header.ExceptionVariable);
			var body = Body.Emit(Generator);
			return Generator.EmitCatchClause(header, body);
		}
	}

	public class TryStatement : IStatement, IPredicateNode, IMemberNode
	{
		public const this(set IStatement TryBody, set IStatement FinallyBody)
		{
			this.CatchClauses = Enumerable.Empty<CatchClause>();
		}
		public const this(set IStatement TryBody, set [CatchClause] CatchClauses)
		{
			this.FinallyBody = EmptyStatement;
		}
		public const this(set IStatement TryBody, set IStatement FinallyBody, set [CatchClause] CatchClauses);

		public IStatement TryBody { const get; private set; }
		public IStatement FinallyBody { const get; private set; }
		public [CatchClause] CatchClauses { const get; private set; }

		public IMemberNode ConvertMembers(MemberConverter Converter)
		{
			var convCatches = new List<CatchClause>();
			bool sameStatement = true;
			foreach (var item in CatchClauses)
			{
				var visitedClause = item.ConvertType(Converter);
				if (visitedClause != item)
				{
					sameStatement = false;
				}
				convCatches.Add(visitedClause);
			}
			if (sameStatement) return this;
			else return new TryStatement(TryBody, FinallyBody, convCatches);
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(TryBody);
			Visitor.Visit(FinallyBody);
			foreach (var item in CatchClauses)
			{
				item.AcceptPredicate(Visitor);
			}
		}

		public IStatement Accept(INodeVisitor Visitor)
		{
			var visitedTryBody = Visitor.Visit(TryBody);
			var visitedFinallyBody = Visitor.Visit(FinallyBody);
			var visitedCatchClauses = new List<CatchClause>();

			bool sameStatement = visitedTryBody == TryBody && visitedFinallyBody == FinallyBody;
			foreach (var item in CatchClauses)
			{
				var visitedClause = item.Accept(Visitor);
				if (visitedClause != item)
				{
					sameStatement = false;
				}
				visitedCatchClauses.Add(visitedClause);
			}

			if (sameStatement) return this;
			else return new TryStatement(visitedTryBody, visitedFinallyBody, visitedCatchClauses);
		}

		public bool IsEmpty
		{
			const get return TryBody.IsEmpty && FinallyBody.IsEmpty;
		}

		public const IStatement Optimize()
		{
			var optTry = TryBody.Optimize();
			var optFinally = FinallyBody.Optimize();
			List<CatchClause> optClauses = new List<CatchClause>();
			foreach (var item in CatchClauses)
			{
				optClauses.Add(item.Optimize());
			}
			return new TryStatement(optTry, optFinally, optClauses);
		}

		public ICodeBlock Emit(ICodeGenerator Generator)
		{
			var cg = (IExceptionCodeGenerator)Generator;
			var tryBlock = TryBody.Emit(Generator);
			var finallyBlock = FinallyBody.Emit(Generator);
			var catchBlocks = new List<ICatchClause>();
			foreach (var item in CatchClauses)
			{
				catchBlocks.Add(item.Emit(cg));
			}
			return cg.EmitTryBlock(tryBlock, finallyBlock, catchBlocks);
		}
	}
}
