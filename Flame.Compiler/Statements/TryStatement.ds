using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Compiler.Statements
{
	public class CatchClause
	{
		private const this(set ManuallyBoundVariable exVariable, set IStatement Body);
		public const this(IVariableMember Member, set IStatement Body)
		{
			this.exVariable = new ManuallyBoundVariable(Member);
		}
		public const this(IVariableMember Member)
		{
			this.exVariable = new ManuallyBoundVariable(Member);
			this.Body = EmptyStatement;
		}

		private ManuallyBoundVariable exVariable;

		public IVariable ExceptionVariable { const get return exVariable; }
		public IStatement Body { const get; set; }

		public CatchClause ConvertType(MemberConverter Converter)
		{
			if (exVariable.IsBound)
			{
				return this; // Too bad. We can't safely convert this exception variable's type.
			}

			var exType = exVariable.Type;
			var convExType = Converter.Convert(exType);
			if (object.ReferenceEquals(exType, convExType))
			{
				return this;
			}
			else
			{
				var convExVariable = new ManuallyBoundVariable(new RetypedVariableMember(exVariable.Member, convExType));
				var convMapping = new Dictionary<IVariable, IVariable>();
				convMapping[exVariable] = convExVariable;
				var variableSubst = new VariableSubstitutingVisitor(convMapping);
				var visitedBody = variableSubst.Visit(Body);
				return new CatchClause(convExVariable, visitedBody);
			}
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(Body);
		}

		public CatchClause Accept(INodeVisitor Visitor)
		{
			var visitedBody = Visitor.Visit(Body);

			if (visitedBody == Body)
			{
				return this;
			}
			else
			{
				return new CatchClause(exVariable, visitedBody);
			}
		}

		public const CatchClause Optimize()
		{
			return new CatchClause(exVariable, Body.Optimize());
		}

		public ICatchClause Emit(IExceptionCodeGenerator Generator)
		{
			var header = Generator.EmitCatchHeader(exVariable.Member);
			exVariable.BindVariable(header.ExceptionVariable);
			var body = Body.Emit(Generator);
			return Generator.EmitCatchClause(header, body);
		}

		public UniqueTag ToBlock(BlockBuildingVisitor Visitor, FinallyFlow OutFlow)
		{
			var exVar = new LocalVariable(ExceptionVariable.Type);
			exVariable.BindVariable(exVar);
			var newBody = new BlockStatement(new IStatement[]
			{
				exVar.CreateSetStatement(new CaughtExceptionExpression(exVar.Type)),
				Body
			}).Simplify();
			return Visitor.CreateBlock("catch", newBody, OutFlow);
		}
	}

	public class TryStatement : IStatement, IPredicateNode, IMemberNode, IFlowStatement
	{
		public const this(set IStatement TryBody, set IStatement FinallyBody)
		{
			this.CatchClauses = Enumerable.Empty<CatchClause>();
		}
		public const this(set IStatement TryBody, set [CatchClause] CatchClauses)
		{
			this.FinallyBody = EmptyStatement;
		}
		public const this(set IStatement TryBody, set IStatement FinallyBody, set [CatchClause] CatchClauses);

		public IStatement TryBody { const get; private set; }
		public IStatement FinallyBody { const get; private set; }
		public [CatchClause] CatchClauses { const get; private set; }

		public IMemberNode ConvertMembers(MemberConverter Converter)
		{
			var convCatches = new List<CatchClause>();
			bool sameStatement = true;
			foreach (var item in CatchClauses)
			{
				var visitedClause = item.ConvertType(Converter);
				if (visitedClause != item)
				{
					sameStatement = false;
				}
				convCatches.Add(visitedClause);
			}
			if (sameStatement) return this;
			else return new TryStatement(TryBody, FinallyBody, convCatches);
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			Visitor.Visit(TryBody);
			Visitor.Visit(FinallyBody);
			foreach (var item in CatchClauses)
			{
				item.AcceptPredicate(Visitor);
			}
		}

		public IStatement Accept(INodeVisitor Visitor)
		{
			var visitedTryBody = Visitor.Visit(TryBody);
			var visitedFinallyBody = Visitor.Visit(FinallyBody);
			var visitedCatchClauses = new List<CatchClause>();

			bool sameStatement = visitedTryBody == TryBody && visitedFinallyBody == FinallyBody;
			foreach (var item in CatchClauses)
			{
				var visitedClause = item.Accept(Visitor);
				if (visitedClause != item)
				{
					sameStatement = false;
				}
				visitedCatchClauses.Add(visitedClause);
			}

			if (sameStatement) return this;
			else return new TryStatement(visitedTryBody, visitedFinallyBody, visitedCatchClauses);
		}

		/// <summary>
		/// Creates a number of basic blocks that are semantically equivalent
		/// to this flow statement.
		/// </summary>
		public void ToBlocks(BlockBuildingVisitor Visitor)
		{
			// Generate the following blocks:
			//
			// @entry:
			//     try @try()
			//
			// @try():
			//     <try-body>
			//     finally @finally()
			//
			// @catch_i():
			//     var ex = caught-exception;
			//     <catch-body>
			//     finally @finally()
			//
			// @finally():
			//     <finally-body>
			//     leave @next()

			var nextBlockTag = Visitor.Builder.NextBlockTag;

			var finallyTag = Visitor.CreateBlock("finally", FinallyBody, new LeaveFlow(new BlockBranch(nextBlockTag)));
			var finallyBr = new BlockBranch(finallyTag);
			var finallyFlow = new FinallyFlow(finallyBr);

			var ehBlocks = new List<ExceptionBranch>();
			foreach (var clause in CatchClauses)
			{
				var ehTag = clause.ToBlock(Visitor, finallyFlow);
				ehBlocks.Add(new ExceptionBranch(
					clause.ExceptionVariable.Type, new BlockBranch(ehTag)));
			}

			var tryTag = Visitor.CreateTryBlock("try", TryBody, ehBlocks, finallyBr);

			Visitor.Builder.CreateCurrentBlock(
				EmptyStatement, new TryFlow(new BlockBranch(tryTag)));
		}

		/// <summary>
		/// Accepts and interacts with a flow visitor.
		/// </summary>
		public IStatement AcceptFlow<TState, TFlow>(IFlowVisitor<TState, TFlow> Visitor)
		{
			// HACK: Just lie to the visitor and pretend this is linear flow.
			//       This is evil, but the visitor would have assumed this
			//       to be the case anyway had we not implemented IFlowStatement.
			return Accept(Visitor);
		}

		public bool IsConstantNode
		{
			const get return true;
		}

		public const IStatement Optimize()
		{
			var optTry = TryBody.Optimize();
			var optFinally = FinallyBody.Optimize();
			List<CatchClause> optClauses = new List<CatchClause>();
			foreach (var item in CatchClauses)
			{
				optClauses.Add(item.Optimize());
			}
			return new TryStatement(optTry, optFinally, optClauses);
		}

		public ICodeBlock Emit(ICodeGenerator Generator)
		{
			var cg = (IExceptionCodeGenerator)Generator;
			var tryBlock = TryBody.Emit(Generator);
			var finallyBlock = FinallyBody.Emit(Generator);
			var catchBlocks = new List<ICatchClause>();
			foreach (var item in CatchClauses)
			{
				catchBlocks.Add(item.Emit(cg));
			}
			return cg.EmitTryBlock(tryBlock, finallyBlock, catchBlocks);
		}
	}
}
