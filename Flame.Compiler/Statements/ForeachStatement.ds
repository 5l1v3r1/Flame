using System;
using System.Collections.Generic;
using System.Text;
using Flame.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Compiler.Statements
{
	public class ForeachElementCache
	{
		public const this()
		{
			this.ElementVariables = new List<ManuallyBoundVariable>();
		}

		public List<ManuallyBoundVariable> ElementVariables { const get; private set; }
	}

	public class ForeachStatement : IStatement, IPredicateNode, IMemberNode
	{
		public const this(set [CollectionElement] Collections, set IStatement Body, set ForeachElementCache elemCache);
		public const this(set [CollectionElement] Collections)
		{
			this.Body = new EmptyStatement();
			this.elemCache = new ForeachElementCache();
			foreach (var item in Collections)
			{
				elemCache.ElementVariables.Add(new ManuallyBoundVariable(item.Member));
			}
		}

		public [CollectionElement] Collections { const get; private set; }
		public IStatement Body { const get; set; }

		private ForeachElementCache elemCache;

		public IReadOnlyList<IVariable> Elements { const get return elemCache.ElementVariables; }

		public bool IsEmpty : IStatement.IsEmpty
		{
			const get
			{
				return Body.IsEmpty;
			}
		}

		public IMemberNode ConvertMembers(MemberConverter Converter)
		{
			bool sameElems = true;
			var newCollectionElements = new List<CollectionElement>();
			foreach (var item in Collections)
			{
				var newElem = item.ConvertType(Converter);
				if (newElem != item)
				{
					sameElems = false;
				}
				newCollectionElements.Add(newElem);
			}

			if (sameElems)
			{
				return this;
			}

			var newForeachStmt = new ForeachStatement(newCollectionElements);

			var substDict = new Dictionary<IVariable, IVariable>();
			foreach (var item in newForeachStmt.elemCache.ElementVariables, var elem in elemCache.ElementVariables)
			{
				substDict[elem] = item;
			}

			var substVisitor = new VariableSubstitutingVisitor(substDict);
			newForeachStmt.Body = substVisitor.Visit(Body);

			return newForeachStmt;
		}

		public void AcceptPredicate(INodeVisitor Visitor)
		{
			foreach (var item in Collections)
			{
				item.AcceptPredicate(Visitor);
			}
			Visitor.Visit(Body);
		}

		private ForeachStatement Accept(INodeVisitor Visitor, bool ApplyToBody)
		{
			bool sameElems = true;

			var newCollectionElements = new List<CollectionElement>();
			foreach (var item in Collections)
			{
				var newElem = item.Accept(Visitor);
				if (newElem != item)
				{
					sameElems = false;
				}
				newCollectionElements.Add(newElem);
			}

			if (sameElems)
			{
				if (ApplyToBody)
					return new ForeachStatement(Collections, Visitor.Visit(Body), elemCache);
				else
					return this;
			}

			var newForeachStmt = new ForeachStatement(newCollectionElements);
			foreach (var item in newForeachStmt.elemCache.ElementVariables, var elem in elemCache.ElementVariables)
			{
				elem.BindVariable(item);
			}

			if (ApplyToBody)
				newForeachStmt.Body = Visitor.Visit(Body);
			else
				newForeachStmt.Body = Body;

			return newForeachStmt;
		}

		public ForeachStatement AcceptCollections(INodeVisitor Visitor)
		{
			return Accept(Visitor, false);
		}

		public IStatement Accept(INodeVisitor Visitor)
		{
			return Accept(Visitor, true);
		}

		public IStatement Optimize() : IStatement.Optimize
		{
			var optColl = new List<CollectionElement>();
			foreach (var item in Collections)
			{
				optColl.Add(new CollectionElement(item.Member, item.Collection.Optimize()));
			}
			var optBody = Body.Optimize();
			return new ForeachStatement(optColl, optBody, elemCache);
		}

		public ICodeBlock Emit(ICodeGenerator Generator) : INode.Emit
		{
			if (Generator is IForeachCodeGenerator)
			{
				var cg = (IForeachCodeGenerator)Generator;
				List<ICollectionBlock> collectionBlocks = new List<ICollectionBlock>();
				foreach (var item in Collections)
				{
					collectionBlocks.Add(cg.EmitCollectionBlock(item.Member, item.Collection.Emit(cg)));
				}

				var loopHeader = cg.EmitForeachHeader(collectionBlocks);

				if (loopHeader != null)
				{
					foreach (var item in loopHeader.Elements, var elem in elemCache.ElementVariables)
						elem.BindVariable(item);

					var body = Body.Emit(Generator);

					var result = cg.EmitForeachBlock(loopHeader, body);

					if (result != null)
						return result;
				}
			}
			return this.Lower().Emit(Generator);
		}

		/// <summary>
		/// Reduces the foreach statements to more primitive statements.
		/// </summary>
		public IStatement Lower()
		{
			var initStatements = new List<IStatement>();
            var conditions = new List<IExpression>();
            var deltas = new List<IStatement>();
            var finalStatements = new List<IStatement>();
            var bodyInits = new List<IStatement>();

            IVariable index = null;
            foreach (var item in Collections, var elem in elemCache.ElementVariables)
            {
                var elemInCollection = item.Reduce(index);
                elem.BindVariable(elemInCollection.Variable);
                if (elemInCollection.Index != null)
                {
                    index = elemInCollection.Index;
                }
                bodyInits.Add(elemInCollection.BodyInitialization);
                initStatements.Add(elemInCollection.Initialization);
                conditions.Add(elemInCollection.Condition);
                deltas.Add(elemInCollection.Delta);
                finalStatements.Add(elemInCollection.Finalization);
            }

        	var init = new BlockStatement(initStatements.ToArray());
            IExpression cond = conditions[0];
            for (int i = 1; i < conditions.Count; i++)
			{
                cond = new LazyAndExpression(cond, conditions[i]);
			}
            var bodyInit = new BlockStatement(bodyInits.ToArray());
            var delta = new BlockStatement(deltas.ToArray());

            var body = new BlockStatement(new IStatement[] { bodyInit, Body });

            var final = new BlockStatement(finalStatements.ToArray());

            return new ForStatement(init, cond, delta, body, final);
		}
	}
}
