using System;
using System.Collections.Generic;
using System.Text;
using Flame.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;

namespace Flame.Compiler.Statements
{
	public class ForeachElementCache
	{
		public const this()
		{
			this.ElementVariables = new List<ManuallyBoundVariable>();
		}

		public List<ManuallyBoundVariable> ElementVariables { const get; private set; }
	}

	public class ForeachStatement : IStatement
	{
		public const this(set IEnumerable<CollectionElement> Collections, set IStatement Body, set ForeachElementCache elemCache);
		public const this(set IEnumerable<CollectionElement> Collections)
		{
			this.Body = new EmptyStatement();
			this.elemCache = new ForeachElementCache();
			foreach (var item in Collections)
			{
				elemCache.ElementVariables.Add(new ManuallyBoundVariable(item.Member));
			}
		}

		public IEnumerable<CollectionElement> Collections { const get; private set; }
		public IStatement Body { const get; set; }

		private ForeachElementCache elemCache;

		public IReadOnlyList<IVariable> Elements { const get return elemCache.ElementVariables; }

		public bool IsEmpty : IStatement.IsEmpty
		{
			const get
			{
				return Body.IsEmpty;
			}
		}

		public IStatement Optimize() : IStatement.Optimize
		{
			var optColl = new List<CollectionElement>();
			foreach (var item in Collections)
			{
				optColl.Add(new CollectionElement(item.Member, item.Collection.Optimize()));
			}
			var optBody = Body.Optimize();
			return new ForeachStatement(optColl, optBody, elemCache);
		}

		public void Emit(IBlockGenerator Generator) : IStatement.Emit
		{
			var codeGen = Generator.CodeGenerator;
			if (codeGen is IForeachCodeGenerator)
			{
				var cg = (IForeachCodeGenerator)codeGen;
				List<ICollectionBlock> collectionBlocks = new List<ICollectionBlock>();
				foreach (var item in Collections)
				{
					collectionBlocks.Add(cg.CreateCollectionBlock(item.Member, item.Collection.Emit(cg)));
				}
				var loopBlock = cg.CreateForeachBlock(collectionBlocks);

				if (loopBlock == null)
				{
					this.Reduce().Emit(Generator);
				}
				else
				{
					foreach (var item in loopBlock.Elements, var elem in elemCache.ElementVariables)
						elem.BindVariable(item);

					Body.Emit(loopBlock);
					Generator.EmitBlock(loopBlock);
				}
			}
			else
			{
				this.Reduce().Emit(Generator);
			}
		}

		/// <summary>
		/// Reduces the foreach statements to more primitive statements.
		/// </summary>
		public IStatement Reduce()
		{
			var initStatements = new List<IStatement>();
            var conditions = new List<IExpression>();
            var deltas = new List<IStatement>();
            var finalStatements = new List<IStatement>();
            var bodyInits = new List<IStatement>();

            IVariable index = null;
            foreach (var item in Collections, var elem in elemCache.ElementVariables)
            {
                var elemInCollection = item.Reduce(index);
                elem.BindVariable(elemInCollection.Variable);
                if (elemInCollection.Index != null)
                {
                    index = elemInCollection.Index;
                }
                bodyInits.Add(elemInCollection.BodyInitialization);
                initStatements.Add(elemInCollection.Initialization);
                conditions.Add(elemInCollection.Condition);
                deltas.Add(elemInCollection.Delta);
                finalStatements.Add(elemInCollection.Finalization);
            }

        	var init = new BlockStatement(initStatements.ToArray());
            IExpression cond = conditions[0];
            for (int i = 1; i < conditions.Count; i++)
			{
                cond = new LazyAndExpression(cond, conditions[i]);
			}
            var bodyInit = new BlockStatement(bodyInits.ToArray());
            var delta = new BlockStatement(deltas.ToArray());

            var body = new BlockStatement(new IStatement[] { bodyInit, Body });

            var final = new BlockStatement(finalStatements.ToArray());

            return new ForStatement(init, cond, delta, body, final);
		}
	}
}
