using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler.Emit;

namespace Flame.Compiler.Statements
{
	public class ContractBodyStatement : IStatement
	{
		public const this(set IStatement Body, set [IExpression] Preconditions, set [IExpression] Postconditions);

		public IStatement Body { const get; private set; }
		public [IExpression] Preconditions { const get; private set; }
		public [IExpression] Postconditions { const get; private set; }

		public const IStatement Optimize()
		{
			if (!Enumerable.Any<IExpression>(Preconditions) && !Enumerable.Any<IExpression>(Postconditions))
			{
				return Body.Optimize();
			}
			else
			{
				return new ContractBodyStatement(Body.Optimize(), Preconditions.OptimizeAll(), Postconditions.OptimizeAll());
			}
		}

		public bool IsEmpty
		{
			const get return Body.IsEmpty && !Enumerable.Any<IExpression>(Preconditions) && !Enumerable.Any<IExpression>(Postconditions);
		}

		public ICodeBlock Emit(ICodeGenerator Target)
		{
			if (Target is IContractCodeGenerator)
			{
				var cg = (IContractCodeGenerator)Target;

				var pre = Preconditions.EmitAll(cg);
				var post = Postconditions.EmitAll(cg);
				var body = Body.Emit(cg);
				return cg.EmitContractBlock(pre, post, body);
			}
			else if (Target is IExceptionCodeGenerator)
			{
				var cg = (IExceptionCodeGenerator)Target;

				var pres = cg.EmitVoid();
				foreach (var item in Preconditions)
				{
					pres = cg.EmitSequence(pres, cg.EmitAssert(item.Emit(cg)));
				}
				return cg.EmitSequence(pres, Body.Emit(Target));
				/*foreach (var item in Postconditions) // Not helpful. The method has already returned at this point.
				{
					Target.EmitBlock(cg.EmitAssert(item.Emit(cg)));
				}*/
			}
			else
			{
				return Body.Emit(Target);
			}
		}
	}
}
