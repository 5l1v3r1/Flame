using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Compiler.Statements
{
	public class DoWhileStatement : IStatement, IFlowStatement
	{
		public const this(set IStatement Body, set IExpression Condition)
		{
			this.Tag = new BlockTag();
		}
		public const this(set BlockTag Tag, set IStatement Body, set IExpression Condition);

		public BlockTag Tag { const get; private set; }
		public IExpression Condition { const get; private set; }
		public IStatement Body { const get; private set; }

		private const DoWhileStatement CreateDoWhile(IStatement NewBody, IExpression NewCondition)
		{
			if (NewCondition == Condition && NewBody == Body)
			{
				return this;
			}
			else
			{
				return new DoWhileStatement(Tag, NewBody, NewCondition);
			}
		}

		public IStatement AcceptFlow<TState, TFlow>(IFlowVisitor<TState, TFlow> Visitor)
			: IFlowStatement.AcceptFlow<TState, TFlow>
		{
			var startFlow = Visitor.CurrentFlow;

			var transBody = Visitor.Visit(Body);

			var transCond = Visitor.Visit(Condition);
			var bodyFlow = Visitor.CreateDeltaFlow(startFlow, Visitor.CurrentFlow);

			var loopFlow = Visitor.CreateLoopFlow(bodyFlow);
			// var doWhileFlow = Visitor.CreateSequenceFlow(bodyFlow, loopFlow);
			// NOTE: 'doWhileFlow' is a more accurate description than 'loopFlow',
			//       however, continue/break statements are said to terminate (local) flow.
			//       Stating that the body and the looped body are executed in sequence
			//       would mean that global flow could be terminated.

			Visitor.CurrentFlow = Visitor.CreateCollapsedFlow(startFlow, loopFlow);

			return CreateDoWhile(transBody, transCond);
		}

		public IStatement Accept(INodeVisitor Visitor)
		{
			var transCond = Visitor.Visit(Condition);
			var transBody = Visitor.Visit(Body);

			return CreateDoWhile(transBody, transCond);
		}

		public bool IsEmpty : IStatement.IsEmpty
		{
			const get
			{
				return Body.IsEmpty;
			}
		}

		public IStatement Optimize() : IStatement.Optimize
		{
			var optCond = Condition.Optimize();
			var optBody = Body.Optimize();

			/*if (optCond.EvaluatesTo<bool>(false))
			{
				return optBody; // This may not be applicable if the body Statement
								// contains a break statement.
			}*/

			return CreateDoWhile(optBody, optCond);
		}

		public ICodeBlock Emit(ICodeGenerator Generator) : INode.Emit
		{
			var body = Body.Emit(Generator);
			var conditionBlock = Condition.Emit(Generator);

			if (Generator is IDoWhileCodeGenerator)
			{
				var whileCg = (IDoWhileCodeGenerator)Generator;
				return whileCg.EmitDoWhile(Tag, body, conditionBlock);
			}
			else
			{
				// "Lower" a do-while block like this:
				//
				// do stmt; while (cond)
				//
				// ==>
				//
				// block:
				// {
				//     stmt;
				//     if (cond) continue block;
				// }

				var continueBlock = Generator.EmitIfElse(conditionBlock,
														 Generator.EmitContinue(Tag),
													     Generator.EmitVoid());
				var seqBlock = Generator.EmitSequence(body, continueBlock);
				return Generator.EmitTagged(Tag, seqBlock);
			}
		}
	}
}
