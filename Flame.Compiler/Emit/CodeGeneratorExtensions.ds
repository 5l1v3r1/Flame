using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler.Expressions;
using Flame.Compiler.Emit;

namespace Flame.Compiler
{
	public static class CodeGeneratorExtensions
	{
		#region Math

		/// <summary>
		/// Creates a block that adds the given values.
		/// </summary>
		public static ICodeBlock EmitAdd(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Add);
		}

		/// <summary>
		/// Creates a block that subtracts the given values.
		/// </summary>
		public static ICodeBlock EmitSubtract(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Subtract);
		}

		/// <summary>
		/// Creates a block that multiplies the given values.
		/// </summary>
		public static ICodeBlock EmitMultiply(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Multiply);
		}

		/// <summary>
		/// Creates a block that divides the given values.
		/// </summary>
		public static ICodeBlock EmitDivide(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Divide);
		}

		public static ICodeBlock EmitLeftShift(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.LeftShift);
		}
		public static ICodeBlock EmitRightShift(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.RightShift);
		}

		public static ICodeBlock EmitAnd(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.And);
		}
		public static ICodeBlock EmitOr(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Or);
		}
		public static ICodeBlock EmitXor(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Xor);
		}

		public static ICodeBlock EmitEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckEquality);
		}
		public static ICodeBlock EmitNotEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var inequalityBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckInequality);
			if (inequalityBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckEquality));
			}
			else
			{
				return inequalityBlock;
			}
		}
		public static ICodeBlock EmitLessThan(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckLessThan);
		}
		public static ICodeBlock EmitLessThanOrEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var cleBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckLessThanOrEqual);
			if (cleBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThan));
			}
			else
			{
				return cleBlock;
			}
		}
		public static ICodeBlock EmitGreaterThan(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThan);
		}
		public static ICodeBlock EmitGreaterThanOrEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var cleBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThanOrEqual);
			if (cleBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckLessThan));
			}
			else
			{
				return cleBlock;
			}
		}

		public static ICodeBlock EmitNot(this ICodeGenerator CodeGenerator, ICodeBlock Value)
		{
			return CodeGenerator.EmitUnary(Value, Operator.Not);
		}

		public static ICodeBlock EmitLogicalAnd(this ICodeGenerator CodeGenerator, ICodeBlock Left, ICodeBlock Right)
		{
			var block = CodeGenerator.EmitBinary(Left, Right, Operator.LogicalAnd);
			if (block != null)
			{
				return block;
			}
			else
			{
				// Left ? Right : false
				return CodeGenerator.EmitIfElse(Left, Right, CodeGenerator.EmitBoolean(false));
			}
		}

		public static ICodeBlock EmitLogicalOr(this ICodeGenerator CodeGenerator, ICodeBlock Left, ICodeBlock Right)
		{
			var block = CodeGenerator.EmitBinary(Left, Right, Operator.LogicalOr);
			if (block != null)
			{
				return block;
			}
			else
			{
				// Left ? true : Right
				return CodeGenerator.EmitIfElse(Left, CodeGenerator.EmitBoolean(true), Right);
            }
		}

		#endregion

		#region Object Model

		public static ICodeBlock EmitGetField(this ICodeGenerator CodeGenerator, IField Field, ICodeBlock Target)
		{
			return CodeGenerator.GetField(Field, Target).EmitGet();
		}
		public static ICodeBlock EmitGetFieldAddress(this IUnmanagedCodeGenerator CodeGenerator, IField Field, ICodeBlock Target)
		{
			return CodeGenerator.GetUnmanagedField(Field, Target).EmitAddressOf();
		}
		public static ICodeBlock EmitSetField(this ICodeGenerator CodeGenerator, IField Field, ICodeBlock Target, ICodeBlock Value)
		{
			return CodeGenerator.GetField(Field, Target).EmitSet(Value);
		}

		public static ICodeBlock EmitInvocation(this ICodeGenerator CodeGenerator, IMethod Method, ICodeBlock Caller, IEnumerable<ICodeBlock> Arguments)
		{
			return CodeGenerator.EmitInvocation(CodeGenerator.EmitMethod(Method, Caller), Arguments);
		}

		public static IEmitVariable DeclareVariable(this IMethodStructureGenerator Generator, IType Type)
		{
			return Generator.DeclareVariable(new TypeVariableMember(Type));
		}

		public static IUnmanagedEmitVariable DeclareUnmanagedVariable(this IUnmanagedMethodStructureGenerator Generator, IType Type)
		{
			return Generator.DeclareUnmanagedVariable(new TypeVariableMember(Type));
		}

		#endregion
	}
}
