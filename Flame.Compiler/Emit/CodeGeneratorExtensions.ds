using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler.Expressions;
using Flame.Compiler.Emit;

namespace Flame.Compiler
{
	public static class CodeGeneratorExtensions
	{
		#region Math
	
		public static ICodeBlock EmitAdd(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Add);
		}
		public static ICodeBlock EmitSubtract(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Subtract);
		}
		public static ICodeBlock EmitMultiply(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Multiply);
		}
		public static ICodeBlock EmitDivide(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Divide);
		}
		
		public static ICodeBlock EmitLeftShift(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.LeftShift);
		}
		public static ICodeBlock EmitRightShift(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.RightShift);
		}
		
		public static ICodeBlock EmitAnd(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.And);
		}
		public static ICodeBlock EmitOr(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Or);
		}
		public static ICodeBlock EmitXor(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.Xor);
		}
		
		public static ICodeBlock EmitEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckEquality);
		}
		public static ICodeBlock EmitNotEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var inequalityBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckInequality);
			if (inequalityBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckEquality));
			}
			else
			{
				return inequalityBlock;
			}
		}
		public static ICodeBlock EmitLessThan(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckLessThan);
		}
		public static ICodeBlock EmitLessThanOrEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var cleBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckLessThanOrEqual);
			if (cleBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThan));
			}
			else
			{
				return cleBlock;
			}
		}
		public static ICodeBlock EmitGreaterThan(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			return CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThan);
		}
		public static ICodeBlock EmitGreaterThanOrEquals(this ICodeGenerator CodeGenerator, ICodeBlock A, ICodeBlock B)
		{
			var cleBlock = CodeGenerator.EmitBinary(A, B, Operator.CheckGreaterThanOrEqual);
			if (cleBlock == null)
			{
				return CodeGenerator.EmitNot(CodeGenerator.EmitBinary(A, B, Operator.CheckLessThan));
			}
			else
			{
				return cleBlock;
			}
		}
		
		public static ICodeBlock EmitNot(this ICodeGenerator CodeGenerator, ICodeBlock Value)
		{
			return CodeGenerator.EmitUnary(Value, Operator.Not);
		}
		
		public static ICodeBlock EmitLogicalAnd(this ICodeGenerator CodeGenerator, ICodeBlock Left, ICodeBlock Right)
		{
			var block = CodeGenerator.EmitBinary(Left, Right, Operator.LogicalAnd);
			if (block != null)
			{
				return block;
			}
			else
			{
				var ifElseBlock = CodeGenerator.CreateIfElseBlock(Left);
        		ifElseBlock.IfBlock.EmitBlock(Right);
        		ifElseBlock.ElseBlock.EmitBlock(CodeGenerator.EmitBoolean(false));
            	return ifElseBlock;
			}
		}
		
		public static ICodeBlock EmitLogicalOr(this ICodeGenerator CodeGenerator, ICodeBlock Left, ICodeBlock Right)
		{
			var block = CodeGenerator.EmitBinary(Left, Right, Operator.LogicalOr);
			if (block != null)
			{
				return block;
			}
			else
			{
				var ifElseBlock = CodeGenerator.CreateIfElseBlock(Left);
	        	ifElseBlock.IfBlock.EmitBlock(CodeGenerator.EmitBoolean(true));
	        	ifElseBlock.ElseBlock.EmitBlock(Right);
	            return ifElseBlock;
            }
		}
		
		#endregion
		
		#region Object Model
		
		public static ICodeBlock EmitGetField(this ICodeGenerator CodeGenerator, IField Field, ICodeBlock Target)
		{
			return CodeGenerator.GetField(Field, Target).CreateGetExpression().Emit(CodeGenerator);
		}
		public static ICodeBlock EmitGetFieldAddress(this IUnmanagedCodeGenerator CodeGenerator, IField Field, ICodeBlock Target)
		{
			return CodeGenerator.GetUnmanagedField(Field, Target).CreateAddressOfExpression().Emit(CodeGenerator);
		}
		public static void EmitSetField(this IBlockGenerator BlockGenerator, IField Field, ICodeBlock Target, ICodeBlock Value)
		{
			BlockGenerator.CodeGenerator.GetField(Field, Target).CreateSetStatement(new CodeBlockExpression(Value, Field.FieldType)).Emit(BlockGenerator);
		}
		
		public static ICodeBlock EmitInvocation(this ICodeGenerator CodeGenerator, IMethod Method, ICodeBlock Caller, IEnumerable<ICodeBlock> Arguments)
		{
			return CodeGenerator.EmitInvocation(CodeGenerator.EmitMethod(Method, Caller), Arguments);
		}
		
		public static IVariable DeclareVariable(this IMethodStructureGenerator Generator, IType Type)
		{
			return Generator.DeclareVariable(new TypeVariableMember(Type)); 
		}
		
		public static IUnmanagedVariable DeclareUnmanagedVariable(this IUnmanagedMethodStructureGenerator Generator, IType Type)
		{
			return Generator.DeclareUnmanagedVariable(new TypeVariableMember(Type));
		}
		
		#endregion
	}
}