using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;

namespace Flame.Compiler.Variables
{
    /// <summary>
    /// Defines a type of variable that operates analogously to a property:
    /// get-expressions call the 'get' accessor, and set-statements call the
    /// 'set' accessor.
    /// </summary>
    /// <remarks>
    /// In the past, property variables were actually associated with a single
    /// property, but this doesn't work well with asymmetric property overrides.
    /// Consider the following snippet of code:
    /// <code>
    /// public abstract VectorBase
    /// {
    ///     double Length { virtual get { ... } virtual set { ... } }
    /// }
    ///
    /// public class Vector
    /// {
    ///     public double Length { override get { ... } }
    ///     public double LengthSquared { get { return Length * Length; } }
    ///                                                ^~~~~~ refers to `Vector.Length`
    ///     public void SetLength(double Value)
    ///     {
    ///         Length = Value;
    ///         ^~~~~~ refers to `VectorBase.Length`
    ///     }
    /// }
    /// </code>
    /// </remarks>
    public class PropertyVariable : IVariable
    {
        public const this(IProperty Property)
        {
        	this.Caller = null;
        	this.IndexerArguments = Enumerable.Empty<IExpression>();
            this.GetAccessor = Property.GetGetAccessor();
            this.SetAccessor = Property.GetSetAccessor();
        }
        public const this(IProperty Property, set IExpression Caller)
        {
        	this.IndexerArguments = Enumerable.Empty<IExpression>();
            this.GetAccessor = Property.GetGetAccessor();
            this.SetAccessor = Property.GetSetAccessor();
        }
        public const this(IProperty Property, set IExpression Caller,
                          set [IExpression] IndexerArguments)
        {
            this.GetAccessor = Property.GetGetAccessor();
            this.SetAccessor = Property.GetSetAccessor();
        }
        public const this(set IMethod GetAccessor, set IMethod SetAccessor,
                          set IExpression Caller, set [IExpression] IndexerArguments);

        /// <summary>
        /// Gets the property variable's 'get' accessor.
        /// </summary>
        public IMethod GetAccessor { const get; private set; }

        /// <summary>
        /// Gets the property variable's 'set' accessor.
        /// </summary>
        public IMethod SetAccessor { const get; private set; }

        /// <summary>
        /// Gets the instance the property operates on.
        /// </summary>
        public IExpression Caller { const get; private set; }

        /// <summary>
        /// Gets the property's indexer arguments.
        /// </summary>
        public [IExpression] IndexerArguments { const get; private set; }

        public void AcceptPredicate(INodeVisitor Visitor)
        {
            if (Caller != null)
                Visitor.Visit(Caller);
            Visitor.VisitAll(IndexerArguments);
        }

        public IType Type
        {
            const get
            {
                if (GetAccessor == null)
                    return SetAccessor.GetParameters()[0].ParameterType;
                else
                    return GetAccessor.ReturnType;
            }
        }

        public IExpression CreateGetExpression()
        {
            return new PropertyGetExpression(this);
        }

        public IStatement CreateSetStatement(IExpression Value)
        {
        	var args = Enumerable.Concat<IExpression>(IndexerArguments, new IExpression[] { Value });
        	return new ExpressionStatement(new InvocationExpression(SetAccessor, Caller, args));
        }

        public IStatement CreateReleaseStatement()
        {
            return EmptyStatement;
        }
    }
}
