using System;
using System.Collections.Generic;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;

namespace Flame.Compiler.Variables
{
    public class ThisVariable : IUnmanagedVariable
    {
        public const this(set IType DeclaringType);

        public IType DeclaringType { const get; private set; }

        private IType exprType;
        public IType Type : IVariable.Type
        {
            const get
            {
                if (exprType == null)
            	{
            		exprType = ThisVariable.GetThisType(DeclaringType);
            	}
            	return exprType;
            }
        }

        public const IExpression CreateAddressOfExpression() : IUnmanagedVariable.CreateAddressOfExpression
        {
            return new ThisAddressOfExpression(Type.MakePointerType(PointerKind.ReferencePointer));
        }

        public const IExpression CreateGetExpression() : IVariable.CreateGetExpression
        {
        	return new ThisGetExpression(Type);
        }

        public const IStatement CreateSetStatement(IExpression Value) : IVariable.CreateSetStatement
        {
        	return new ThisSetStatement(Value);
        }

        public const IStatement CreateReleaseStatement() : IVariable.CreateReleaseStatement
        {
            //return new ThisReleaseStatement(this);
            return new EmptyStatement();
        }

        public override const int GetHashCode()
        {
            return 0;
        }
        public override const bool Equals(object Other)
        {
            return Other is ThisVariable;
        }

        public static const IType GetThisType(IType CurrentType)
		{
			var finalType = CurrentType;
			if (finalType.IsGeneric && finalType.IsGenericDeclaration)
			{
				finalType = finalType.MakeGenericType((IEnumerable<IType>)finalType.GetGenericParameters());
			}
			if (finalType.IsValueType && !finalType.IsPointer)
			{
				finalType = finalType.MakePointerType(PointerKind.ReferencePointer);
			}
			return finalType;
		}

		/// <summary>
		/// Gets a boolean value that indicates whether the given variable refers directly or indirectly to a ThisVariable reference.
		/// </summary>
		public static const bool IsThisVariable(IVariable Variable)
		{
			if (Variable is ThisVariable) return true;
			else if (Variable is AtAddressVariable)
			{
				if (((AtAddressVariable)Variable).Pointer is ThisGetExpression) return true;
			}
			else return false;
		}
    }
}
