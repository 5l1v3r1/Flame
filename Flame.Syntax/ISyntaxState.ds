using System;
using System.Collections.Generic;
using Flame.Compiler.Variables;
using Flame.Compiler;
using Pixie;

namespace Flame.Syntax
{
    public interface ISyntaxState : IVariableProvider
    {
        IType CurrentType { const get; }
        IType DeclaringType { const get; }
        IType ReturnType { const get; }
        IScopedBinder Binder { const get; }
        IMemberProvider MemberProvider { const get; }
        ICompilerLog Log { const get; }
        IConverter<IType, string> TypeNamer { const get; }
        BlockTag Tag { const get; }

        IVariable DeclareVariable(string Name, IVariable Variable, SourceLocation Location);
        const DeclaredVariable GetDeclaredVariable(string Name);

    	void PushScope();
        void PushScope(BlockTag Tag);
    	IStatement PopScope();
    }

    public struct DeclaredVariable
    {
        public const this(set IVariable Variable, set SourceLocation Location);

        public IVariable Variable { const get; private set; }
        public SourceLocation Location { const get; private set; }
    }

    public static class RedefinitionHelpers
    {
        public static const IMarkupNode CreateNeutralDiagnosticsNode(string Title, SourceLocation Location)
        {
            var oldSrc = Location.CreateSourceNode();
            var neutralOldSrc = new MarkupNode("neutral-diagnostics", new IMarkupNode[] { oldSrc });
            var oldTitle = new MarkupNode(NodeConstants.TextNodeType, Title);
            var oldMessage = Location.CreateLineNumberNode(NodeConstants.TextNodeType);

            return new MarkupNode(NodeConstants.RemarksNodeType, new IMarkupNode[]
            {
                oldTitle,
                oldMessage,
                neutralOldSrc
            });
        }

        public static const IMarkupNode AppendDiagnosticsRemark(IMarkupNode Node, string Title, SourceLocation Location)
        {
            if (Location == null)
            {
                return Node;
            }

            var nextRemark = CreateNeutralDiagnosticsNode(Title, Location);

            return new MarkupNode("entry", new IMarkupNode[]
            {
                Node,
                nextRemark
            });
        }

        public static const IMarkupNode CreateRedefinitionMessageNode(IMarkupNode Message,
            SourceLocation NewDefinition, SourceLocation OldDefinition)
        {
            var firstDiag = NewDefinition.CreateDiagnosticsNode();

            var firstEntry = new MarkupNode("entry", new IMarkupNode[]
            {
                Message,
                firstDiag
            });

            return AppendDiagnosticsRemark(firstEntry, "Previous definition: ", OldDefinition);
        }

        public static const IMarkupNode CreateRedefinitionMessageNode(string Message,
            SourceLocation NewDefinition, SourceLocation OldDefinition)
        {
            var firstMessage = new MarkupNode(NodeConstants.TextNodeType, Message);
            return CreateRedefinitionMessageNode(firstMessage, NewDefinition, OldDefinition);
        }

        public static const IMarkupNode CreateRedefinitionNode(string Name,
            SourceLocation NewDefinition, SourceLocation OldDefinition)
        {
            return CreateRedefinitionMessageNode("'" + Name + "' is defined more than once.", NewDefinition, OldDefinition);
        }
    }
}
