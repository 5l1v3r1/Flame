using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp;
using Flame.DSharp.Build;
using Flame.DSharp.Lexer;

namespace Flame.Syntax.DSharp
{
    public class SyntaxState : ISyntaxState
    {
        public const this(set IMethod Method, set IScopedBinder Binder, set ICompilerLog Log, set IConverter<IType, string> TypeNamer)
        {
            this.MemberProvider = new MemberProvider(Binder);
            this.declaredVariables = new Stack<Dictionary<string, DeclaredVariable>>();
            PushScope();
        }
        public const this(set IMethod Method, IBinder OuterBinder, set ICompilerLog Log, set IConverter<IType, string> TypeNamer)
        {
            this.Binder = new ScopedBinder(OuterBinder, this);
            this.MemberProvider = new MemberProvider(Binder);
            this.declaredVariables = new Stack<Dictionary<string, DeclaredVariable>>();
            PushScope();
        }
        public const this(set IMethod Method, IBinder OuterBinder, set ICompilerLog Log, set IMemberProvider MemberProvider, set IConverter<IType, string> TypeNamer)
        {
            this.Binder = new ScopedBinder(OuterBinder, this);
            this.declaredVariables = new Stack<Dictionary<string, DeclaredVariable>>();
            PushScope();
        }

        public IType CurrentType
        {
            const get
            {
                var declType = Method.DeclaringType;
                if (declType.IsGeneric && declType.IsGenericDeclaration)
                {
                	return declType.MakeGenericType(declType.GetGenericParameters());
                }
                else
                {
                	return declType;
                }
            }
        }

        public ICompilerLog Log { const get; private set; }
        public IScopedBinder Binder { const get; private set; }
        public IConverter<IType, string> TypeNamer { const get; private set; }
        public IMemberProvider MemberProvider { const get; private set; }

        private Stack<Dictionary<string, DeclaredVariable>> declaredVariables;
        public Dictionary<string, DeclaredVariable> Locals
        {
            const get
            {
            	Dictionary<string, DeclaredVariable> dict = new Dictionary<string, DeclaredVariable>();
            	foreach (var map in declaredVariables)
            	foreach (var item in map)
            	{
            		dict[item.Key] = item.Value;
            	}
                return dict;
            }
        }

        public IMethod Method { const get; private set; }

		private IVariableProvider paramProvider;
        public IVariableProvider ParameterProvider
        {
            const get
            {
            	if (paramProvider == null)
            	{
            		paramProvider = new MethodParameterProvider(Method);
            	}
                return paramProvider;
            }
        }
        public IType ReturnType
        {
            const get
            {
                return Method.ReturnType;
            }
        }
        public IType DeclaringType
        {
            const get
            {
                return Method.DeclaringType;
            }
        }
        public IVariable DeclareVariable(string Name, IVariable Variable, SourceLocation Location)
        {
            var localDecls = declaredVariables.Peek();
            if (localDecls.ContainsKey(Name))
            {
                var body = RedefinitionHelpers.CreateRedefinitionNode(Name, Location, localDecls[Name].Location);
                Log.LogError(new LogEntry("Variable redefinition", body));
            }
            else if (Log.ShowShadowWarnings && VariableExists(Name))
            {
                var node = RedefinitionHelpers.CreateRedefinitionMessageNode("Variable '" + Name + "' is shadowed. " + Warnings.GetWarningNameMessage(Warnings.Shadow),
                    Location, this.GetDeclarationLocation(Name));
                Log.LogWarning(new LogEntry("Variable shadowed", node));
            }
            localDecls[Name] = new DeclaredVariable(Variable, Location);
            return Variable;
        }
        public const IVariable GetVariable(string Name)
        {
            return GetDeclaredVariable(Name).Variable;
        }
        public const DeclaredVariable GetDeclaredVariable(string Name)
        {
            var localDict = Locals;
            if (localDict.ContainsKey(Name))
            {
                return localDict[Name];
            }
            else if (ParameterProvider != null && ParameterProvider.VariableExists(Name))
            {
                return new DeclaredVariable(ParameterProvider.GetVariable(Name), null);
            }
            return default(DeclaredVariable);
        }
        public const bool VariableExists(string Name)
        {
            var localDict = Locals;
            if (localDict.ContainsKey(Name))
            {
                return true;
            }
            else
            {
                return ParameterProvider != null && ParameterProvider.VariableExists(Name);
            }
        }

        public void PushScope()
        {
            Binder = Binder.PushScope();
            this.declaredVariables.Push(new Dictionary<string, DeclaredVariable>());
        }

        public IStatement PopScope()
        {
            List<IStatement> statements = new List<IStatement>();
            var scopeVars = declaredVariables.Pop();
            foreach (var item in scopeVars)
            {
                statements.Add(item.Value.Variable.CreateReleaseStatement());
            }

            Binder = Binder.PopScope();

            return new BlockStatement(statements.ToArray());
        }
    }
}
