using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.DSharp;
using Flame.DSharp.Build;
using Flame.DSharp.Lexer;

namespace Flame.Syntax.DSharp
{
    public class PropertySyntax : MemberSyntax, IMemberSyntax<IProperty>
    {
        public const this(set ISignatureSyntax Signature, set IEnumerable<IAccessorSyntax> Accessors, set IEnumerable<IMemberSyntax<IParameter>> IndexerParameters, set IEnumerable<ITypeMemberAccessSyntax> ImplementedProperties);

        public IEnumerable<IAccessorSyntax> Accessors { const get; private set; }
        public IEnumerable<IMemberSyntax<IParameter>> IndexerParameters { const get; private set; }
        public IEnumerable<ITypeMemberAccessSyntax> ImplementedProperties { const get; private set; }

        public bool IsFieldProperty
        {
            const get
            {
            	if (Signature.ModifierTokens.IsAbstract)
            	{
            		return false;
            	}
            	else
            	{
            		foreach (var item in Accessors)
            		{
            			if (!item.IsEmpty)
            			{
            				return false;
            			}
            		}
            	}
                return true;
            }
        }

        protected override void AddExtraLeadingTrivia(List<Token> tokens)
        {
            foreach (var item in IndexerParameters)
        		tokens.AddRange(item.GetAllTrivia());
        	foreach (var item in ImplementedProperties)
        		tokens.AddRange(item.GetAllTrivia());
        	/*foreach (var item in Accessors)
        		tokens.AddRange(item.GetAllTrivia());*/
        	// Do not include trivia from accessors. Otherwise, descriptions would be copied from the accessor level to the property level.
        }

        #region GetCode

        public override CodeBuilder GetCode()
        {
            var cb = Signature.GetCode();
            var indexerArgs = Enumerable.ToArray<IMemberSyntax<IParameter>>(IndexerParameters);
            if (indexerArgs.Length > 0)
            {
                cb.Append("[");
                for (int i = 0; i < indexerArgs.Length; i++)
                {
                    if (i != 0)
                    {
                        cb.Append(",");
                    }
                    cb.Append(indexerArgs[i].GetCode());
                }
                cb.Append("]");
            }
            var implProperties = Enumerable.ToArray<ITypeMemberAccessSyntax>(ImplementedProperties);
            if (implProperties.Length > 0)
            {
                cb.Append(":");
                for (int i = 0; i < implProperties.Length; i++)
                {
                    if (i != 0)
                    {
                        cb.Append(",");
                    }
                    cb.Append(implProperties[i].GetCode());
                }
            }
            cb.AddLine("{");
            cb.IncreaseIndentation();
            foreach (var item in Accessors)
            {
                cb.AddCodeBuilder(item.GetCode());
            }
            cb.DecreaseIndentation();
            cb.AddLine("}");
            return cb;
        }

        #endregion

        #region CreateMember

        public IProperty CreateMember(ISyntaxState State)
        {
            return new SyntaxProperty(this, State.DeclaringType, State.Binder,
                State.Log, State.MemberProvider, State.TypeNamer);
        }

        #endregion

        public bool IsExtensionMember
        {
            get
            {
                var firstIndexerParam = Enumerable.FirstOrDefault<IMemberSyntax<IParameter>>(IndexerParameters);
                if (firstIndexerParam == null)
                    return false;
                return firstIndexerParam.IsExtensionMember;
            }
        }

        public bool IsSingletonMember
        {
        	const get
        	{
        		if (Signature.ModifierTokens.IsStatic)
				{
					return Signature.ModifierTokens.GetAccess() != AccessModifier.Private;
				}
				else
				{
					return false;
				}
        	}
        }
    }
}
