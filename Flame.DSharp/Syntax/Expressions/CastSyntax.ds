using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.DSharp.Lexer;
using Flame.Compiler;
using Flame.Compiler.Expressions;

namespace Flame.Syntax.DSharp
{
    public class CastSyntax : IExpressionSyntax, ITokenNode, ISourceSyntax
    {
        public const this(set ITypeSyntax TargetType, set IExpressionSyntax Expression)
        {
            this.OpeningToken = new Token(TokenType.RParen, "(");
            this.ClosingToken = new Token(TokenType.LParen, ")");
        }
        public const this(set Token OpeningToken, set ITypeSyntax TargetType, set Token ClosingToken, set IExpressionSyntax Expression);

        public Token OpeningToken { const get; private set; }
        public ITypeSyntax TargetType { const get; private set; }
        public Token ClosingToken { const get; private set; }
        public IExpressionSyntax Expression { const get; private set; }
        
        public SourceLocation Location
        {
        	const get return CastLocation.Concat(Expression.GetSourceLocation());
        }
        
        public SourceLocation CastLocation
        {
        	const get return OpeningToken.Location.Concat(TargetType.GetSourceLocation()).Concat(ClosingToken.Location);
        }
        
        public IReadOnlyList<Token> Tokens
        {
        	const get
        	{
        		var tks = new List<Token>();
        		tks.Add(OpeningToken);
				tks.AddRange(TargetType.GetTokens());
				tks.Add(ClosingToken);
				tks.AddRange(Expression.GetTokens());
				return tks;
        	}
        }

        public const IExpression CreateExpression(ISyntaxState State)
        {
        	var expr = Expression.CreateVerifiedExpression(State);
        	var type = TargetType.CreateVerifiedType(State);
        	var exprType = expr.Type;
        	if (exprType.IsBit && type.IsBit)
        	{
	       		if (exprType.GetPrimitiveMagnitude() > type.GetPrimitiveMagnitude())
	       		{
	       			State.Log.LogWarning(new LogEntry("Bit type downcast", "'" + this.GetCode().ToString() + "' implies a downcast of bit types (" + exprType.Name + " to " + type.Name + "). This could lead to an arbitrary loss of information.", CastLocation));	
	       		}
	       	}
	       	else if (exprType.Equals(type))
	       	{
	       		State.Log.LogWarning(new LogEntry("Meaningless cast", "'" + this.GetCode().ToString() + "' does not change the type of '" + Expression.GetCode().ToString() + "'.", CastLocation));
	       	}
            return new ConversionExpression(expr, type);
        }

        public override const string ToString()
        {
            return GetCode().ToString();
        }

        public const CodeBuilder GetCode()
        {
            var cb = new CodeBuilder();
            cb.Append(OpeningToken.ToString());
            cb.Append(TargetType.GetCode());
            cb.Append(ClosingToken.ToString());
            cb.Append(Expression.GetCode());
            return cb;
        }
        
        #region Static
        
        public static const IExpression CreateImplicitCast(ISyntaxState State, IExpressionSyntax Value, IType TargetType)
        {
        	var expr = Value.CreateVerifiedExpression(State);
        	return CastSyntax.CreateImplicitCast(State, expr, Value, TargetType);
        }
        
        public static const IExpression CreateImplicitCast(ISyntaxState State, IExpression expr, ISyntaxNode Value, IType TargetType)
        {
        	var valType = expr.Type;
        	if (!ConversionExpression.RequiresConversion(valType, TargetType))
        	{
        		return expr;
        	}
        	else if (CastSyntax.UseImplicitCast(State, valType, TargetType))
        	{
        		return new ConversionExpression(expr, TargetType);
        	}
        	else
        	{
        		State.Log.LogError(new LogEntry("Cast error", "The expression '" + Value.GetCode().ToString() + "' of type '" + valType.FullName + "' could not be cast implicitly to '" + TargetType.FullName + "'", Value.GetSourceLocation()));
        		return new ConversionExpression(expr, TargetType);
        	}
        }
        
        public static const bool UseImplicitCast(ISyntaxState State, IType SourceType, IType TargetType)
        {
        	if (SourceType.Is(TargetType))
        	{
        		return true;
        	}
        	else if (SourceType.IsVector && TargetType.IsArray)
        	{
        		return SourceType.AsContainerType().GetElementType().Is(TargetType.AsContainerType().GetElementType()) && SourceType.AsContainerType().AsVectorType().GetDimensions().Length == TargetType.AsContainerType().AsArrayType().ArrayRank;
        	}
        	if (SourceType.IsPointer && TargetType.IsPointer)
        	{
        		var firstPtrType = SourceType.AsContainerType().AsPointerType();
                var secondPtrType = TargetType.AsContainerType().AsPointerType();
                return firstPtrType.PointerKind.Equals(PointerKind.ReferencePointer) && secondPtrType.PointerKind.Equals(PointerKind.TransientPointer);
        	}
        	if (SourceType.IsPrimitive && TargetType.IsPrimitive)
        	{
        		if (SourceType.GetPrimitiveMagnitude() <= TargetType.GetPrimitiveMagnitude())
        		{
        			if (SourceType.IsSignedInteger)
        			{
					 	return TargetType.IsSignedInteger || TargetType.IsFloatingPoint;
					}
        			else if (SourceType.IsUnsignedInteger)
					{
						if (TargetType.IsUnsignedInteger || TargetType.IsFloatingPoint)
        					return true;
        				else if (TargetType.IsSignedInteger)
        					return SourceType.GetPrimitiveMagnitude() < TargetType.GetPrimitiveMagnitude();
        				else
        					return false;
        			}
        			else if (SourceType.IsBit && TargetType.IsBit)
        			{
        				return true;
        			}
        			else if (SourceType.IsFloatingPoint && TargetType.IsFloatingPoint)
        			{
        				return true;
        			}
        			else
        			{
        				return false;
        			}
        		}
        	}
        	else if ((SourceType.IsArray || SourceType.IsVector) && TargetType.GetGenericDeclaration().Equals(State.Environment.EnumerableType))
        	{
        		if (!TargetType.IsGeneric)
        			return true;
        		return SourceType.AsContainerType().GetElementType().Is(Enumerable.First<IType>(TargetType.GetGenericArguments()));
        	}
        	return false;
        }
        
        #endregion
    }
}