using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.DSharp.Parser;

namespace Flame.Syntax.DSharp
{
    public abstract class MemberAccessSyntaxBase : VariableSyntaxBase, ITypeMemberAccessSyntax, ISourceSyntax
    {
    	public const this();
        public const this(set IExpressionSyntax Target, set Token Operator, set Token Member);

        public IExpressionSyntax Target { const get; protected set; }
        public Token Operator { const get; protected set; }
        public Token Member { const get; protected set; }
        
        public SourceLocation Location
        {
        	const get return Target.GetSourceLocation().Concat(Operator.Location).Concat(Member.Location);
        }

        public abstract IVariable GetCallerVariable(ISyntaxState State);

        public override string ToString()
        {
            return this.GetCode().ToString();
        }

        public override CodeBuilder GetCode()
        {
            var cb = Target.GetCode();
            cb.Append(Operator.ToString());
            cb.Append(Member.ToString());
            return cb;
        }

        #region CreateAddressToValueExpression

        public static IExpression CreateAddressToValueExpression(IVariable Variable)
        {
            IExpression callerExpr;
            if (Variable is IUnmanagedVariable)
            {
                callerExpr = ((IUnmanagedVariable)Variable).CreateAddressOfExpression();
            }
            else
            {
                // This is hacky, and slower on .Net (tests on .Net 4.5 showed unbox/box takes about 1.1x as much time as the other approach). In addition, boxing/unboxing may cause the gc to kick in.
                // The upside of this approach is that the temporary variable will be released by the gc.
                // Temporary variables are released after they are used, though.
                /*callerExpr = new Expressions.ConversionExpression(
                    new Expressions.ConversionExpression(Caller.CreateGetExpression(), State.Binder.RootType), 
                    property.DeclaringType.MakePointerType(PointerKind.ReferencePointer));*/

                var placeholder = new LateBoundVariable(Variable.Type);

                callerExpr = new Expressions.InitializedExpression(placeholder.CreateSetStatement(Variable.CreateGetExpression()),
                    placeholder.CreateAddressOfExpression(),
                    placeholder.CreateReleaseStatement());
                // This may not be the best place to release the temporary variable. Ideally, it would be released after usage.
            }
            return callerExpr;
        }

        #endregion

        #region CreateCallerExpression

        public static IExpression CreateCallerExpression(ISyntaxState State, IVariable Caller, ITypeMember Member)
        {
            IExpression callerExpr;
            if (Member.IsStatic)
            {
                callerExpr = null;
            }
            else
            {
                callerExpr = CreateInstanceCallerExpression(State, Caller, Member.DeclaringType);
            }
            return callerExpr;
        }

        #endregion

        #region CreateInstanceCallerExpression

        public static IExpression CreateInstanceCallerExpression(ISyntaxState State, IVariable Caller, IType CallerType)
        {
            IExpression callerExpr;
            if (CallerType.IsValueType && !Caller.Type.IsPointer)
            {
                callerExpr = CreateAddressToValueExpression(Caller);
            }
            else if (CallerType.IsAssociatedSingletonOf(Caller.Type))
            {
            	callerExpr = (SingletonVariable.GetSingletonVariable(CallerType, State.CurrentType)).CreateGetExpression();
            }
            else
            {
                callerExpr = Caller.CreateGetExpression();
            }
            return callerExpr;
        }

        #endregion

        #region CreateExtensionCallerExpression

        public static IExpression CreateExtensionCallerExpression(IVariable Caller, IType CallerType)
        {
            if (CallerType.IsPointer)
            	if (CallerType.AsContainerType().GetElementType().IsValueType && !Caller.Type.IsPointer)
                	return CreateAddressToValueExpression(Caller);
            
            return Caller.CreateGetExpression();
        }

        #endregion

        public static IVariable CreateVariable(IVariable Caller, IType CallerType, string MemberName, ISyntaxState State)
        {
        	var members = State.MemberProvider.GetMembers(CallerType, MemberName);
        	var possibleFields = Enumerable.OfType<IField>(members);
            var field = possibleFields.GetField(MemberName);
            if (field != null)
            {
            	if (field.IsStatic)
                	return new FieldVariable(field, null);
                else if (CallerType.IsValueType)
                	return new ValueTypeFieldVariable(field, Caller);
                else
                	return new FieldVariable(field, CreateCallerExpression(State, Caller, field));
            }
            List<IProperty> properties = new List<IProperty>();
            var possibleProperties = Enumerable.OfType<IProperty>(members);
            bool callerNull = Caller == null;
            bool singletonCaller = CallerType.IsSingleton && Caller != null;
            foreach (var item in possibleProperties)
            {
            	if (item.IsStatic)
            	{
            		if (callerNull || singletonCaller || item.IsExtension)
            			properties.Add(item);
            	}
            	else if (!callerNull)
            	{
            		properties.Add(item);
            	}
            }
            
            IType propertyTargetType;
            if (Caller == null)
            	propertyTargetType = null;
            else
            	propertyTargetType = Caller.Type;
            	
            var property = Enumerable.FirstOrDefault<IProperty>(properties.GetBestProperties(propertyTargetType, new IType[0]));
            if (property != null)
            {
                IExpression callerExpr;
                if (Caller != null && property.IsExtension)
                {
                    callerExpr = CreateExtensionCallerExpression(Caller, Enumerable.First<IParameter>(property.GetIndexerParameters()).ParameterType);
                    return new PropertyVariable(property, null, new IExpression[] { callerExpr });
                }
                else
                {
                    callerExpr = CreateCallerExpression(State, Caller, property);
                    return new PropertyVariable(property, callerExpr);
                }
            }
            else if (singletonCaller)
            {
            	property = Enumerable.FirstOrDefault<IProperty>(properties.GetBestProperties(null, new IType[0]));
            	if (property != null)
            	{
            		return new PropertyVariable(property, null);
            	}
            }
            
            return null;
        }
        
        private static const IType BindType(ISyntaxNode Node, ISyntaxState State)
        {
        	// Tokenize and parse
        	var tokenStream = new TokenizerStream(Node.GetCode().ToString(), null);
        	var parser = new DSharpSyntaxParser(State.Log);
        	var tSyntax = parser.ToTypeSyntax(tokenStream);
        	if (tSyntax == null)
        		return null;
        	else 
        		return tSyntax.CreateType(State);
        }
        
        private const IType BindType(ISyntaxState State)
        {
        	return BindType(Target, State);
        }
        
        public static const IVariable CreateSingletonVariable(ISyntaxState State, IType Type)
        {
        	if (Type == null)
        	{
        		return null;
        	}
        	else if (Type.IsSingleton)
            {
            	return SingletonVariable.GetSingletonVariable(Type, State.CurrentType);
            }
            else
            {
            	var associatedSingleton = Type.GetAssociatedSingleton();
            	if (associatedSingleton != null)
            		return SingletonVariable.GetSingletonVariable(associatedSingleton, State.CurrentType);
            	else return null;
            }
        }

        public override IVariable CreateVariable(ISyntaxState State)
        {
            var variable = GetCallerVariable(State);

            IType exprType;
            if (variable == null)
            {
                exprType = BindType(State);
                variable = CreateSingletonVariable(State, exprType);
            }
            else
            {
                exprType = variable.Type;
            }
            if (exprType == null)
            {
            	// Actually, don't log this. Other expressions may be counting on this returning null
            	// State.Log.LogError("'" + Target.GetCode().ToString() + "' could not be resolved as a variable, expression or type.");
                return null;
            }

            string name = Member.TokenValue;

            var result = CreateVariable(variable, exprType, name, State);
            
            if (result == null) // Try singleton
            {
            	var singletonType = BindType(this, State);
            	if (singletonType != null)
            		return CreateSingletonVariable(State, singletonType);
            }
            
            /*if (result == null) // Actually, don't log this. Other expressions may be counting on this returning null
            {
            	State.Log.LogError(new LogEntry("Member not found error", "The member '" + Member.TokenValue + "' in expression '" + this.GetCode().ToString() + "' could not be resolved"));
            }*/
            
            return result;
        }

        public [ITypeMember] GetAccessedMembers(ISyntaxState State)
        {
            var expr = this.GetCallerExpression(State);

            IType parentType;
            if (expr == null)
            {
                parentType = BindType(State);
            }
            else
            {
                parentType = expr.Type;
            }
            
            if (parentType == null)
            {
            	if (Target is MemberAccessSyntaxBase) // Try to go the extra mile and find some type info.
            	{
            		var innerTarget = ((MemberAccessSyntaxBase)Target).Target;
            		var innerCallerExpr = innerTarget.CreateExpression(State);
            		while (innerTarget != null && innerCallerExpr == null)
            		{
            			if (innerTarget is MemberAccessSyntaxBase)
            			{
            				innerTarget = ((MemberAccessSyntaxBase)innerTarget).Target;
            				innerCallerExpr = innerTarget.CreateExpression(State);
            			}
            			else
            			{
            				innerTarget = null;
            				innerCallerExpr = null;
            			}
            		}
            		if (innerCallerExpr == null)
            		{
            			State.Log.LogError(new LogEntry("Member access error", "'" + Target.GetCode().ToString() + "' in member access syntax '" + this.GetCode().ToString() + "' could not be resolved as a variable, expression or type, and '" + innerTarget.GetCode().ToString() + "' could not be resolved, either", Location));
            		}
            		else
            		{
            			State.Log.LogError(new LogEntry("Member access error", "'" + Target.GetCode().ToString() + "' in member access syntax '" + this.GetCode().ToString() + "' could not be resolved as a variable, expression or type, though '" + innerTarget.GetCode().ToString() + "' was resolved as an expression of type '" + innerCallerExpr.Type.FullName + "'", Location));
            		}
            	}
            	else
            	{
            		State.Log.LogError(new LogEntry("Member access error", "'" + Target.GetCode().ToString() + "' in member access syntax '" + this.GetCode().ToString() + "' could not be resolved as a variable, expression or type", Location));
            	}
            	return Enumerable.Empty<ITypeMember>(); // Keep it civilized by returning an empty enumerable instead of null
            }

            string name = Member.TokenValue;

            return State.MemberProvider.GetMembers(parentType, name);
        }
    }
}