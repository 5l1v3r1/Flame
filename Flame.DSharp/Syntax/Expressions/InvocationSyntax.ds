using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.DSharp.Build;
using Pixie;

namespace Flame.Syntax.DSharp
{
    public class InvocationSyntax : IInvocationSyntax, ISourceSyntax
    {
        public const this(set ITypeMemberAccessSyntax Method, set [IExpressionSyntax] Arguments);

        public ITypeMemberAccessSyntax Method { const get; private set; }
        public [IExpressionSyntax] Arguments { const get; private set; }

        public SourceLocation Location
        {
        	const get
        	{
        		var result = Method.GetSourceLocation();
        		foreach (var item in Arguments)
        		{
        			result = result.Concat(item.GetSourceLocation());
        		}
        		return result;
        	}
        }

        public static const IExpression CreateInvocationExpression(ISyntaxState State, IMethod Method, IVariable Caller)
        {
            return CreateInvocationExpression(State, Method, Caller, (IEnumerable<IExpression>)new IExpression[0]);
        }

        public static const IExpression CreateInvocationExpression(ISyntaxState State, IMethod Method, IVariable Caller, IEnumerable<IExpression> Arguments)
        {
            IExpression callerExpr;
            if (Method.IsExtension && Caller != null)
            {
                callerExpr = null;
                var callerInst = MemberAccessSyntaxBase.CreateExtensionCallerExpression(Caller, Enumerable.FirstOrDefault<IParameter>(Method.GetParameters()).ParameterType);
                Arguments = Enumerable.ToArray<IExpression>(Enumerable.Concat<IExpression>((IEnumerable<IExpression>)new IExpression[] { callerInst }, Arguments));
            }
            else
            {
                callerExpr = MemberAccessSyntaxBase.CreateCallerExpression(State, Caller, Method);
            }

            return new InvocationExpression(Method, callerExpr, Enumerable.ToArray<IExpression>(Arguments));
        }

        public static const IExpression CastExtensionCallerExpression(ISyntaxState State, IVariable callerInst, ISyntaxNode MethodNode, IType TargetType)
        {
        	var valType = callerInst.Type;
	    	if (valType.Is(TargetType))
	     	{
	        	return callerInst.CreateGetExpression();
	    	}
	    	else if (TargetType.IsPointer && !valType.IsPointer)
	      	{
	         	if (TargetType.AsContainerType().GetElementType().IsValueType)
	       			return MemberAccessSyntaxBase.CreateAddressToValueExpression(callerInst);
	     	}
	       	if (CastSyntax.UseImplicitCast(State, valType, TargetType))
	       	{
	        	return new ConversionExpression(callerInst.CreateGetExpression(), TargetType);
	      	}

	        State.Log.LogError(new LogEntry("Cast error", "The caller of '" + MethodNode.GetCode().ToString() + "' of type '" + valType.FullName + "' could not be cast implicitly to '" + TargetType.FullName + "'", MethodNode.GetSourceLocation()));
	        return new ConversionExpression(callerInst.CreateGetExpression(), TargetType);
        }

        public static const IExpression CreateInvocationExpression(ISyntaxState State, IMethod Method, IVariable Caller, ISyntaxNode MethodNode, IEnumerable<IExpression> Arguments, IEnumerable<IExpressionSyntax> Nodes)
        {
        	IEnumerable<IParameter> methodParameters = Method.GetParameters();
        	List<IExpression> callArgs = new List<IExpression>();
            IExpression callerExpr;
            if (Method.IsExtension && Caller != null)
            {
                callerExpr = null;
                var targetType = Enumerable.FirstOrDefault<IParameter>(methodParameters).ParameterType;
                var callerInst = InvocationSyntax.CastExtensionCallerExpression(State, Caller, MethodNode, targetType);
                callArgs.Add(callerInst);
                methodParameters = Enumerable.Skip<IParameter>(methodParameters, 1);
            }
            else
            {
                callerExpr = MemberAccessSyntaxBase.CreateCallerExpression(State, Caller, Method);
            }
            foreach (var item in Arguments, var node in Nodes, var parameter in methodParameters)
            {
            	callArgs.Add(CastSyntax.CreateImplicitCast(State, item, node, parameter.ParameterType));
            }

            return new InvocationExpression(Method, callerExpr, callArgs.ToArray());
        }

        public static const void AppendCallSignature(CodeBuilder SignatureBuilder, IType[] argTypes, IConverter<IType, string> TypeNamer)
        {
    	    SignatureBuilder.Append('(');
        	bool first = true;
        	foreach (var item in argTypes)
        	{
        		if (first)
        			first = false;
        		else
        			SignatureBuilder.Append(", ");

        		if (item == null) SignatureBuilder.Append("<unresolved type>");
        		else SignatureBuilder.Append(TypeNamer.Convert(item));
        	}
        	SignatureBuilder.Append(')');
        }

        public static const IMarkupNode CreateSignatureDiff(IMethod Method, IType[] ArgumentTypes, IConverter<IType, string> TypeNamer)
        {
            var nodes = new List<IMarkupNode>();
            if (Method.IsStatic)
            {
                nodes.Add(TypeDiffComparer.ToTextNode("static "));
            }
            if (Method.IsConstructor)
            {
                nodes.Add(TypeDiffComparer.ToTextNode("new "));
                nodes.Add(TypeDiffComparer.ToTextNode(TypeNamer.Convert(Method.DeclaringType)));
            }
            else
            {
                var retType = Method.ReturnType;
                if (retType == null)
                {
                    nodes.Add(TypeDiffComparer.ToTextNode("void"));
                }
                else
                {
                    nodes.Add(TypeDiffComparer.ToTextNode(TypeNamer.Convert(Method.ReturnType)));
                }
                nodes.Add(TypeDiffComparer.ToTextNode(" "));
                nodes.Add(TypeDiffComparer.ToTextNode(Method.FullName));
            }
            var methodDiffBuilder = new MethodDiffComparer(TypeNamer);
            nodes.Add(methodDiffBuilder.CompareArguments(ArgumentTypes, Method));
            return new MarkupNode("node", nodes);
        }

        public static const CodeBuilder CreateExpectedSignatureDescription(IType CallerType, CodeBuilder CallerCode, IType[] ArgumentTypes, bool AllowStatic, IConverter<IType, string> TypeNamer)
        {
            CodeBuilder expectedSignature = new CodeBuilder();
        	expectedSignature.Append("'");
        	if (CallerType == null && AllowStatic)
        		expectedSignature.Append("static ");
			expectedSignature.Append(CallerCode);
        	AppendCallSignature(expectedSignature, ArgumentTypes, TypeNamer);
        	expectedSignature.Append("'");
        	if (CallerType != null)
        	{
            	expectedSignature.Append(" (where the caller expression is of type '");
            	expectedSignature.Append(TypeNamer.Convert(CallerType));
            	expectedSignature.Append("')");
        	}
        	return expectedSignature;
        }

        public const IExpression CreateExpression(ISyntaxState State)
        {
            var argExprs = Arguments.CreateVerifiedExpressions(State);
            var argTypes = argExprs.Types;

            var callerVar = Method.GetCallerVariable(State);
            IType callerType;
            if (callerVar == null)
            	callerType = null;
            else
            	callerType = callerVar.Type;

            var matches = Method.GetAccessedMembers(State);

            IMethod method = Enumerable.OfType<IMethod>(matches).GetBestMethod(callerType, argTypes);

            if (method == null && ThisVariable.IsThisVariable(callerVar))
            {
            	// Try for static methods
            	method = Enumerable.OfType<IMethod>(matches).GetBestMethod(null, argTypes);
            	if (method == null) // Try for singleton methods
            	{
            		var associatedSingleton = callerType.GetAssociatedSingleton();
            		method = Enumerable.OfType<IMethod>(matches).GetBestMethod(associatedSingleton, argTypes);
            		if (method != null)
            			callerVar = new SingletonVariable(associatedSingleton);
            	}
            }
            if (method == null)
            {
                var namer = new DSharpTypeNamer();
            	CodeBuilder expectedSignature = CreateExpectedSignatureDescription(callerType, Method.GetCode(), argTypes, true, namer);

            	var failedMatches = Enumerable.ToArray<IMethod>(Enumerable.OfType<IMethod>(matches));
            	if (failedMatches.Length > 0)
            	{
            		var failedMatchesList = new List<IMarkupNode>();
            		foreach (var item in failedMatches)
            		{
                        failedMatchesList.Add(CreateSignatureDiff(item, argTypes, namer));
            		}
                    var explanationNode = new MarkupNode(NodeConstants.TextNodeType,
                        "Method call '" + this.GetCode().ToString() + "' could not be resolved. Expected signature compatible with " + expectedSignature.ToString() + ". Incompatible or ambiguous matches:");
                    var failedMatchesNode = new MarkupNode("list", failedMatchesList);
                    var messageNode = new MarkupNode("entry", new IMarkupNode[] { explanationNode, failedMatchesNode });
            		State.Log.LogError(new LogEntry("Method resolution error", messageNode, Location));
            	}
            	else
            	{
            		State.Log.LogError(new LogEntry("Method resolution error", "Method call '" + this.GetCode().ToString() + "' could not be resolved because '" + this.Method.GetCode().ToString() + "' was not recognized as function or type member. Expected signature compatible with " + expectedSignature.ToString() + ".", Location));
            	}
            }

            /*IExpression callerExpr;
            if (method.IsExtension && callerVar != null)
            {
                callerExpr = null;
                var callerInst = MemberAccessSyntaxBase.CreateExtensionCallerExpression(callerVar, Enumerable.FirstOrDefault<IParameter>(method.GetParameters()).ParameterType);
                argExprs = Enumerable.ToArray<IExpression>(Enumerable.Concat<IExpression>((IEnumerable<IExpression>)new IExpression[] { callerInst }, argExprs));
            }
            else
            {
                callerExpr = MemberAccessSyntaxBase.CreateCallerExpression(callerVar, method);
            }
            return new InvocationExpression(method, callerExpr, argExprs);*/

            return CreateInvocationExpression(State, method, callerVar, this, argExprs, Arguments);
        }

        public override const string ToString()
        {
            return GetCode().ToString();
        }

        public const CodeBuilder GetCode()
        {
            CodeBuilder sb = new CodeBuilder();
            sb.Append(Method.GetCode().ToString());
            sb.Append("(");
            bool first = true;
            foreach (var item in Arguments)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    sb.Append(",");
                }
                sb.Append(item.GetCode().ToString());
            }
            sb.Append(")");
            return sb;
        }

        public IExpression GetCallerExpression(ISyntaxState State)
        {
            return Method.GetCallerExpression(State);
        }

        public IVariable GetCallerVariable(ISyntaxState State)
        {
            return Method.GetCallerVariable(State);
        }

        public IEnumerable<ITypeMember> GetAccessedMembers(ISyntaxState State)
        {
            var argExprs = Arguments.CreateExpressions(State);
            var argTypes = argExprs.Types;

            var callerVar = Method.GetCallerVariable(State);

            var matches = Method.GetAccessedMembers(State);

            return Enumerable.OfType<IMethod>(matches).GetBestMethods(callerVar.Type, argTypes);
        }
    }
}
