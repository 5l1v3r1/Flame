using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.DSharp.Build;
using Pixie;

namespace Flame.Syntax.DSharp
{
    public class InvocationSyntax : IInvocationSyntax, ISourceSyntax
    {
        public const this(set ITypeMemberAccessSyntax Method, set DelimitedList<IExpressionSyntax> ArgumentList);

        public ITypeMemberAccessSyntax Method { const get; private set; }
        public DelimitedList<IExpressionSyntax> ArgumentList { const get; private set; }
        public [IExpressionSyntax] Arguments { const get return ArgumentList; }

        public SourceLocation Location
        {
        	const get return Method.GetSourceLocation().Concat(ArgumentList.Location);
        }

        public static const IExpression CastExtensionCallerExpression(ISyntaxState State, IVariable callerInst, ISyntaxNode MethodNode, IType TargetType)
        {
        	var valType = callerInst.Type;
	    	if (valType.Is(TargetType))
	     	{
	        	return callerInst.CreateGetExpression();
	    	}
	    	else if (TargetType.IsPointer && !valType.IsPointer)
	      	{
	         	if (TargetType.AsContainerType().GetElementType().IsValueType)
	       			return MemberAccessSyntaxBase.CreateAddressToValueExpression(callerInst);
	     	}
	       	if (CastSyntax.UseImplicitCast(State, valType, TargetType))
	       	{
	        	return ConversionExpression.Create(callerInst.CreateGetExpression(), TargetType);
	      	}

	        State.Log.LogError(new LogEntry("Cast error",
                "The caller of '" + MethodNode.GetCode().ToString() +
                "' of type '" + State.TypeNamer.Convert(valType) +
                "' could not be cast implicitly to '" +
                State.TypeNamer.Convert(TargetType) + "'",
                MethodNode.GetSourceLocation()));

	        return ConversionExpression.Create(callerInst.CreateGetExpression(), TargetType);
        }

        public static const IExpression CreateInvocationExpression(ISyntaxState State, IExpression Delegate, ISyntaxNode MethodNode, [IExpression] Arguments, [IExpressionSyntax] Nodes)
        {
            var delegateParams = Delegate.GetDelegateParameterTypes();

            var callArgs = new List<IExpression>();
            foreach (var input in Arguments, var node in Nodes, var targetType in delegateParams)
            {
                callArgs.Add(CastSyntax.CreateImplicitCast(State, input, node, targetType));
            }

            return Delegate.CreateDelegateInvocationExpression(callArgs);
        }

        public static const void AppendCallSignature(CodeBuilder SignatureBuilder, IType[] argTypes, IConverter<IType, string> TypeNamer)
        {
    	    SignatureBuilder.Append('(');
        	bool first = true;
        	foreach (var item in argTypes)
        	{
        		if (first)
        			first = false;
        		else
        			SignatureBuilder.Append(", ");

        		if (item == null) SignatureBuilder.Append("<unresolved type>");
        		else SignatureBuilder.Append(TypeNamer.Convert(item));
        	}
        	SignatureBuilder.Append(')');
        }

        public static const IMarkupNode CreateSignatureDiff(IMethod Method, IType[] ArgumentTypes, IConverter<IType, string> TypeNamer)
        {
            var nodes = new List<IMarkupNode>();
            if (Method.IsStatic)
            {
                nodes.Add(TypeDiffComparer.ToTextNode("static "));
            }
            if (Method.IsConstructor)
            {
                nodes.Add(TypeDiffComparer.ToTextNode("new "));
                nodes.Add(TypeDiffComparer.ToTextNode(TypeNamer.Convert(Method.DeclaringType)));
            }
            else
            {
                var retType = Method.ReturnType;
                if (retType == null)
                {
                    nodes.Add(TypeDiffComparer.ToTextNode("void"));
                }
                else
                {
                    nodes.Add(TypeDiffComparer.ToTextNode(TypeNamer.Convert(Method.ReturnType)));
                }
                nodes.Add(TypeDiffComparer.ToTextNode(" "));
                nodes.Add(TypeDiffComparer.ToTextNode(Method.FullName));
            }
            var methodDiffBuilder = new MethodDiffComparer(TypeNamer);
            nodes.Add(methodDiffBuilder.CompareArguments(ArgumentTypes, Method));
            return new MarkupNode("node", nodes);
        }

        public static const CodeBuilder CreateExpectedSignatureDescription(CodeBuilder CallerCode, IType[] ArgumentTypes, IConverter<IType, string> TypeNamer)
        {
            var expectedSignature = new CodeBuilder();
        	expectedSignature.Append("'");
			expectedSignature.Append(CallerCode);
        	AppendCallSignature(expectedSignature, ArgumentTypes, TypeNamer);
        	expectedSignature.Append("'");
        	/*if (CallerType != null)
        	{
            	expectedSignature.Append(" (where the caller expression is of type '");
            	expectedSignature.Append(TypeNamer.Convert(CallerType));
            	expectedSignature.Append("')");
        	}*/
        	return expectedSignature;
        }

        public const IExpression CreateExpression(ISyntaxState State)
        {
            var delegatesExpr = ((IExpressionSyntax)Method).CreateVerifiedExpression(State);
            var delegates = IntersectionExpression.GetIntersectedExpressions(delegatesExpr);

            var argExprs = Arguments.CreateVerifiedExpressions(State);
            var argTypes = argExprs.Types;

            var resolvedDelegate = delegates.GetBestDelegate(argTypes);

            if (resolvedDelegate != null)
            {
                return CreateInvocationExpression(State, resolvedDelegate, Method, argExprs, Arguments);
            }

            var matches = delegatesExpr.GetMethodGroup();

            var namer = State.TypeNamer;
        	var expectedSignature = CreateExpectedSignatureDescription(Method.GetCode().Trim(), argTypes, namer).Trim();

            var thisCode = this.GetCode().Trim();

        	var failedMatches = Enumerable.ToArray<IMethod>(matches);
        	if (failedMatches.Length > 0)
        	{
        		var failedMatchesList = new List<IMarkupNode>();
        		foreach (var item in failedMatches)
        		{
                    failedMatchesList.Add(CreateSignatureDiff(item, argTypes, namer));
        		}
                var explanationNode = new MarkupNode(NodeConstants.TextNodeType,
                    "Method call '" + thisCode.ToString() + "' could not be resolved. " +
                    "Expected signature compatible with " + expectedSignature.ToString() +
                    ". Incompatible or ambiguous matches:");
                var failedMatchesNode = new MarkupNode("list", failedMatchesList);
                var messageNode = new MarkupNode("entry", new IMarkupNode[] { explanationNode, failedMatchesNode });
        		State.Log.LogError(new LogEntry("Method resolution error", messageNode, Location));
        	}
        	else
        	{
                var thisMethodCode = this.Method.GetCode().Trim();
        		State.Log.LogError(new LogEntry("Method resolution error", "Method call '" + thisCode.ToString() + "' could not be resolved because '" + thisMethodCode.ToString() + "' was not recognized as function or type member. Expected signature compatible with " + expectedSignature.ToString() + ".", Location));
        	}

            return null;
        }

        public override const string ToString()
        {
            return GetCode().ToString();
        }

        public const CodeBuilder GetCode()
        {
            var sb = new CodeBuilder();
            sb.Append(Method.GetCode());
            sb.Append(ArgumentList.GetCode());
            return sb;
        }

        public IExpression GetCallerExpression(ISyntaxState State)
        {
            return Method.GetCallerExpression(State);
        }

        public IVariable GetCallerVariable(ISyntaxState State)
        {
            return Method.GetCallerVariable(State);
        }

        public [ITypeMember] GetAccessedMembers(ISyntaxState State)
        {
            var argExprs = Arguments.CreateExpressions(State);
            var argTypes = argExprs.Types;

            var callerVar = Method.GetCallerVariable(State);

            var matches = Method.GetAccessedMembers(State);

            return Enumerable.OfType<IMethod>(matches).GetBestMethods(callerVar.Type, argTypes);
        }
    }
}
