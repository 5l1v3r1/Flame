using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.DSharp.Build;
using Pixie;

namespace Flame.Syntax.DSharp
{
    public class NewObjectSyntax : IInvocationSyntax, ISourceSyntax
    {
        public const this(set Token NewKeyword, set ITypeSyntax Type, set [IExpressionSyntax] Arguments);
        public const this(set ITypeSyntax Type, set [IExpressionSyntax] Arguments)
        {
        	this.NewKeyword = new Token(TokenType.NewKeyword, "new");
        }
        public const this(set ITypeSyntax Type)
        {
        	this.NewKeyword = new Token(TokenType.NewKeyword, "new");
        	this.Arguments = new IExpressionSyntax[0];
        }

        public Token NewKeyword { const get; private set; }
        public ITypeSyntax Type { const get; private set; }
        public [IExpressionSyntax] Arguments { const get; private set; }

        public SourceLocation Location
        {
        	const get
        	{
        		var result = NewKeyword.Location.Concat(Type.GetSourceLocation());
				foreach (var item in Arguments)
					result = result.Concat(item.GetSourceLocation());
				return result;
        	}
        }

        protected IType CreateType(ISyntaxState State)
        {
            ISyntaxState localSyntaxState;
            if (NewKeyword.Type == TokenType.UNDEFINED)
            {
                var attrBinder = new AttributeBinder(State.Binder);
                localSyntaxState = new IndirectSyntaxState(State, attrBinder, State.MemberProvider);
            }
            else
            {
                localSyntaxState = State;
            }

            return Type.CreateVerifiedType(localSyntaxState);
        }

        public IExpression CreateExpression(ISyntaxState State)
        {
            var realType = CreateType(State);

			List<IExpression> argList = new List<IExpression>();
			foreach (var item in Arguments)
			{
				argList.Add(item.CreateVerifiedExpression(State));
			}
            var args = argList.ToArray();

            if (args.Length == 0 && realType.IsVector)
            {
            	var vectType = realType.AsContainerType().AsVectorType();
                return new NewVectorExpression(vectType.GetElementType(), vectType.GetDimensions());
            }
            else if (args.Length == 0 && realType.IsArray) // special case to support initialized arrays
            {
                return new NewArrayExpression(realType.AsContainerType().GetElementType(), (IReadOnlyList<IExpression>)new IExpression[] { null });
            }
            else
            {
            	var argTypes = args.Types;

                var ctor = realType.GetConstructors().GetBestMethod(false, realType, argTypes);

                if (ctor == null)
                {
                	var newInstanceCode = new CodeBuilder();
                	newInstanceCode.Append(NewKeyword.ToString());
                	newInstanceCode.Append(Type.GetCode());
                    var namer = new DSharpTypeNamer();
                	var expectedSignature = InvocationSyntax.CreateExpectedSignatureDescription(null, newInstanceCode, argTypes, false, namer);
                	var failedMatches = Enumerable.ToArray<IMethod>(realType.GetConstructors());
	            	if (failedMatches.Length > 0)
	            	{
                        var failedMatchesList = new List<IMarkupNode>();
                        foreach (var item in failedMatches)
                        {
                            failedMatchesList.Add(InvocationSyntax.CreateSignatureDiff(item, argTypes, namer));
                        }
                        var explanationNode = new MarkupNode(NodeConstants.TextNodeType,
                            "No appropriate constructor for '" + Type.GetCode().ToString() + "' could be found in new object expression '" + this.GetCode().ToString() + "', expected signature compatible with " + expectedSignature.ToString() + ". Incompatible or ambiguous matches:");
                        var failedMatchesNode = new MarkupNode("list", failedMatchesList);
                        var messageNode = new MarkupNode("entry", new IMarkupNode[] { explanationNode, failedMatchesNode });
                        State.Log.LogError(new LogEntry("Constructor resolution error", messageNode, Location));
	            	}
	            	else
	            	{
	            		State.Log.LogError(new LogEntry("Constructor resolution error", "No appropriate constructor for '" + Type.GetCode().ToString() + "' could be found in new object expression '" + this.GetCode().ToString() + "', expected signature compatible with " + expectedSignature.ToString(), Location));
	            	}
                	return null;
                }

                return new InvocationExpression(ctor, null, args);
            }
        }

        public IExpression GetCallerExpression(ISyntaxState State)
        {
            return null;
        }

        public IVariable GetCallerVariable(ISyntaxState State)
        {
            return null;
        }

        public const IEnumerable<ITypeMember> GetAccessedMembers(ISyntaxState State)
        {
            var realType = CreateType(State);

			List<IType> argTypes = new List<IType>();
			foreach (var arg in Arguments)
			{
				argTypes.Add(arg.CreateVerifiedExpression(State).Type);
			}

            return new ITypeMember[] { realType.GetConstructors().GetBestMethod(false, realType, argTypes.ToArray()) };
        }

        public override const string ToString()
        {
            return GetCode().ToString();
        }

        public const CodeBuilder GetCode()
        {
            CodeBuilder cb = new CodeBuilder();
            if (NewKeyword.Type != TokenType.UNDEFINED)
            {
                cb.Append(NewKeyword.ToString());
            }
            cb.Append(Type.GetCode());
            cb.Append("(");
            bool first = true;
            foreach (var item in Arguments)
            {
                if (first)
                {
                    first = false;
                }
                else
                {
                    cb.Append(",");
                }
                cb.Append(item.GetCode().ToString());
            }
            cb.Append(")");
            return cb;
        }
    }
}
