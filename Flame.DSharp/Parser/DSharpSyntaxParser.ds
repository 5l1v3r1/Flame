using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.DSharp.Build;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Parser
{
	/// <summary>
	/// The D# syntax parser.
	/// </summary>
	/// <remarks>
	/// This is where the magic happens.
	/// </remarks>
	public virtual class DSharpSyntaxParser
	{
		public this(set ICompilerLog Log);
	
		public ICompilerLog Log { const get; private set; }
	
		#region ParseExpression
	
        public virtual IExpressionSyntax ParseExpression(ITokenStream Tokens)
        {
            var firstExpr = ParseSingleExpression(Tokens);
            var peek = Tokens.PeekNoTrivia();
            if (peek.TokenPeek.Type.IsBinaryExpressionToken())
            {
                return ParseBinaryExpression(firstExpr, Tokens, int32.MaxValue);
            }
            else
            {
                return firstExpr;
            }
        }
        
        protected virtual IExpressionSyntax ParseSafeExpression(ITokenStream Tokens)
        {
            /*IExpressionSyntax syntax;
            try
            {
                syntax = ParseExpression(Tokens);
            }
            catch (Exception)
            {
                syntax = null;
            }
            return syntax;*/
            return ParseExpression(Tokens); // All expressions should be safe now.
        }
        
        #endregion
        
        #region ParseSingleExpression
        
        protected virtual IExpressionSyntax ParseSingleExpression(ITokenStream Parser)
        {
        	if (MatchesInlineDeclarationPattern(Parser))
        	{
        		return ParseInlineDeclarationSyntax(Parser);
        	}
        	else
        	{
	            var token = Parser.NextNoTrivia();
	            IExpressionSyntax expr;
	            if (token.Type == TokenType.Identifier)
	            {
	                expr = new IdentifierSyntax(token);
	            }
	            else if (token.Type == TokenType.ThisKeyword)
	            {
	                expr = new ThisSyntax(token);
	            }
	            else if (token.Type == TokenType.NullKeyword)
	            {
	                expr = new NullSyntax(token);
	            }
	            else if (token.Type == TokenType.HashKeyword)
	            {
	            	expr = ParseHashExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.NewKeyword)
	            {
	                expr = ParseNewObjectExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.DefaultKeyword)
	            {
	                expr = ParseDefaultValueExpression(token, Parser);
	            }
	            else if (token.Type.IsValueToken())
	            {
	                expr = GetValue(token);
	            }
	            else if (token.Type.IsPrefixUnaryToken())
	            {
	                expr = ParsePrefixedExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.RParen)
	            {
	                expr = ParseParenthesesExpression(Parser);
	            }
	            else
	            {
	                Log.LogError(new LogEntry("Parser error", "Could not identify token '" + token.TokenValue + "' as valid expression syntax."));
	                return null;
	            }
	            return ParseIdentifierExpression(expr, Parser);
            }
        }
        
        #endregion
        
        #region Type Parsing

        #region Array Type Shred

        protected virtual int ExploreArrayTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            int count = 1;
            if (peek.Type != TokenType.RBrackets)
            {
                return 0;
            }
            else
            {
                do
                {
                    *Position = peek.Identifier;
                    peek = Tokens.PeekNoTrivia(*Position);
                    count++;
                    if (peek.Type == TokenType.Integer) // Vector type.
                    {
                        peek = Tokens.PeekNoTrivia(peek);
                        count++;
                    }
                    else if (peek.Type != TokenType.Comma && peek.Type != TokenType.LBrackets)
                    {
                        return 0;
                    }
                } while (peek.Type == TokenType.Comma)
                if (peek.Type == TokenType.LBrackets)
                {
                	*Position = peek.Identifier;
                    return ExploreTypeShred(Tokens, Position) + count;
                }
                else
                {
                    return 0;
                }
            }
        }

        #endregion
        
        #region Peek Array Type Shred
        
        protected virtual ITokenTypeSyntax PeekArrayTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, TokenIdentifier^ Position)
        {
        	var leading = Tokens.PeekNoTrivia(*Position);
            if (leading.Type != TokenType.RBrackets)
            {
                return null;
            }
            else
            {
            	var peek = leading;
            	List<Token> commas = new List<Token>();
            	List<IExpressionSyntax> exprs = new List<IExpressionSyntax>();
                do
                {
                    *Position = peek.Identifier;
                    peek = Tokens.PeekNoTrivia(*Position);
                    if (peek.Type == TokenType.Integer) // Vector type.
                    {
                    	exprs.Add(new IntegerSyntax(peek.TokenPeek));
                        peek = Tokens.PeekNoTrivia(peek);
                    }
                    if (peek.Type == TokenType.Comma)
                    {
                    	commas.Add(peek.TokenPeek);
                    }
                    else if (peek.Type != TokenType.LBrackets)
                    {
                        return null;
                    }
                } while (peek.Type == TokenType.Comma)
                if (peek.Type == TokenType.LBrackets)
                {
                	*Position = peek.Identifier;
                	ITokenTypeSyntax type;
                	if (exprs.Count == 0)
                	{
                		type = new ArrayTypeSyntax(ElementType, leading.TokenPeek, commas, peek.TokenPeek);
                	}
                	else
                	{
                		type = new VectorTypeSyntax(ElementType, leading.TokenPeek, new SeparatedList<IExpressionSyntax>(exprs, commas), peek.TokenPeek);
	                	if (exprs.Count - 1 != commas.Count)
	                	{
	                		// State.Log.LogError(new LogEntry("Type parsing error", "Type '" + type.GetCode().ToString() + "' is neither a vector nor an array type"));
	                		return null;
	                	}
                	}
                		
                    var nextShred = PeekTypeShred(Tokens, type, Position);
                    if (nextShred == null)
                    	return type;
                    else
                    	return nextShred;
                }
                else
                {
                    return null;
                }
            }
        }
        
        #endregion

        #region Generic Type Shred

        // <shred, shred, shred>
        protected virtual int ExploreGenericTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            int count = 1;
            if (peek.Type != TokenType.LessThan)
            {
                return 0;
            }
            else
            {
                do
                {
                    *Position = peek.Identifier;
                    count += ExploreEntireType(Tokens, Position);
                    peek = Tokens.PeekNoTrivia(*Position);
                    count++;
                } while (peek.Type == TokenType.Comma)
                if (peek.Type == TokenType.GreaterThan)
                {
                    *Position = peek.Identifier;
                    return ExploreTypeShred(Tokens, Position) + count;
                }
                else
                {
                    return 0;
                }
            }
        }

        #endregion
        
        #region Peek Generic Type Shred
        
        protected virtual ITokenTypeSyntax PeekGenericTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, TokenIdentifier^ Position)
        {
        	var leading = Tokens.PeekNoTrivia(*Position);
            if (leading.Type != TokenType.LessThan)
            {
                return null;
            }
            else
            {
            	var peek = leading;
            	List<SeparatedItem<ITokenTypeSyntax>> typeArgs = new List<SeparatedItem<ITokenTypeSyntax>>();
                do
                {
                    *Position = peek.Identifier;
                    var arg = PeekEntireType(Tokens, Position);
                    if (arg == null)
                    {
                    	return null;
                    }
                    if (peek.Type == TokenType.Comma)
                    {
                    	typeArgs.Add(new SeparatedItem<ITokenTypeSyntax>(peek.TokenPeek, arg));
                    }
                    else
                    {
                    	typeArgs.Add(new SeparatedItem<ITokenTypeSyntax>(arg));
                    }
                    peek = Tokens.PeekNoTrivia(*Position);
                } while (peek.Type == TokenType.Comma)
                if (peek.Type == TokenType.GreaterThan)
                {
                	*Position = peek.Identifier;
                	
                	ITokenTypeSyntax type = new GenericInstanceTypeSyntax(ElementType, leading.TokenPeek, new SeparatedList<ITokenTypeSyntax>(typeArgs), peek.TokenPeek);
                		
                    var nextShred = PeekTypeShred(Tokens, type, Position);
                    if (nextShred == null)
                    	return type;
                    else
                    	return nextShred;
                }
                else
                {
                    return null;
                }
            }
        }
        
        #endregion

        #region Dot Type Shred

        // .identifier
        protected virtual int ExploreDotTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type != TokenType.Dot)
            {
                return 0;
            }
            peek = Tokens.PeekNoTrivia(peek);
            if (peek.Type != TokenType.Identifier)
            {
                return 0;
            }
            *Position = peek.Identifier;
            return ExploreTypeShred(Tokens, Position) + 2;
        }

        #endregion
        
        #region Peek Dot Type Shred
        
        // .identifier
        protected virtual ITokenTypeSyntax PeekDotTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, TokenIdentifier^ Position)
        {
            var dotPeek = Tokens.PeekNoTrivia(*Position);
            if (dotPeek.Type != TokenType.Dot)
            {
                return null;
            }
            var identifierPeek = Tokens.PeekNoTrivia(dotPeek);
            if (identifierPeek.Type != TokenType.Identifier)
            {
                return null;
            }
            var type = new DotTypeSyntax(ElementType, dotPeek.TokenPeek, identifierPeek.TokenPeek);
            *Position = identifierPeek.Identifier;
            var nextType = PeekTypeShred(Tokens, type, Position);
            if (nextType == null)
            	return type;
            else
            	return nextType;
        }
        
        #endregion
        
        #region Enumerable Type Shred
        
        protected virtual int ExploreEnumerableTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
        	var peek = Tokens.PeekNoTrivia(*Position);
        	int count = 1;
            if (peek.Type != TokenType.RBrackets)
            {
                return 0;
            }
            *Position = peek.Identifier;
            peek = Tokens.PeekNoTrivia(peek);
            bool isEnumerator = false;
            if (peek.Type == TokenType.LessThan)
            {
            	isEnumerator = true;
            	*Position = peek.Identifier;
            }
            count += ExploreEntireType(Tokens, Position);
            peek = Tokens.PeekNoTrivia(*Position);
            if (isEnumerator)
            {
	            if (peek.Type != TokenType.GreaterThan)
	            {
	            	return 0;
	            }
            	peek = Tokens.PeekNoTrivia(peek);
            }
            if (peek.Type != TokenType.LBrackets)
            {
            	return 0;
            }
            *Position = peek.Identifier;
            return count + 1;
        }
        
        #endregion
        
        #region Peek Type Shred
        
        protected virtual ITokenTypeSyntax PeekEnumerableTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
        	var leadingPeek = Tokens.PeekNoTrivia(*Position);
        	int count = 1;
            if (leadingPeek.Type != TokenType.RBrackets)
            {
                return null;
            }
            *Position = leadingPeek.Identifier;
            
            var leadingLessThanPeek = Tokens.PeekNoTrivia(leadingPeek);
            if (leadingLessThanPeek.Type == TokenType.LessThan)
            {
            	*Position = leadingLessThanPeek.Identifier;
            	var elemType = PeekEntireType(Tokens, Position);
            	var trailingGreaterThanPeek = Tokens.PeekNoTrivia(*Position);
            	if (trailingGreaterThanPeek.Type != TokenType.GreaterThan)
            	{
            		return null;
            	}
            	var trailingPeek = Tokens.PeekNoTrivia(trailingGreaterThanPeek);
            	if (trailingPeek.Type != TokenType.LBrackets)
            	{
            		return null;
            	}
            	*Position = trailingPeek.Identifier;
            	return new EnumeratorTypeSyntax(leadingPeek.TokenPeek, leadingLessThanPeek.TokenPeek, elemType, trailingGreaterThanPeek.TokenPeek, trailingPeek.TokenPeek);
            }
            else
            {
            	var elemType = PeekEntireType(Tokens, Position);
            	var trailingPeek = Tokens.PeekNoTrivia(*Position);
            	if (trailingPeek.Type != TokenType.LBrackets)
            	{
            		return null;
            	}
            	*Position = trailingPeek.Identifier;
            	return new EnumerableTypeSyntax(leadingPeek.TokenPeek, elemType, trailingPeek.TokenPeek);
            }
        }
        
        #endregion
        
        #region Explore Entire Type
        
        protected virtual int ExploreEntireType(ITokenStream Tokens, TokenIdentifier^ Position)
        {
        	var peek = Tokens.PeekNoTrivia(*Position);
        	if (peek.Type == TokenType.VarKeyword)
        	{
        		*Position = peek.Identifier;
        		return 1;
        	}
        	else if (peek.Type == TokenType.Identifier)
            {
                *Position = peek.Identifier;
                return ExploreTypeShred(Tokens, Position) + 1;
            }
            else if (peek.Type == TokenType.RBrackets)
            {
            	return ExploreEnumerableTypeShred(Tokens, Position);
            }
            else
            {
				return 0;
            }
        }
        
        protected virtual int ExploreEntireType(ITokenStream Tokens)
        {
            TokenIdentifier pos = Tokens.CurrentPosition;
            return ExploreEntireType(Tokens, &pos);
        }
        
        #endregion
        
        #region Peek Entire Type
        
        protected virtual ITokenTypeSyntax PeekEntireType(ITokenStream Tokens, TokenIdentifier^ Position)
        {
        	var peek = Tokens.PeekNoTrivia(*Position);
        	if (peek.Type == TokenType.VarKeyword)
        	{
        		*Position = peek.Identifier;
        		return new InferredTypeSyntax(peek.TokenPeek);
        	}
        	else if (peek.Type == TokenType.Identifier)
            {
                return PeekIdentifierTypeShred(Tokens, Position);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
            	return PeekEnumerableTypeShred(Tokens, Position);
            }
            else
            {
				return null;
            }
        }
        
        protected virtual ITokenTypeSyntax PeekEntireType(ITokenStream Tokens)
        {
            TokenIdentifier pos = Tokens.CurrentPosition;
            return PeekEntireType(Tokens, &pos);
        }
        
        #endregion

        #region ExploreTypeIdentifierShred

        protected virtual int ExploreTypeIdentifierShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.Identifier || peek.Type == TokenType.VarKeyword)
            {
                *Position = peek.Identifier;
                return ExploreTypeShred(Tokens, Position) + 1;
            }
            else
            {
				return 0;
            }
        }

        protected virtual int ExploreTypeIdentifierShred(ITokenStream Tokens)
        {
            TokenIdentifier pos = Tokens.CurrentPosition;
            return ExploreTypeIdentifierShred(Tokens, &pos);
        }

        #endregion
        
        #region Peek Type Identifier Shred
        
        protected virtual ITokenTypeSyntax PeekIdentifierTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.VarKeyword)
            {
            	*Position = peek.Identifier;
            	return new InferredTypeSyntax(peek.TokenPeek); 
            }
            else if (peek.Type == TokenType.Identifier)
            {
                *Position = peek.Identifier;
                var identifierSyntax = new IdentifierTypeSyntax(peek.TokenPeek);
                
                var nextType = PeekTypeShred(Tokens, identifierSyntax, Position);
                if (nextType != null)
                {
                	return nextType;
                }
                else
                {
                	return identifierSyntax;
                }
            }
            else
            {
				return null;
            }
        }
        
        #endregion

        #region ExploreTypeShred

        protected virtual int ExploreTypeShred(ITokenStream Tokens, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.LessThan)
            {
                return ExploreGenericTypeShred(Tokens, Position);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
                return ExploreArrayTypeShred(Tokens, Position);
            }
            else if (peek.Type == TokenType.Dot)
            {
                return ExploreDotTypeShred(Tokens, Position);
            }
            else if (peek.Type == TokenType.Asterisk || peek.Type == TokenType.Caret)
            {
                *Position = peek.Identifier;
                return ExploreTypeShred(Tokens, Position) + 1;
            }
            else
            {
                return 0;
            }
        }

        #endregion
        
        #region Peek Type Shred

        protected virtual ITokenTypeSyntax PeekTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.LessThan)
            {
                return PeekGenericTypeShred(Tokens, ElementType, Position);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
                return PeekArrayTypeShred(Tokens, ElementType, Position);
            }
            else if (peek.Type == TokenType.Dot)
            {
                return PeekDotTypeShred(Tokens, ElementType, Position);
            }
            else if (peek.Type == TokenType.Asterisk || peek.Type == TokenType.Caret)
            {
                *Position = peek.Identifier;
                var pointerType = new PointerTypeSyntax(ElementType, peek.TokenPeek);
                
                var nextType = PeekTypeShred(Tokens, pointerType, Position);
                
                if (nextType == null)
                	return pointerType;
                else
                	return nextType;
            }
            else
            {
                return null;
            }
        }

        #endregion

        protected virtual IEnumerable<Token> ParseTypeTokens(ITokenStream Tokens)
        {
        	var peekType = PeekEntireType(Tokens);
        	
        	if (peekType == null)
        		return (IEnumerable<Token>)new Token[0];
        	
            int parseCount = peekType.Tokens.Count;

            Token[] tokens = new Token[parseCount];

            for (int i = 0; i < parseCount; ++i)
            {
                tokens[i] = Tokens.NextNoTrivia();
            }

            return tokens;
        }

        public virtual ITypeSyntax ToTypeSyntax(ITokenStream Tokens)
        {
            if (Tokens.PeekNoTrivia().Type == TokenType.EndOfFile)
            {
                return null;
            }
            ITypeSyntax tSyntax = ParseType(Tokens);
            if (Tokens.PeekNoTrivia().Type == TokenType.EndOfFile)
            {
                return tSyntax;
            }
            else
            {
                return null;
            }
        }

        public virtual ITypeSyntax ParseType(ITokenStream Tokens)
        {
            /*IEnumerable<Token> tTokens = ParseTypeTokens(Tokens);

            return new TypeSyntax(tTokens);*/
            
            var type = PeekEntireType(Tokens);
            
            if (type == null) // No type was parsed. So be it.
            {
            	return null;
            }
            
            int parseCount = type.Tokens.Count;
            
            for (int i = 0; i < parseCount; i++)
            {
                Tokens.NextNoTrivia();
            }
            
            return type;
        }

        #endregion
        
        #region Expressions
        
        #region ParseHashExpression
        
        protected virtual IExpressionSyntax ParseHashExpression(Token HashKeyword, ITokenStream Parser)
        {
        	var leadingParen = Parser.NextNoTrivia(TokenType.RParen, Log);
        	var expr = ParseExpression(Parser);
        	var trailingParen = Parser.NextNoTrivia(TokenType.LParen, Log);
        	return new HashSyntax(HashKeyword, leadingParen, expr, trailingParen);
        }
        
        #endregion
        
        #region ParseParenthesesSyntax
        
        protected virtual IExpressionSyntax ParseCastExpression(ITypeSyntax Type, ITokenStream Parser)
        {
            var expr = ParseSingleExpression(Parser);
            return new CastSyntax(Type, expr);
        }

        protected virtual IExpressionSyntax ParseParenthesesExpression(ITokenStream Parser)
        {
            var block = Parser.NextBlockContents(TokenType.RParen, TokenType.LParen);            

            var tSyntax = ToTypeSyntax(block);
            block.Reset();

            /* This is what the C# spec says about parentheses: 
             * To resolve cast-expression ambiguities, the following rule exists: A sequence of one or more tokens (§2.3.3) enclosed in parentheses is considered the start of a cast-expression only if at least one of the following are true:
             *  ⦁	The sequence of tokens is correct grammar for a type, but not for an expression.
             *  ⦁	The sequence of tokens is correct grammar for a type, and the token immediately following the closing parentheses is the token “~”, the token “!”, the token “(”, an identifier (§2.4.1), a literal (§2.4.4), or any keyword (§2.4.3) except as and is.
             */
            if (tSyntax != null) // probably a conversion
            {
                var peek = Parser.PeekNoTrivia();
                if ((peek.Type.IsValueToken() || peek.Type == TokenType.Not || peek.Type == TokenType.Tilde || peek.Type == TokenType.RParen || (peek.Type.IsKeyword() && !peek.Type.IsTypeBinaryExpressionToken())))
                {
                    return ParseCastExpression(tSyntax, Parser);
                }
                else
                {
                    var blockExpr = ParseSafeExpression(block);
                    if (blockExpr == null)
                    {
                        return ParseCastExpression(tSyntax, Parser);
                    }
                    else
                    {
                        return blockExpr;
                    }
                }
            }
            else
            {
                return new ParenthesesSyntax(ParseExpression(block));
            }
        }
        
        #endregion
        
        #region GetPrecendence

        protected virtual int32 GetPrecedence(TokenType Token)
        {
            if (Token == TokenType.Percent || Token == TokenType.Asterisk || Token == TokenType.Slash)
            {
            	return 0;
            }
            else if (Token == TokenType.Plus || Token == TokenType.Minus)
            {
            	return 1;
            }
            else if (Token == TokenType.LeftShift || Token == TokenType.RightShift)
            {
            	return 2;
            }
            else if (Token == TokenType.EqualsEquals || Token == TokenType.NotEquals)
           	{
           		return 3;
           	}
           	else if (Token == TokenType.GreaterThanOrEquals || Token == TokenType.GreaterThan || 
           			Token == TokenType.LessThanOrEquals || Token == TokenType.LessThan ||
           			Token == TokenType.IsKeyword)
            {
	            return 4;
            }
            else if (Token == TokenType.And)
            {
            	return 5;
            }
            else if (Token == TokenType.Caret)
            {
            	return 6;
            }
            else if (Token == TokenType.Bar)
            {
            	return 7;
            }
            else if (Token == TokenType.AndAnd)
            {
            	return 8;
            }
            else if (Token == TokenType.BarBar)
            {
            	return 9;
            }
            else if (Token == TokenType.Equals || Token == TokenType.AndEquals || 
           			Token == TokenType.BarEquals || Token == TokenType.PercentEquals ||
           			Token == TokenType.CaretEquals || Token == TokenType.PlusEquals ||
           			Token == TokenType.MinusEquals || Token == TokenType.AsteriskEquals ||
           			Token == TokenType.SlashEquals)
            {
	            return 10;
            }
            else
            {
            	return int32.MaxValue;
            }
        }

        #endregion
        
        #region CreateBinaryExpression

        protected virtual IExpressionSyntax CreateNormalBinaryExpression(IExpressionSyntax A, IExpressionSyntax B, Token Operator)
        {
        	if (Operator.Type == TokenType.AndAnd)
        	{
        		return new LazyAndSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.And)
        	{
        		return new AndSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.BarBar)
        	{
        		return new LazyOrSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Bar)
        	{
        		return new OrSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Caret)
        	{
        		return new XorSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Percent)
        	{
        		return new RemainderSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.EqualsEquals)
        	{
        		return new CheckEqualitySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.NotEquals)
        	{
        		return new CheckInequalitySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.GreaterThanOrEquals)
        	{
        		return new GreaterThanOrEqualsSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.GreaterThan)
        	{
        		return new GreaterThanSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LessThanOrEquals)
        	{
        		return new LessThanOrEqualsSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LessThan)
        	{
        		return new LessThanSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Plus)
        	{
        		return new AddSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Minus)
        	{
        		return new SubtractSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Asterisk)
        	{
        		return new MultiplySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Slash)
        	{
        		return new DivideSyntax(A, Operator, B);
        	}        	
        	else if (Operator.Type == TokenType.RightShift)
        	{
        		return new RightShiftSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LeftShift)
        	{
        		return new LeftShiftSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Equals || Operator.Type == TokenType.AndEquals || Operator.Type == TokenType.BarEquals ||
        			Operator.Type == TokenType.PercentEquals || Operator.Type == TokenType.CaretEquals || Operator.Type == TokenType.PlusEquals ||
        			Operator.Type == TokenType.MinusEquals || Operator.Type == TokenType.AsteriskEquals || Operator.Type == TokenType.SlashEquals)
        	{
        		return new AssignmentSyntax((IVariableSyntax)A, Operator, B);
        	}
        	else
        	{
        		return null;
        	}
        }

        protected virtual IExpressionSyntax CreateTypeBinaryExpression(IExpressionSyntax A, ITypeSyntax B, Token Operator)
        {
            if (Operator.Type == TokenType.IsKeyword)
            {
                return new IsSyntax(A, Operator, B);
            }
            else
            {
                return null;
            }
        }

        protected virtual IExpressionSyntax CreateBinaryExpression(ISyntaxNode A, ISyntaxNode B, Token Operator)
        {
            if (Operator.Type.IsTypeBinaryExpressionToken())
            {
                return CreateTypeBinaryExpression((IExpressionSyntax)A, (ITypeSyntax)B, Operator);
            }
            else
            {
                return CreateNormalBinaryExpression((IExpressionSyntax)A, (IExpressionSyntax)B, Operator);
            }
        }

        protected virtual IExpressionSyntax CreateBinaryExpression(List<ISyntaxNode> Operands, Token Operator)
        {
            IExpressionSyntax expr = CreateBinaryExpression(Operands[0], Operands[1], Operator);
            for (int i = 2; i < Operands.Count; i++)
            {
                expr = CreateBinaryExpression(expr, Operands[i], Operator);
            }
            return expr;
        }

        #endregion
        
        #region ParseBinaryExpression
        
        private static Token PeekOperator(ITokenStream Parser)
        {
        	var peek = Parser.PeekNoTrivia();
        	
        	if (peek.Type == TokenType.GreaterThan)
        	{
        		var peek2 = Parser.Peek(peek);
        		if (peek2.Type == TokenType.GreaterThan)
        		{
        			return peek.TokenPeek.Combine(peek2.TokenPeek, TokenType.RightShift);
        		}
        	}
        	
        	return peek.TokenPeek;
        }
        
        private static Token ParseOperator(ITokenStream Parser)
        {
        	var op = Parser.NextNoTrivia();
        	
        	if (op.Type == TokenType.GreaterThan)
        	{
        		var peek = Parser.Peek();
        		if (peek.Type == TokenType.GreaterThan)
        		{
        			return op.Combine(Parser.Next(), TokenType.RightShift);
        		}
        	}
        	
        	return op;
        }
        
        protected IExpressionSyntax ParseBinaryExpression(IExpressionSyntax FirstExpression, ITokenStream Parser, int MaxPrecedence)
        {
            List<ISyntaxNode> operands = new List<ISyntaxNode>();
            Token op = ParseOperator(Parser);
            operands.Add(FirstExpression);
            int currentPrecedence = GetPrecedence(op.Type);
            //var nextOpTokenPeek = PeekNoWhitespaceToken(Parser);
            var nextOpTokenPeek = op;
            do
            {
                if (nextOpTokenPeek.Type == op.Type)
                {
                    if (operands.Count > 1)
                    {
                        ParseOperator(Parser);
                    }
                    if (op.Type.IsTypeBinaryExpressionToken())
                    {
                        operands.Add(ParseType(Parser));
                    }
                    else
                    {
                        operands.Add(ParseSingleExpression(Parser));
                    }
                }
                else
                {
                    int nextPrecedence = GetPrecedence(nextOpTokenPeek.Type);
                    if (nextPrecedence < currentPrecedence)
                    {
                        var lastOperand = operands[operands.Count - 1];
                        operands.RemoveAt(operands.Count - 1);
                        var newExpr = ParseBinaryExpression((IExpressionSyntax)lastOperand, Parser, nextPrecedence);
                        operands.Add(newExpr);
                    }
                    else if (nextPrecedence > MaxPrecedence)
                    {
                        return CreateBinaryExpression(operands, op); // We're done here
                    }
                    else
                    {
                        var currentExpr = CreateBinaryExpression(operands, op);
                        return ParseBinaryExpression(currentExpr, Parser, MaxPrecedence);
                    }
                }
                nextOpTokenPeek = PeekOperator(Parser);
            } while (nextOpTokenPeek.Type.IsBinaryExpressionToken())
            return CreateBinaryExpression(operands, op);
        }
        
        #endregion
        
        #region ParseInvocationExpression

        protected virtual IExpressionSyntax ParseInvocationExpression(ITypeMemberAccessSyntax Caller, ITokenStream Parser)
        {
            var exprs = ParseArgumentList(Parser);

            return new InvocationSyntax(Caller, exprs);
        }

        protected virtual IEnumerable<IExpressionSyntax> ParseArgumentListContents(ITokenStream Parser, TokenType RightDelimiter)
        {
            List<IExpressionSyntax> exprs = new List<IExpressionSyntax>();

            var peek = Parser.PeekNoTrivia();
            while (peek.Type != RightDelimiter)
            {
                exprs.Add(ParseExpression(Parser));
                peek = Parser.PeekNoTrivia();
                if (peek.Type == TokenType.Comma)
                {
                    Parser.NextNoTrivia();
                }
                else
                {
                    //peek.TokenPeek.EnsureType(RightDelimiter, Log);
                    break;
                }
            }

            return exprs;
        }

        protected virtual IEnumerable<IExpressionSyntax> ParseArgumentList(ITokenStream Parser, TokenType LeftDelimiter, TokenType RightDelimiter)
        {
            var rParen = Parser.NextNoTrivia();
            rParen.EnsureType(LeftDelimiter, Log);

            var exprs = ParseArgumentListContents(Parser, RightDelimiter);

            var lParen = Parser.NextNoTrivia(RightDelimiter, Log);

            return exprs;
        }

        protected virtual IEnumerable<IExpressionSyntax> ParseArgumentList(ITokenStream Parser)
        {
            return ParseArgumentList(Parser, TokenType.RParen, TokenType.LParen);
        }

        #endregion
        
        #region ParseDefaultValueExpression

        protected virtual IExpressionSyntax ParseDefaultValueExpression(Token DefaultToken, ITokenStream Tokens)
        {
            if (DefaultToken.EnsureType(TokenType.DefaultKeyword, Log))
            {
	            var rParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
	            var type = ParseType(Tokens);
	            var lParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
	
	            var expr = new DefaultValueSyntax(DefaultToken, rParen, type, lParen);
	
	            return expr;
	        }
	        else
	        {
	        	return null;
	        }
        }

        #endregion
        
        #region ParseNewObjectExpression

        protected virtual IExpressionSyntax ParseNewObjectExpression(Token NewToken, ITokenStream Tokens)
        {
            var type = ParseType(Tokens);
            var peek = Tokens.PeekNoTrivia();

            IExpressionSyntax expr;

            if (peek.Type != TokenType.RBrackets)
            {
                IEnumerable<IExpressionSyntax> args;
                if (peek.Type == TokenType.RParen)
                {
                    args = ParseArgumentList(Tokens);
                }
                else
                {
                    args = new IExpressionSyntax[0];
                }
                expr = new NewObjectSyntax(NewToken, type, args);
            }
            else
            {
                IEnumerable<IExpressionSyntax> arrayArgs = ParseArgumentList(Tokens, TokenType.RBrackets, TokenType.LBrackets);
                expr = new NewArraySyntax(NewToken, type, arrayArgs);
            }
            if (Tokens.PeekNoTrivia().Type == TokenType.RBraces)
            {
                return ParseInitializedListExpression(expr, Tokens);
            }
            else
            {
                return expr;
            }
        }

        #endregion
        
        #region ParseInitializedListExpression

        protected virtual IExpressionSyntax ParseInitializedListExpression(IExpressionSyntax List, ITokenStream Tokens)
        {
            var rBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);

            IEnumerable<IExpressionSyntax> exprs = ParseArgumentListContents(Tokens, TokenType.LBraces);

            var lBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            InitializedListSyntax syntax = new InitializedListSyntax(List, rBraces, exprs, lBraces);

            return syntax;
        }

        #endregion
        
        #region GetValue

        protected virtual IExpressionSyntax GetValue(Token Token)
        {
            string val = Token.TokenValue;
            if (Token.Type == TokenType.String)
            {
            	return new StringSyntax(Token);
            }
            else if (Token.Type == TokenType.Char)
            {
            	return new CharSyntax(Token);
            }
            else if (Token.Type == TokenType.Float32)
            {
            	return new Float32Syntax(Token);
            }
            else if (Token.Type == TokenType.Float64)
            {
            	return new Float64Syntax(Token);
            }
            else if (Token.Type == TokenType.HexInteger)
            {
            	return new HexIntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.BinaryInteger)
            {
            	return new BinaryIntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.Identifier)
            {
            	return new IdentifierSyntax(Token);
            }
            else if (Token.Type == TokenType.Integer)
            {
            	return new IntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.TrueLiteral || Token.Type == TokenType.FalseLiteral)
            {
            	return new BooleanSyntax(Token);
            }
            else
            {
            	Log.LogError("The token " + Token.ToString() + " was mistakenly identified as a value token or could not be parsed.");
            	return null;
            }
        }

        #endregion
        
        #region ParsePrefixedExpression

        protected virtual IExpressionSyntax ParsePrefixedExpression(Token Token, ITokenStream Parser)
        {
            if (Token.Type == TokenType.And)
            {
                var variable = GetVariable(Parser);
                return new AddressOfSyntax(Token, variable);
            }
            else
            {
                IExpressionSyntax InnerExpression = ParseSingleExpression(Parser);
                if (Token.Type == TokenType.Plus)
                {
                	return InnerExpression;
                }
                else if (Token.Type == TokenType.PlusPlus || Token.Type == TokenType.MinusMinus)
                {
                	return new PrefixDeltaSyntax(Token, (IVariableSyntax)InnerExpression); 
                }
                else if (Token.Type == TokenType.Minus)
                {
                	return new NegateSyntax(Token, InnerExpression);
                }
                else if (Token.Type == TokenType.Tilde || Token.Type == TokenType.Not)
                {
                	return new NotSyntax(Token, InnerExpression);
                }
                else if (Token.Type == TokenType.Asterisk)
                {
                	return new AtAddressSyntax(Token, InnerExpression);
                }
                else
                {
                	Log.LogError("The token " + Token.ToString() + " was mistakenly identified as an expression prefix or could not be parsed.");
                	return null;
                }
            }
        }

        #endregion
        
        #region IsGenericTypeArgumentSyntax

        protected virtual bool IsGenericTypeArgumentSyntax(ITokenStream Parser)
        {
            var peek = Parser.PeekNoTrivia();
            if (peek.Type == TokenType.LessThan)
            {
                int blocks = 1;
                while (blocks > 0)
                {
                    peek = Parser.PeekNoTrivia(peek);
                    if (peek.Type == TokenType.LessThan)
                    {
                        blocks++;
                    }
                    else if (peek.Type == TokenType.GreaterThan)
                    {
                        blocks--;
                    }
                    else if (!peek.Type.IsTypeToken())
                    {
                        return false;
                    }
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ParseGenericTypeArgumentExpression

        protected virtual IExpressionSyntax ParseGenericTypeArgumentExpression(ITypeMemberAccessSyntax Target, ITokenStream Tokens)
        {
            List<ITypeSyntax> typeSyntaxGroup = new List<ITypeSyntax>();

            var opener = Tokens.NextNoTrivia(TokenType.LessThan, Log);
            typeSyntaxGroup.Add(ParseType(Tokens));
            while (Tokens.PeekNoTrivia().Type == TokenType.Comma)
            {
                Tokens.NextNoTrivia(TokenType.Comma, Log);
                typeSyntaxGroup.Add(ParseType(Tokens));
            }
			
            var closer = Tokens.NextNoTrivia(TokenType.GreaterThan, Log);

            return new GenericTypeArgumentsSyntax(Target, opener, typeSyntaxGroup, closer);
        }

        #endregion

        #region ParseIdentifierExpression

        protected virtual IExpressionSyntax ParseIdentifierExpression(Token Identifier, ITokenStream Parser)
        {
            return ParseIdentifierExpression(new IdentifierSyntax(Identifier), Parser);
        }

        protected virtual IExpressionSyntax ParseIdentifierExpression(IExpressionSyntax Expression, ITokenStream Parser)
        {
            var peek = Parser.PeekNoTrivia();
            if (peek.Type == TokenType.Dot || peek.Type == TokenType.RArrow)
            {
                var dot = Parser.NextNoTrivia();
                var secondIdent = Parser.NextNoTrivia();
                secondIdent.EnsureType(TokenType.Identifier, Log);
                IExpressionSyntax accessExpr;
                if (peek.Type == TokenType.RArrow)
                {
                    accessExpr = new AtAddressMemberAccessSyntax(Expression, dot, secondIdent);
                }
                else
                {
                    accessExpr = new MemberAccessSyntax(Expression, dot, secondIdent);
                }
                return ParseIdentifierExpression(accessExpr, Parser);
            }
            else if (peek.Type == TokenType.RParen)
            {
                var invocation = ParseInvocationExpression((ITypeMemberAccessSyntax)Expression, Parser);
                return ParseIdentifierExpression(invocation, Parser);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
                var indexerExpr = ParseIndexedElementVariable(Expression, Parser);
                return ParseIdentifierExpression(indexerExpr, Parser);
            }
            else if (IsGenericTypeArgumentSyntax(Parser))
            {
                var generic = ParseGenericTypeArgumentExpression((ITypeMemberAccessSyntax)Expression, Parser);
                return ParseIdentifierExpression(generic, Parser);
            }
            else if (peek.Type.IsPostfixUnaryToken())
            {
                var postFixExpr = new PostfixDeltaSyntax((IVariableSyntax)Expression, Parser.NextNoTrivia(peek.Type, Log));
                return ParseIdentifierExpression(postFixExpr, Parser);
            }
            else
            {
                return Expression;
            }
        }

        #endregion
        
        #endregion
        
        #region Variable Parsing

        #region GetVariable

        protected virtual IVariableSyntax GetVariable(ITokenStream Parser)
        {
            IExpressionSyntax parsedExpr = ParseExpression(Parser);
            return (IVariableSyntax)parsedExpr;
        }

        #endregion

        #region ParseIndexedElementVariable

        protected virtual IVariableSyntax ParseIndexedElementVariable(IExpressionSyntax Caller, ITokenStream Parser)
        {
            var exprs = ParseArgumentList(Parser, TokenType.RBrackets, TokenType.LBrackets);

            return new IndexedElementSyntax(Caller, exprs);
        }

        #endregion

        #endregion
        
        #region Statement Parsing

        public virtual IStatementSyntax ParseStatement(ITokenStream Tokens)
        {
            var syntax = ParseStatementInternal(Tokens);
            if (syntax == null)
            {
            	return new EmptySyntax();
            }
            else
            {
            	return syntax;
            }
        }

        #region ParseStatementInternal

        protected virtual IStatementSyntax ParseStatementInternal(ITokenStream Tokens)
        {
            var peek = Tokens.PeekNoTrivia();
            var tokenType = peek.TokenPeek.Type;
            if (tokenType == TokenType.EndOfFile)
            	return null;
            else if (tokenType == TokenType.Semicolon)
            	return new EmptySyntax(Tokens.NextNoTrivia());
            else if (tokenType == TokenType.ReturnKeyword)
            	return ParseReturnSyntax(Tokens);
            else if (tokenType == TokenType.ThrowKeyword)
            	return ParseThrowSyntax(Tokens);
            else if (tokenType == TokenType.AssertKeyword)
            	return ParseAssertSyntax(Tokens);
            else if (tokenType == TokenType.TryKeyword)
            	return ParseTrySyntax(Tokens);
            else if (tokenType == TokenType.YieldKeyword)
            	return ParseYieldSyntax(Tokens);
            else if (tokenType == TokenType.BreakKeyword)
            	return ParseBreakSyntax(Tokens);
            else if (tokenType == TokenType.NextKeyword)
            	return ParseNextSyntax(Tokens);
            else if (tokenType == TokenType.RBraces)
            	return ParseBlockSyntax(Tokens);
            else if (tokenType == TokenType.IfKeyword)
            	return ParseIfElseSyntax(Tokens);
            else if (tokenType == TokenType.WhileKeyword)
            	return ParseWhileSyntax(Tokens);
            else if (tokenType == TokenType.DoKeyword)
            	return ParseDoWhileSyntax(Tokens);
            else if (tokenType == TokenType.ForKeyword)
            	return ParseForSyntax(Tokens);
            else if (tokenType == TokenType.ForeachKeyword)
            	return ParseForeachSyntax(Tokens);
            else
            {
            	if (MatchesDeclarationPattern(Tokens))
               	{
                	return ParseDeclarationSyntax(Tokens);
               	}
             	else
             	{
               		var expr = ParseExpression(Tokens);
               		if (Tokens.PeekNoTrivia().Type == TokenType.Semicolon)
                   	{
                 		Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                   	}
                  	if (expr is ISetVariableExpressionSyntax)
                   	{
                    	return new SetVariableStatementSyntax((ISetVariableExpressionSyntax)expr);
                   	}
                    else
                    {
                    	return new ExpressionStatementSyntax(expr);
                	}
            	}
            }
        }

        #endregion

        #region MatchesDeclarationPattern
        
        protected virtual bool MatchesGeneralDeclarationPattern(ITokenStream Tokens, out PeekToken^ TokenPeek)
        {
        	return MatchesGeneralDeclarationPattern(Tokens, true, TokenPeek);
        }
        
        protected virtual bool MatchesGeneralDeclarationPattern(ITokenStream Tokens, bool AllowAmbiguousTypes, out PeekToken^ TokenPeek)
        {
            int parseCount = ExploreEntireType(Tokens);
            if (parseCount < 1) // At least one token must be valid type syntax.
            {
            	return false;
            }
            var peek = Tokens.PeekNoTrivia();
            for (int i = 0; i < parseCount; i++)
            {
                if (!AllowAmbiguousTypes && i == parseCount - 1 && (peek.Type == TokenType.Asterisk || peek.Type == TokenType.Caret)) // Inline pointer declaration is ambiguous: 'a * b' could be either multiplication or a transient pointer declaration.
                {
                	return false;
                }
            	peek = Tokens.PeekNoTrivia(peek);
            }
            if (peek.Type != TokenType.Identifier)
            {
                return false;
            }
            *TokenPeek = Tokens.PeekNoTrivia(peek);
            return true;
        }

        protected virtual bool MatchesDeclarationPattern(ITokenStream Tokens)
        {
        	PeekToken peek;
            if (!MatchesGeneralDeclarationPattern(Tokens, &peek))
            {
            	return false;
            }
            return peek.Type == TokenType.Semicolon || peek.Type == TokenType.Comma || peek.Type == TokenType.Equals;
        }
        
        protected virtual bool MatchesInlineDeclarationPattern(ITokenStream Tokens)
        {
            PeekToken peek;
            return MatchesGeneralDeclarationPattern(Tokens, false, &peek);
        }

        #endregion

        #region ParseDeclarationSyntax

        protected virtual SingleVariableDeclaration ParseSingleVariableDeclaration(ITokenStream Tokens)
        {
            Token name = Tokens.NextNoTrivia();
            var quickPeek = Tokens.PeekNoTrivia();
            if (quickPeek.Type == TokenType.Equals)
            {
                Token op = Tokens.NextNoTrivia();
                IExpressionSyntax expr = ParseExpression(Tokens);
                return new SingleVariableDeclaration(name, op, expr);
            }
            else
            {
                return new SingleVariableDeclaration(name);
            }
        }

        protected virtual VariableDeclarationSyntax ParseDeclarationSyntax(ITokenStream Tokens)
        {
            var type = ParseType(Tokens);

            List<SingleVariableDeclaration> decl = new List<SingleVariableDeclaration>();
            var peek = Tokens.PeekNoTrivia();
            do
            {
                if (peek.Type == TokenType.Comma)
                {
                    Tokens.NextNoTrivia();
                }
                decl.Add(ParseSingleVariableDeclaration(Tokens));
                peek = Tokens.PeekNoTrivia();
            } while (peek.Type == TokenType.Comma)

            Token semicolon;
            if (Tokens.PeekNoTrivia().Type == TokenType.Semicolon)
            {
                semicolon = Tokens.NextNoTrivia();
            }
            else
            {
                semicolon = Token.Undefined;
            }

            return new VariableDeclarationSyntax(type, decl, semicolon);
        }
        
        protected virtual InlineVariableDeclarationSyntax ParseInlineDeclarationSyntax(ITokenStream Tokens)
        {
            var type = ParseType(Tokens);
            var decl = ParseSingleVariableDeclaration(Tokens);

            return new InlineVariableDeclarationSyntax(type, decl);
        }

        #endregion

        #region ParseReturnSyntax

        protected virtual IStatementSyntax ParseReturnSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.ReturnKeyword, Log);
            var peek = Tokens.PeekNoTrivia();
            if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new ReturnSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                var expr = ParseExpression(Tokens);
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new ReturnSyntax(expr, keyword, semicolon);
            }
        }

        #endregion
        
        #region ParseThrowSyntax

        protected virtual IStatementSyntax ParseThrowSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.ThrowKeyword, Log);
            var expr = ParseExpression(Tokens);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new ThrowSyntax(expr, keyword, semicolon);
        }

        #endregion
        
        #region ParseAssertSyntax
        
        protected virtual IStatementSyntax ParseAssertSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.AssertKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new AssertSyntax(keyword, leadingParen, expr, trailingParen, semicolon);
        }
        
        #endregion
        
        #region ParseYieldSyntax
        
        protected virtual IStatementSyntax ParseYieldSyntax(ITokenStream Tokens)
        {
        	var yieldKeyword = Tokens.NextNoTrivia(TokenType.YieldKeyword, Log);
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type == TokenType.BreakKeyword)
        	{
        		var breakSyntax = ParseBreakSyntax(Tokens);
        		return new YieldBreakSyntax(yieldKeyword, breakSyntax);
        	}
        	else
        	{
        		var returnKeyword = Tokens.NextNoTrivia(TokenType.ReturnKeyword, Log);
        		var expr = ParseExpression(Tokens);
        		var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
        		return new YieldReturnSyntax(yieldKeyword, new ReturnSyntax(expr, returnKeyword, semicolon));
        	}
        }
        
        #endregion

        #region ParseBreakSyntax

        protected virtual BreakSyntax ParseBreakSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.BreakKeyword, Log);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new BreakSyntax(keyword, semicolon);
            /*if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new BreakSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                return new BreakSyntax(keyword, Token.Undefined);
            }*/
        }

        #endregion

        #region ParseNextSyntax

        protected virtual IStatementSyntax ParseNextSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia();
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new NextSyntax(keyword, semicolon);
            /*if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new NextSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                return new NextSyntax(keyword, Token.Undefined);
            }*/
        }

        #endregion

        #region ParseBlock

        protected virtual IStatementSyntax ParseBlockSyntax(ITokenStream Tokens)
        {
        	var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
        	List<IStatementSyntax> statements = new List<IStatementSyntax>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type != TokenType.LBraces && peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED)
        	{
        		statements.Add(ParseStatementInternal(Tokens));
        		peek = Tokens.PeekNoTrivia();
        	}
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);
            return new BlockSyntax(leadingBraces, trailingBraces, statements);
        }

        #endregion

        #region ParseIfElseSyntax

        protected virtual IStatementSyntax ParseIfElseSyntax(ITokenStream Tokens)
        {
            var ifKeyword = Tokens.NextNoTrivia(TokenType.IfKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var ifBody = ParseStatement(Tokens);
            if (Tokens.PeekNoTrivia().Type == TokenType.ElseKeyword)
            {
                var elseKeyword = Tokens.NextNoTrivia();
                var elseBody = ParseStatement(Tokens);
                return new IfElseSyntax(ifKeyword, leadingParen, expr, trailingParen, ifBody, elseKeyword, elseBody);
            }
            else
            {
                return new IfElseSyntax(ifKeyword, leadingParen, expr, trailingParen, ifBody);
            }
        }

        #endregion

        #region ParseWhileSyntax

        protected virtual IStatementSyntax ParseWhileSyntax(ITokenStream Tokens)
        {
            var whileKeyword = Tokens.NextNoTrivia(TokenType.WhileKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var body = ParseStatement(Tokens);
            return new WhileSyntax(whileKeyword, leadingParen, expr, trailingParen, body);
        }

        #endregion

        #region ParseWhileSyntax

        protected virtual IStatementSyntax ParseDoWhileSyntax(ITokenStream Tokens)
        {
            var doKeyword = Tokens.NextNoTrivia(TokenType.DoKeyword, Log);
            var body = ParseStatement(Tokens);
            var whileKeyword = Tokens.NextNoTrivia(TokenType.WhileKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            return new DoWhileSyntax(doKeyword, body, whileKeyword, leadingParen, expr, trailingParen);
        }

        #endregion

        #region ParseForSyntax

        protected virtual IStatementSyntax ParseForSyntax(ITokenStream Tokens)
        {
            var forKeyword = Tokens.NextNoTrivia(TokenType.ForKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            var initStatement = ParseStatement(Tokens); //ParseDeclarationSyntax(Tokens);
            var expr = ParseExpression(Tokens);
            Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            var deltaStatement = ParseStatement(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var body = ParseStatement(Tokens);
            return new ForSyntax(forKeyword, leadingParen, initStatement, expr, deltaStatement, trailingParen, body);
        }

        #endregion

        #region ParseForeachSyntax

        #region ParseElementInCollection

        protected virtual ElementInCollectionSyntax ParseElementInCollection(ITokenStream Tokens)
        {
            var variableDecl = ParseDeclarationSyntax(Tokens);
            var inKeyword = Tokens.NextNoTrivia(TokenType.InKeyword, Log);
            var enumerable = ParseExpression(Tokens);
            return new ElementInCollectionSyntax(variableDecl, inKeyword, enumerable);
        }

        #endregion

        protected virtual IStatementSyntax ParseForeachSyntax(ITokenStream Tokens)
        {
            var foreachKeyword = Tokens.NextNoTrivia(TokenType.ForeachKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);

            List<ElementInCollectionSyntax> elems = new List<ElementInCollectionSyntax>();
            elems.Add(ParseElementInCollection(Tokens));
            var peek = Tokens.PeekNoTrivia();
            while (peek.Type == TokenType.Comma)
            {
                Tokens.NextNoTrivia(TokenType.Comma, Log);
                elems.Add(ParseElementInCollection(Tokens));
                peek = Tokens.PeekNoTrivia();
            }

            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var body = ParseStatement(Tokens);
            return new ForeachSyntax(foreachKeyword, leadingParen, elems, trailingParen, body);
        }

        #endregion
        
        #region ParseCatchSyntax
        
        protected virtual CatchSyntax ParseCatchSyntax(ITokenStream Tokens)
        {
        	var keyword = Tokens.NextNoTrivia(TokenType.CatchKeyword, Log);
        	var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
        	var variableDecl = ParseDeclarationSyntax(Tokens);
        	var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
        	var body = ParseStatement(Tokens);
        	return new CatchSyntax(keyword, leadingParen, variableDecl, trailingParen, body);
        }
        
        #endregion
        
        #region ParseFinallySyntax
        
        protected virtual FinallySyntax ParseFinallySyntax(ITokenStream Tokens)
        {
        	var keyword = Tokens.NextNoTrivia(TokenType.FinallyKeyword, Log);
        	var body = ParseStatement(Tokens);
        	return new FinallySyntax(keyword, body);
        }
        
        #endregion
        
        #region ParseTrySyntax
        
        protected virtual IStatementSyntax ParseTrySyntax(ITokenStream Tokens)
        {
        	var tryKeyword = Tokens.NextNoTrivia(TokenType.TryKeyword, Log);
        	var tryBody = ParseStatement(Tokens);
        	FinallySyntax finallyClause = null;
        	List<CatchSyntax> catchClauses = new List<CatchSyntax>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type == TokenType.CatchKeyword || peek.Type == TokenType.FinallyKeyword)
        	{
        		if (peek.Type == TokenType.CatchKeyword)
        		{
        			catchClauses.Add(ParseCatchSyntax(Tokens));
        		}
        		else if (peek.Type == TokenType.FinallyKeyword)
        		{
        			if (finallyClause != null)
        			{
        				Log.LogError(new LogEntry("Invalid syntax", "A try/catch/finally statement has multiple finally clauses."));
        			}
        			finallyClause = ParseFinallySyntax(Tokens);
        		}
        		peek = Tokens.PeekNoTrivia();
        	}
        	return new TrySyntax(tryKeyword, tryBody, finallyClause, catchClauses);
        }
        
        #endregion

        #endregion
        
        #region Structure Parsing
        
        #region Attribute Parsing

        public virtual IAttributeSyntax ParseAttribute(ITokenStream Tokens)
        {
            var openingToken = Tokens.NextNoTrivia(TokenType.RBrackets, Log);
            var expr = (IInvocationSyntax)ParseNewObjectExpression(Token.Undefined, Tokens);
            var closingToken = Tokens.NextNoTrivia(TokenType.LBrackets, Log);
            return new AttributeSyntax(openingToken, expr, closingToken);
        }

        public virtual IEnumerable<IAttributeSyntax> ParseAttributes(ITokenStream Tokens)
        {
            List<IAttributeSyntax> attrs = new List<IAttributeSyntax>();
            while (Tokens.PeekNoTrivia().Type == TokenType.RBrackets)
            {
                attrs.Add(ParseAttribute(Tokens));
            }
            return attrs;
        }
        
        protected virtual bool PeekIsUnambiguousAttribute(ITokenStream Tokens)
        {
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type != TokenType.RBrackets)
        	{
        		return false;
        	}
        	var pos = peek.Identifier;
        	var type = PeekEntireType(Tokens, &pos);
        	int parseCount = type.Tokens.Count;
        	
        	if (parseCount == 0)
        		return false;
        	
            // Skip all tokens in the type, and skip one extra token for the leading RBrackets
            for (int i = 0; i < parseCount + 1; i++)
        	{
        		peek = Tokens.PeekNoTrivia(peek);
        	}
        	
        	if (peek.Type == TokenType.RParen)
        		return true; // Constructor syntax, i.e. [Attribute()]. This is, unambiguously, an attribute.
        	if (peek.Type != TokenType.LBrackets)
        		return false; // Not an attribute
        	
        	peek = Tokens.PeekNoTrivia(peek);
        	
        	if (peek.Type == TokenType.Identifier) // [T] SomeMethod() --> [T] is not an attribute, because it is trailed by an identifier
        	{
        		return false; // Parse [T] as an enumerable
        	}
        	else if (peek.Type == TokenType.ThisKeyword)
        	{
        		// 'this' is tricky:
        		// [T] this() --> attribute
        		// [T] this[int Index] --> enumerable
        		
        		peek = Tokens.PeekNoTrivia(peek); // One last lookahead
        		
        		return peek.Type != TokenType.RBrackets; // [T] this[int Index] syntax
        	}
        	else
        	{
        		return true; // The syntax was matched to be that of an attribute, and was not trailed by an enumerator
        	}
        }
        
        /// <summary>
        /// Parses a list of attributes that may or may not be trailed by an enumerator, which uses the same syntax.
        /// </summary>
        public virtual IEnumerable<IAttributeSyntax> ParseAmbiguousAttributes(ITokenStream Tokens)
        {
            List<IAttributeSyntax> attrs = new List<IAttributeSyntax>();
            while (PeekIsUnambiguousAttribute(Tokens))
            {
                attrs.Add(ParseAttribute(Tokens));
            }
            return attrs;
        }

        #endregion
        
        #region ParseGenericParameters

        protected IEnumerable<IGenericParameterDeclarationSyntax> ParseGenericParameters(ITokenStream Tokens)
        {
            if (Tokens.PeekNoTrivia().Type != TokenType.LessThan)
            {
                return new IGenericParameterDeclarationSyntax[0];
            }

            List<IGenericParameterDeclarationSyntax> syntaxGroup = new List<IGenericParameterDeclarationSyntax>();
            Tokens.NextNoTrivia(TokenType.LessThan, Log);

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type != TokenType.GreaterThan)
            {
                List<Token> genericParameterTokens = new List<Token>();
                while (peek.Type != TokenType.Comma && peek.Type != TokenType.GreaterThan)
                {
                    genericParameterTokens.Add(Tokens.NextNoTrivia());
                    peek = Tokens.PeekNoTrivia();
                }
                if (peek.Type == TokenType.Comma)
                {
                    Tokens.NextNoTrivia(TokenType.Comma, Log);
                    peek = Tokens.PeekNoTrivia();
                }

                GenericParameterDeclarationSyntax syntax = new GenericParameterDeclarationSyntax(Enumerable.Take<Token>(genericParameterTokens, genericParameterTokens.Count - 1), Enumerable.Last<Token>(genericParameterTokens));
                syntaxGroup.Add(syntax);
            }

            Tokens.NextNoTrivia(TokenType.GreaterThan, Log);
            return syntaxGroup;
        }

        #endregion
        
        #region ParseGenericConstraints

        protected virtual [GenericConstraintSyntax] ParseGenericConstraints(ITokenStream Tokens)
        {
            List<GenericConstraintSyntax> constraints = new List<GenericConstraintSyntax>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type == TokenType.WhereKeyword)
            {
                var whereKeyword = Tokens.NextNoTrivia();
                var identifier = Tokens.NextNoTrivia(TokenType.Identifier, Log);
                var genericColon = Tokens.NextNoTrivia(TokenType.Colon, Log);
                var genericBaseTypes = ParseTypeList(Tokens);

                constraints.Add(new GenericConstraintSyntax(whereKeyword, identifier, genericColon, genericBaseTypes));
                
                peek = Tokens.PeekNoTrivia();
            }
            return constraints;
        }

        #endregion
        
        #region ParsePreconditions
        
        protected virtual PreconditionSyntax ParsePrecondition(ITokenStream Tokens)
        {
            var inKeyword = Tokens.NextNoTrivia(TokenType.InKeyword, Log);
            var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
            var cond = ParseExpression(Tokens);
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new PreconditionSyntax(inKeyword, leadingBraces, cond, trailingBraces);
        }
        
        #endregion
        
        #region ParsePostconditions
        
        protected virtual PostconditionSyntax ParsePostcondition(ITokenStream Tokens)
        {
            var outKeyword = Tokens.NextNoTrivia(TokenType.OutKeyword, Log);
            
            Token leadingParen = null;
            Token identifier = null;
            Token trailingParen = null;
            if (Tokens.PeekNoTrivia().Type == TokenType.RParen)
            {
	            leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
	            identifier = Tokens.NextNoTrivia(TokenType.Identifier, Log); 
	            trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            }
            
            var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
            var cond = ParseExpression(Tokens);
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new PostconditionSyntax(outKeyword, leadingParen, identifier, trailingParen, leadingBraces, cond, trailingBraces);
        }
        
        #endregion
        
        #region ParseMethodContract
        
        protected virtual MethodContract ParseMethodContract(ITokenStream Tokens)
        {
        	List<PreconditionSyntax> pres = new List<PreconditionSyntax>();
        	List<PostconditionSyntax> posts = new List<PostconditionSyntax>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type == TokenType.OutKeyword || peek.Type == TokenType.InKeyword)
            {
            	if (peek.Type == TokenType.InKeyword)
            	{
            		pres.Add(ParsePrecondition(Tokens));
            	}
            	else
            	{
            		posts.Add(ParsePostcondition(Tokens));
            	}
            	
                peek = Tokens.PeekNoTrivia();
            }
            
            return new MethodContract(pres, posts);
        }
        
        #endregion
        
        #region ParseParameter

        protected virtual IMemberSyntax<IParameter> ParseParameter(ITokenStream Tokens)
        {
            ParameterSyntax syntax = new ParameterSyntax(ParseCommonSignatureSyntax(Tokens));
            return syntax;
        }

        #endregion

        #region ParseParameterList

        protected virtual IEnumerable<IMemberSyntax<IParameter>> ParseParameterList(ITokenStream Tokens, TokenType LeftDelimiter, TokenType RightDelimiter)
        {
            Tokens.NextNoTrivia(LeftDelimiter, Log);

            List<IMemberSyntax<IParameter>> parameters = new List<IMemberSyntax<IParameter>>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type != RightDelimiter)
            {
                var syntax = ParseParameter(Tokens);
                parameters.Add(syntax);

                peek = Tokens.PeekNoTrivia();
                if (peek.Type == TokenType.Comma)
                {
                    Tokens.NextNoTrivia(TokenType.Comma, Log);
                    peek = Tokens.PeekNoTrivia();
                }
                else
                {
                    break;
                }
            }

            Tokens.NextNoTrivia(RightDelimiter, Log);

            return parameters;
        }

        #endregion

        #region ParseTypeList

        protected virtual IEnumerable<ITypeSyntax> ParseTypeList(ITokenStream Tokens)
        {
            List<ITypeSyntax> baseTypes = new List<ITypeSyntax>();
            while (true)
            {
                baseTypes.Add(ParseType(Tokens));
                var peek = Tokens.PeekNoTrivia();
                if (peek.Type == TokenType.Comma)
                {
                    Tokens.NextNoTrivia();
                }
                else
                {
                    break;
                }
            }
            return baseTypes;
        }

        #endregion
        
        #region ParseCommonSignatureSyntax
        
        private bool IsConstructorSyntaxIdentifier(Token LastToken, ITokenStream Tokens)
        {
        	if (LastToken != default(Token))
        	if (LastToken.Type == TokenType.ThisKeyword && Tokens.PeekNoTrivia().Type == TokenType.RParen)
        		return true;
        	return false;
        }
        
        protected virtual ISignatureSyntax ParseCommonSignatureSyntax(ITokenStream Tokens)
        {
            var attrs = ParseAmbiguousAttributes(Tokens);

            bool typeDef = false;

            List<Token> modifierTokens = new List<Token>();
            while (Tokens.PeekNoTrivia().Type.IsModifier())
            {
                var token = Tokens.NextNoTrivia();
                if (token.Type.IsTypeKindToken())
                {
                    typeDef = true;
                }
                modifierTokens.Add(token);
            }
            var lastToken = Enumerable.LastOrDefault<Token>(modifierTokens);
            if (IsConstructorSyntaxIdentifier(lastToken, Tokens)) // ctor
            {
                return new ConstructorSignatureSyntax(attrs, Enumerable.Take<Token>(modifierTokens, modifierTokens.Count - 1), lastToken);
            }
            else if (typeDef) // type def
            {
                var name = Tokens.NextNoTrivia(TokenType.Identifier, Log);
                var genericParams = ParseGenericParameters(Tokens);
                return new SignatureSyntax(attrs, modifierTokens, null, name, genericParams);
            }
            else
            {
                var type = ParseType(Tokens);
                var name = Tokens.NextNoTrivia();
                if (name.Type == TokenType.OperatorKeyword)
                {
                	var op = Tokens.NextNoTrivia();
                	return new OperatorSignatureSyntax(attrs, modifierTokens, type, name, op);
                }
                else
                {
	                var genericParams = ParseGenericParameters(Tokens);
	                return new SignatureSyntax(attrs, modifierTokens, type, name, genericParams);
                }
            }
        }

        #endregion
        
        #region Field Parsing

        protected virtual IMemberSyntax<IField> ParseField(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            if (Tokens.PeekNoTrivia().Type == TokenType.Equals)
            {
                var equality = Tokens.NextNoTrivia(TokenType.Equals, Log);
                var expr = ParseExpression(Tokens);
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new FieldSyntax(Signature, equality, expr, semicolon);
            }
            else
            {
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new FieldSyntax(Signature, semicolon);
            }
        }

        #endregion

        #region Enum Literal Parsing

        protected virtual IMemberSyntax<IField> ParseEnumLiteral(ITokenStream Tokens)
        {
            Token ident = Tokens.NextNoTrivia();
            Token assignmentOperator;
            IExpressionSyntax expr;
            if (Tokens.PeekNoTrivia().Type == TokenType.Equals)
            {
                assignmentOperator = Tokens.NextNoTrivia();
                expr = ParseExpression(Tokens);
            }
            else
            {
                assignmentOperator = Token.Undefined;
                expr = null;
            }
            Token comma;
            if (Tokens.PeekNoTrivia().Type == TokenType.Comma)
            {
                comma = Tokens.NextNoTrivia();
            }
            else
            {
                comma = Token.Undefined;
            }
            return new EnumLiteralSyntax(ident, assignmentOperator, expr, comma);
        }

        #endregion

        #region Method Parsing

        protected virtual IMemberSyntax<IMethod> ParseMethod(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            var parameters = ParseParameterList(Tokens, TokenType.RParen, TokenType.LParen);

            [ITypeMemberAccessSyntax] implementedProperties;
            if (Tokens.PeekNoTrivia().Type == TokenType.Colon)
            {
                List<ITypeMemberAccessSyntax> implProps = new List<ITypeMemberAccessSyntax>();
                do
                {
                    Tokens.NextNoTrivia();
                    implProps.Add((ITypeMemberAccessSyntax)ParseExpression(Tokens));
                } while (Tokens.PeekNoTrivia().Type == TokenType.Comma);
                implementedProperties = implProps;
            }
            else
            {
                implementedProperties = new ITypeMemberAccessSyntax[0];
            }

            var constraints = ParseGenericConstraints(Tokens);
            var contract = ParseMethodContract(Tokens);
            
            IStatementSyntax body = ParseStatement(Tokens);

            return new MethodSyntax(Signature, parameters, implementedProperties, constraints, contract, body);
        }

        #endregion

        #region Accessor Parsing

        protected virtual IAccessorSyntax ParseAccessor(ITokenStream Tokens)
        {
            var attrs = ParseAttributes(Tokens);

            List<Token> modifierTokens = new List<Token>();
            var peek = Tokens.PeekNoTrivia().TokenPeek;
            while (!AccessorSignatureSyntax.IsAccessorName(peek) && peek.Type.IsModifier())
            {
                modifierTokens.Add(Tokens.NextNoTrivia());
                peek = Tokens.PeekNoTrivia().TokenPeek;
            }
            
            if (!AccessorSignatureSyntax.IsAccessorName(peek))
            {
            	Log.LogError(new LogEntry("Parser error", "Invalid accessor syntax. Expected valid accessor name, got '" + peek.ToString() + "'"));
            	return null;
            }

            Token nameToken = Tokens.NextNoTrivia();
            AccessorSignatureSyntax signature = new AccessorSignatureSyntax(attrs, modifierTokens, nameToken);
            var contract = ParseMethodContract(Tokens);
            
            IStatementSyntax body = ParseStatement(Tokens);
            
            return new AccessorSyntax(signature, contract, body);
        }

        #endregion
        
        #region Property Parsing

        protected virtual IMemberSyntax<ITypeMember> ParseProperty(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            IEnumerable<IMemberSyntax<IParameter>> parameters;
            if (Tokens.PeekNoTrivia().Type == TokenType.RBrackets)
            {
                parameters = ParseParameterList(Tokens, TokenType.RBrackets, TokenType.LBrackets);
            }
            else
            {
                parameters = new List<IMemberSyntax<IParameter>>();
            }

            IEnumerable<ITypeMemberAccessSyntax> implementedProperties;
            if (Tokens.PeekNoTrivia().Type == TokenType.Colon)
            {
                List<ITypeMemberAccessSyntax> implProps = new List<ITypeMemberAccessSyntax>();
                do
                {
                    Tokens.NextNoTrivia();
                    implProps.Add((ITypeMemberAccessSyntax)ParseExpression(Tokens));
                } while (Tokens.PeekNoTrivia().Type == TokenType.Comma);
                implementedProperties = implProps;
            }
            else
            {
                implementedProperties = new ITypeMemberAccessSyntax[0];
            }

            Tokens.NextNoTrivia(TokenType.RBraces, Log);

            List<IAccessorSyntax> accessors = new List<IAccessorSyntax>();

            while (Tokens.PeekNoTrivia().Type != TokenType.LBraces)
            {
                accessors.Add(ParseAccessor(Tokens));
            }

            Tokens.NextNoTrivia(TokenType.LBraces, Log);

            var syntax = new PropertySyntax(Signature, accessors, parameters, implementedProperties);
            if (syntax.IsFieldProperty)
            {
                return new FieldPropertySyntax(syntax);
            }
            else
            {
                return syntax;
            }
        }

        #endregion
        
        #region Member Parsing

        protected virtual IMemberSyntax<IMember> ParseMember(ITokenStream Tokens)
        {
            var commonSig = ParseCommonSignatureSyntax(Tokens);

			bool isTypeDecl = false;
			foreach (var item in commonSig.ModifierTokens)
			{
				if (item.Type.IsTypeKindToken())
				{
					isTypeDecl = true;
					break;					
				}
			}
            if (isTypeDecl)
            {
                return (IMemberSyntax<IType>)ParseTypeDeclaration(Tokens, commonSig);
            }
            else
            {
                var peek = Tokens.PeekNoTrivia();

                if (peek.Type == TokenType.RParen)
                {
                    return ParseMethod(Tokens, commonSig);
                }
                else if (peek.Type == TokenType.RBraces || peek.Type == TokenType.RBrackets || peek.Type == TokenType.Colon)
                {
                    return ParseProperty(Tokens, commonSig);
                }
                else
                {
                    return ParseField(Tokens, commonSig);
                }
            }
        }

        #endregion
        
        #region Type Declaration Parsing

        protected virtual ITypeDeclarationSyntax ParseTypeDeclaration(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            var peek = Tokens.PeekNoTrivia();

            Token colon;
            IEnumerable<ITypeSyntax> baseTypes;

            if (peek.Type == TokenType.Colon)
            {
                colon = Tokens.NextNoTrivia();
                baseTypes = ParseTypeList(Tokens);
            }
            else
            {
                colon = Token.Undefined;
                baseTypes = (IEnumerable<ITypeSyntax>)new ITypeSyntax[0];
            }

            var constraints = ParseGenericConstraints(Tokens);

            TypeSignatureSyntax typeSig = new TypeSignatureSyntax(Signature, colon, baseTypes, constraints);

            Tokens.NextNoTrivia(TokenType.RBraces, Log);

			bool isEnum = false;
			foreach (var item in Signature.ModifierTokens)
			{
				if (item.Type == TokenType.EnumKeyword)
				{
					isEnum = true;
					break;
				}
			}

            List<IMemberSyntax<IMember>> members = new List<IMemberSyntax<IMember>>();

            peek = Tokens.PeekNoTrivia();
            while (peek.Type != TokenType.LBraces)
            {
                if (isEnum)
                {
                    members.Add(ParseEnumLiteral(Tokens));
                }
                else
                {
                    members.Add(ParseMember(Tokens));
                }
                peek = Tokens.PeekNoTrivia();
            }

            Tokens.NextNoTrivia(TokenType.LBraces, Log);

            TypeDeclarationSyntax syntax = new TypeDeclarationSyntax(typeSig, members);

            return syntax;
        }

        public virtual ITypeDeclarationSyntax ParseTypeDeclaration(ITokenStream Tokens)
        {
            return ParseTypeDeclaration(Tokens, ParseCommonSignatureSyntax(Tokens));
        }

        #endregion
        
        public virtual IBinderDirectiveSyntax ParseUsingSyntax(ITokenStream Tokens)
        {
        	var usingKeyword = Tokens.NextNoTrivia(TokenType.UsingKeyword, Log);
            List<Token> name = new List<Token>();
            Token token = Tokens.NextNoTrivia();
            while (token.Type != TokenType.Semicolon && token.Type != TokenType.Equals && token.Type != TokenType.EndOfFile)
            {
                name.Add(token);
                token = Tokens.NextNoTrivia();
            }
            if (token.Type == TokenType.Equals)
            {
                Token endToken = Tokens.NextNoTrivia();
                List<Token> mapped = new List<Token>();
                while (endToken.Type != TokenType.Semicolon && endToken.Type != TokenType.EndOfFile)
                {
                    mapped.Add(endToken);
                    endToken = Tokens.NextNoTrivia();
                }
                endToken.EnsureType(TokenType.Semicolon, Log);
                return new UsingMapSyntax(usingKeyword, name, token, mapped, endToken);
            }
            else
            {
                return new UsingSyntax(usingKeyword, name, token);
            }
        }
        
        public NamespaceCompilationUnit ParseNamespaceSyntax(ITokenStream Tokens)
        {
            var nsKeyword = Tokens.NextNoTrivia(TokenType.NamespaceKeyword, Log);
            List<Token> nameTokens = new List<Token>();
            nameTokens.Add(Tokens.NextNoTrivia());
            while (Tokens.PeekNoTrivia().Type == TokenType.Dot)
            {
                nameTokens.Add(Tokens.NextNoTrivia(TokenType.Dot, Log));
                nameTokens.Add(Tokens.NextNoTrivia());
            }
            var rBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);

			var peek = Tokens.PeekNoTrivia();
			List<ISyntaxNode> contents = new List<ISyntaxNode>();
			while (peek.Type != TokenType.LBraces && peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED)
			{
				contents.Add(ParseCompilationUnitChild(Tokens));
				peek = Tokens.PeekNoTrivia();
			}

            var lBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);
            
            return new NamespaceCompilationUnit(nsKeyword, nameTokens.ToArray(), rBraces, contents.ToArray(), lBraces);
        }
        
        public virtual ISyntaxNode ParseCompilationUnitChild(ITokenStream Tokens)
        {
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type == TokenType.UsingKeyword)
        	{
        		return ParseUsingSyntax(Tokens);
        	}
        	else if (peek.Type == TokenType.NamespaceKeyword)
        	{
        		return ParseNamespaceSyntax(Tokens);
        	}
        	else
        	{
        		return ParseTypeDeclaration(Tokens);
        	}
        }
        
        public virtual CompilationUnit ParseCompilationUnit(ITokenStream Tokens)
        {
        	var children = new List<ISyntaxNode>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED && peek.Type != TokenType.LBraces)
        	{
        		children.Add(ParseCompilationUnitChild(Tokens));
        		peek = Tokens.PeekNoTrivia();
        	}
        	return new CompilationUnit(children.ToArray());
        }
        
        #endregion
	}
}