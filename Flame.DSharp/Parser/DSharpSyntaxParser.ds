using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.DSharp.Build;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;
using Pixie;

namespace Flame.DSharp.Parser
{
	/// <summary>
	/// The D# syntax parser.
	/// </summary>
	/// <remarks>
	/// This is where the magic happens.
	/// </remarks>
	public virtual class DSharpSyntaxParser
	{
		public this(set ICompilerLog Log);

		public ICompilerLog Log { const get; private set; }

		#region ParseExpression

        public virtual IExpressionSyntax ParseExpression(ITokenStream Tokens)
        {
            var firstExpr = ParseSingleExpression(Tokens);
            var peek = Tokens.PeekNoTrivia();
            if (peek.TokenPeek.Type.IsBinaryExpressionToken())
            {
                return ParseBinaryExpression(firstExpr, Tokens, int32.MaxValue);
            }
            else
            {
                return firstExpr;
            }
        }

        protected virtual IExpressionSyntax ParseSafeExpression(ITokenStream Tokens)
        {
            /*IExpressionSyntax syntax;
            try
            {
                syntax = ParseExpression(Tokens);
            }
            catch (Exception)
            {
                syntax = null;
            }
            return syntax;*/
            return ParseExpression(Tokens); // All expressions should be safe now.
        }

        #endregion

        #region ParseSingleExpression

        protected virtual IExpressionSyntax ParseSingleExpression(ITokenStream Parser)
        {
			var inlineDecl = ParseInlineDeclarationSyntax(Parser);
        	if (!object.ReferenceEquals(inlineDecl, null))
        	{
        		return inlineDecl;
        	}
        	else
        	{
	            var token = Parser.NextNoTrivia();
	            IExpressionSyntax expr;
	            if (token.Type == TokenType.Identifier)
	            {
	                expr = new IdentifierSyntax(token);
	            }
	            else if (token.Type == TokenType.ThisKeyword)
	            {
	                expr = new ThisSyntax(token);
	            }
	            else if (token.Type == TokenType.NullKeyword)
	            {
	                expr = new NullSyntax(token);
	            }
	            else if (token.Type == TokenType.HashKeyword)
	            {
	            	expr = ParseHashExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.NewKeyword)
	            {
	                expr = ParseNewObjectExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.DefaultKeyword)
	            {
	                expr = ParseDefaultValueExpression(token, Parser);
	            }
	            else if (token.Type.IsValueToken())
	            {
	                expr = GetValue(token);
	            }
	            else if (token.Type.IsPrefixUnaryToken())
	            {
	                expr = ParsePrefixedExpression(token, Parser);
	            }
	            else if (token.Type == TokenType.RParen)
	            {
	                expr = ParseParenthesesExpression(Parser);
	            }
	            else
	            {
	                Log.LogError(new LogEntry("Parser error", "Could not identify token '" + token.TokenValue + "' as valid expression syntax.", token.Location));
	                return null;
	            }
	            return ParseIdentifierExpression(expr, Parser);
            }
        }

        #endregion

        #region Type Parsing

        #region Peek Array Type Shred

        protected virtual ITokenTypeSyntax PeekArrayTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, bool AllowDelegates, TokenIdentifier^ Position)
        {
        	var leading = Tokens.PeekNoTrivia(*Position);
            if (leading.Type != TokenType.RBrackets)
            {
                return null;
            }
            else
            {
            	var peek = leading;
            	List<Token> commas = new List<Token>();
            	List<IExpressionSyntax> exprs = new List<IExpressionSyntax>();
                do
                {
                    *Position = peek.Identifier;
                    peek = Tokens.PeekNoTrivia(*Position);
                    if (peek.Type == TokenType.Integer) // Vector type.
                    {
                    	exprs.Add(new IntegerSyntax(peek.TokenPeek));
                        peek = Tokens.PeekNoTrivia(peek);
                    }
                    if (peek.Type == TokenType.Comma)
                    {
                    	commas.Add(peek.TokenPeek);
                    }
                    else if (peek.Type != TokenType.LBrackets)
                    {
                        return null;
                    }
                } while (peek.Type == TokenType.Comma)
                if (peek.Type == TokenType.LBrackets)
                {
                	*Position = peek.Identifier;
                	ITokenTypeSyntax type;
                	if (exprs.Count == 0)
                	{
                		type = new ArrayTypeSyntax(ElementType, leading.TokenPeek, commas, peek.TokenPeek);
                	}
                	else
                	{
                		type = new VectorTypeSyntax(ElementType, leading.TokenPeek, new SeparatedList<IExpressionSyntax>(exprs, commas), peek.TokenPeek);
	                	if (exprs.Count - 1 != commas.Count)
	                	{
	                		// State.Log.LogError(new LogEntry("Type parsing error", "Type '" + type.GetCode().ToString() + "' is neither a vector nor an array type"));
	                		return null;
	                	}
                	}

                    var nextShred = PeekTypeShred(Tokens, type, AllowDelegates, Position);
                    if (nextShred == null)
                    	return type;
                    else
                    	return nextShred;
                }
                else
                {
                    return null;
                }
            }
        }

        #endregion

        #region Peek Generic Type Shred

		protected virtual DelimitedList<ITokenTypeSyntax> PeekTypeList(ITokenStream Tokens,
			TokenType LeftDelimiter, TokenType RightDelimiter, TokenIdentifier^ Position)
		{
			var leading = Tokens.PeekNoTrivia(*Position);
			if (leading.Type != LeftDelimiter)
			{
				return null;
			}
			else
			{
				*Position = leading.Identifier;

				var peek = Tokens.PeekNoTrivia(leading);
				var typeArgs = new List<SeparatedItem<ITokenTypeSyntax>>();
				while (peek.Type != RightDelimiter && peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED)
				{
					var arg = PeekEntireType(Tokens, true, Position);
					if (arg == null)
					{
						return null;
					}
					if (peek.Type == TokenType.Comma)
					{
						typeArgs.Add(new SeparatedItem<ITokenTypeSyntax>(peek.TokenPeek, arg));
					}
					else
					{
						typeArgs.Add(new SeparatedItem<ITokenTypeSyntax>(arg));
					}
					peek = Tokens.PeekNoTrivia(*Position);
					*Position = peek.Identifier;

					if (peek.Type != TokenType.Comma)
						break;
				}
				if (peek.Type == RightDelimiter)
				{
					*Position = peek.Identifier;

					return new DelimitedList<ITokenTypeSyntax>(leading.TokenPeek, new SeparatedList<ITokenTypeSyntax>(typeArgs), peek.TokenPeek);
				}
				else
				{
					return null;
				}
			}
		}

        protected virtual ITokenTypeSyntax PeekGenericTypeShred(ITokenStream Tokens,
			ITokenTypeSyntax ElementType, bool AllowDelegates, TokenIdentifier^ Position)
        {
			var tList = PeekTypeList(Tokens, TokenType.LessThan, TokenType.GreaterThan, Position);

			if (tList == null) return null;

			var type = new GenericInstanceTypeSyntax(ElementType, tList);

			return PeekTypeShred(Tokens, type, AllowDelegates, Position);
        }

		protected virtual ITokenTypeSyntax PeekDelegateTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, TokenIdentifier^ Position)
		{
			var tList = PeekTypeList(Tokens, TokenType.RParen, TokenType.LParen, Position);

			if (tList == null) return null;

			var type = new DelegateTypeSyntax(ElementType, tList);

			return PeekTypeShred(Tokens, type, true, Position);
		}

        #endregion

        #region Peek Dot Type Shred

        // .identifier
        protected virtual ITokenTypeSyntax PeekDotTypeShred(ITokenStream Tokens,
			ITokenTypeSyntax ElementType, bool AllowDelegates, TokenIdentifier^ Position)
        {
            var dotPeek = Tokens.PeekNoTrivia(*Position);
            if (dotPeek.Type != TokenType.Dot)
            {
                return null;
            }
            var identifierPeek = Tokens.PeekNoTrivia(dotPeek);
            if (identifierPeek.Type != TokenType.Identifier)
            {
                return null;
            }
            var type = new DotTypeSyntax(ElementType, dotPeek.TokenPeek, identifierPeek.TokenPeek);
            *Position = identifierPeek.Identifier;
            var nextType = PeekTypeShred(Tokens, type, AllowDelegates, Position);
            if (nextType == null)
            	return type;
            else
            	return nextType;
        }

        #endregion

        #region Peek Type Shred

        protected virtual ITokenTypeSyntax PeekEnumerableTypeShredCore(ITokenStream Tokens, TokenIdentifier^ Position)
        {
        	var leadingPeek = Tokens.PeekNoTrivia(*Position);
        	int count = 1;
            if (leadingPeek.Type != TokenType.RBrackets)
            {
                return null;
            }
            *Position = leadingPeek.Identifier;

            var leadingLessThanPeek = Tokens.PeekNoTrivia(leadingPeek);
            if (leadingLessThanPeek.Type == TokenType.LessThan)
            {
            	*Position = leadingLessThanPeek.Identifier;
            	var elemType = PeekEntireType(Tokens, true, Position);
            	var trailingGreaterThanPeek = Tokens.PeekNoTrivia(*Position);
            	if (trailingGreaterThanPeek.Type != TokenType.GreaterThan)
            	{
            		return null;
            	}
            	var trailingPeek = Tokens.PeekNoTrivia(trailingGreaterThanPeek);
            	if (trailingPeek.Type != TokenType.LBrackets)
            	{
            		return null;
            	}
            	*Position = trailingPeek.Identifier;
            	return new EnumeratorTypeSyntax(leadingPeek.TokenPeek, leadingLessThanPeek.TokenPeek, elemType, trailingGreaterThanPeek.TokenPeek, trailingPeek.TokenPeek);
            }
            else
            {
            	var elemType = PeekEntireType(Tokens, true, Position);
            	var trailingPeek = Tokens.PeekNoTrivia(*Position);
            	if (trailingPeek.Type != TokenType.LBrackets)
            	{
            		return null;
            	}
            	*Position = trailingPeek.Identifier;
            	return new EnumerableTypeSyntax(leadingPeek.TokenPeek, elemType, trailingPeek.TokenPeek);
            }
        }

		protected virtual ITokenTypeSyntax PeekEnumerableTypeShred(ITokenStream Tokens, bool AllowDelegates, TokenIdentifier^ Position)
		{
			var shred = PeekEnumerableTypeShredCore(Tokens, Position);
			if (shred == null)
				return null;
			else if (AllowDelegates && Tokens.PeekNoTrivia(*Position).Type == TokenType.RParen)
				return PeekDelegateTypeShred(Tokens, shred, Position);
			else
				return shred;
		}

        #endregion

        #region Peek Entire Type

        public virtual ITokenTypeSyntax PeekEntireType(ITokenStream Tokens, bool AllowDelegates, TokenIdentifier^ Position)
        {
        	var peek = Tokens.PeekNoTrivia(*Position);
        	if (peek.Type == TokenType.VarKeyword)
        	{
        		*Position = peek.Identifier;
        		return new InferredTypeSyntax(peek.TokenPeek);
        	}
        	else if (peek.Type == TokenType.Identifier)
            {
                return PeekIdentifierTypeShred(Tokens, AllowDelegates, Position);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
            	return PeekEnumerableTypeShred(Tokens, AllowDelegates, Position);
            }
            else
            {
				return null;
            }
        }

        public virtual ITokenTypeSyntax PeekEntireType(ITokenStream Tokens, bool AllowDelegates)
        {
            TokenIdentifier pos = Tokens.CurrentPosition;
            return PeekEntireType(Tokens, AllowDelegates, &pos);
        }

        #endregion

        #region Peek Type Identifier Shred

        protected virtual ITokenTypeSyntax PeekIdentifierTypeShred(ITokenStream Tokens, bool AllowDelegates, TokenIdentifier^ Position)
        {
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.VarKeyword)
            {
            	*Position = peek.Identifier;
            	return new InferredTypeSyntax(peek.TokenPeek);
            }
            else if (peek.Type == TokenType.Identifier)
            {
                *Position = peek.Identifier;
                var identifierSyntax = new IdentifierTypeSyntax(peek.TokenPeek);

                return PeekTypeShred(Tokens, identifierSyntax, AllowDelegates, Position);
            }
            else
            {
				return null;
            }
        }

        #endregion

        #region Peek Type Shred

		protected virtual ITokenTypeSyntax CoalescePeekFailure(TokenIdentifier OldPosition,
			ITokenTypeSyntax ElementType, ITokenTypeSyntax Result, TokenIdentifier^ Position)
		{
			if (Result == null)
			{
				*Position = OldPosition;
				return ElementType;
			}
			else
			{
				return Result;
			}
		}

        protected virtual ITokenTypeSyntax PeekTypeShred(ITokenStream Tokens, ITokenTypeSyntax ElementType, bool AllowDelegates, TokenIdentifier^ Position)
        {
			var oldPos = *Position;
            var peek = Tokens.PeekNoTrivia(*Position);
            if (peek.Type == TokenType.LessThan)
            {
                return CoalescePeekFailure(oldPos, ElementType,
					PeekGenericTypeShred(Tokens, ElementType, AllowDelegates, Position),
					Position);
            }
			else if (AllowDelegates && peek.Type == TokenType.RParen)
			{
				return CoalescePeekFailure(oldPos, ElementType,
					PeekDelegateTypeShred(Tokens, ElementType, Position),
					Position);
			}
            else if (peek.Type == TokenType.RBrackets)
            {
				return CoalescePeekFailure(oldPos, ElementType,
					PeekArrayTypeShred(Tokens, ElementType, AllowDelegates, Position),
					Position);
            }
            else if (peek.Type == TokenType.Dot)
            {
				return CoalescePeekFailure(oldPos, ElementType,
					PeekDotTypeShred(Tokens, ElementType, AllowDelegates, Position),
					Position);
            }
            else if (peek.Type == TokenType.Asterisk || peek.Type == TokenType.Caret)
            {
                *Position = peek.Identifier;
                var pointerType = new PointerTypeSyntax(ElementType, peek.TokenPeek);

                var nextType = PeekTypeShred(Tokens, pointerType, AllowDelegates, Position);

                if (nextType == null)
				{
					*Position = oldPos;
                	return pointerType;
				}
                else
				{
                	return nextType;
				}
            }
            else
            {
				*Position = oldPos;
                return ElementType;
            }
        }

        #endregion

        protected virtual [Token] ParseTypeTokens(ITokenStream Tokens)
        {
        	var peekType = PeekEntireType(Tokens, true);

        	if (peekType == null)
        		return new Token[0];

            int parseCount = peekType.Tokens.Count;

            Token[] tokens = new Token[parseCount];

            for (int i = 0; i < parseCount; ++i)
            {
                tokens[i] = Tokens.NextNoTrivia();
            }

            return tokens;
        }

        public virtual ITypeSyntax ToTypeSyntax(ITokenStream Tokens)
        {
            if (Tokens.PeekNoTrivia().Type == TokenType.EndOfFile)
            {
                return null;
            }
            ITypeSyntax tSyntax = ParseType(Tokens);
            if (Tokens.PeekNoTrivia().Type == TokenType.EndOfFile)
            {
                return tSyntax;
            }
            else
            {
                return null;
            }
        }

        public virtual ITypeSyntax ParseType(ITokenStream Tokens, bool AllowDelegates)
        {
            var type = PeekEntireType(Tokens, AllowDelegates);

            if (type == null) // No type was parsed. So be it.
            {
            	return null;
            }

			SkipTypeTokens(Tokens, type);

            return type;
        }

		public virtual ITypeSyntax ParseType(ITokenStream Tokens)
		{
			return ParseType(Tokens, true);
		}

		protected virtual void SkipTypeTokens(ITokenStream Tokens, ITokenTypeSyntax Syntax)
		{
			int parseCount = Syntax.Tokens.Count;

			for (int i = 0; i < parseCount; i++)
			{
				Tokens.NextNoTrivia();
			}
		}

		protected virtual PeekToken PeekTypeTokens(ITokenStream Tokens, ITokenTypeSyntax Syntax)
		{
			var peek = Tokens.PeekNoTrivia();

			int parseCount = Syntax.Tokens.Count;

			for (int i = 0; i < parseCount; i++)
			{
				peek = Tokens.PeekNoTrivia(peek);
			}

			return peek;
		}

        #endregion

        #region Expressions

        #region ParseHashExpression

        protected virtual IExpressionSyntax ParseHashExpression(Token HashKeyword, ITokenStream Parser)
        {
        	var leadingParen = Parser.NextNoTrivia(TokenType.RParen, Log);
        	var expr = ParseExpression(Parser);
        	var trailingParen = Parser.NextNoTrivia(TokenType.LParen, Log);
        	return new HashSyntax(HashKeyword, leadingParen, expr, trailingParen);
        }

        #endregion

        #region ParseParenthesesSyntax

        protected virtual IExpressionSyntax ParseCastExpression(ITypeSyntax Type, ITokenStream Parser)
        {
            var expr = ParseSingleExpression(Parser);
            return new CastSyntax(Type, expr);
        }

        protected virtual IExpressionSyntax ParseParenthesesExpression(ITokenStream Parser)
        {
            var block = Parser.NextBlockContents(TokenType.RParen, TokenType.LParen);

            var tSyntax = ToTypeSyntax(block);
            block.Reset();

            /* This is what the C# spec says about parentheses:
             * To resolve cast-expression ambiguities, the following rule exists: A sequence of one or more tokens (§2.3.3) enclosed in parentheses is considered the start of a cast-expression only if at least one of the following are true:
             *  ⦁	The sequence of tokens is correct grammar for a type, but not for an expression.
             *  ⦁	The sequence of tokens is correct grammar for a type, and the token immediately following the closing parentheses is the token “~”, the token “!”, the token “(”, an identifier (§2.4.1), a literal (§2.4.4), or any keyword (§2.4.3) except as and is.
             */
            if (tSyntax != null) // probably a conversion
            {
                var peek = Parser.PeekNoTrivia();
                if ((peek.Type.IsValueToken() || peek.Type == TokenType.Not || peek.Type == TokenType.Tilde || peek.Type == TokenType.RParen || (peek.Type.IsKeywordToken() && !peek.Type.IsTypeBinaryExpressionToken())))
                {
                    return ParseCastExpression(tSyntax, Parser);
                }
                else
                {
                    var blockExpr = ParseSafeExpression(block);
                    if (blockExpr == null)
                    {
                        return ParseCastExpression(tSyntax, Parser);
                    }
                    else
                    {
                        return blockExpr;
                    }
                }
            }
            else
            {
                return new ParenthesesSyntax(ParseExpression(block));
            }
        }

        #endregion

        #region GetPrecendence

        protected virtual int32 GetPrecedence(TokenType Token)
        {
            if (Token == TokenType.Percent || Token == TokenType.Asterisk || Token == TokenType.Slash)
            {
            	return 0;
            }
            else if (Token == TokenType.Plus || Token == TokenType.Minus)
            {
            	return 1;
            }
            else if (Token == TokenType.LeftShift || Token == TokenType.RightShift)
            {
            	return 2;
            }
            else if (Token == TokenType.EqualsEquals || Token == TokenType.NotEquals)
           	{
           		return 3;
           	}
           	else if (Token == TokenType.GreaterThanOrEquals || Token == TokenType.GreaterThan ||
           			Token == TokenType.LessThanOrEquals || Token == TokenType.LessThan ||
           			Token == TokenType.IsKeyword)
            {
	            return 4;
            }
            else if (Token == TokenType.And)
            {
            	return 5;
            }
            else if (Token == TokenType.Caret)
            {
            	return 6;
            }
            else if (Token == TokenType.Bar)
            {
            	return 7;
            }
            else if (Token == TokenType.AndAnd)
            {
            	return 8;
            }
            else if (Token == TokenType.BarBar)
            {
            	return 9;
            }
            else if (Token == TokenType.Equals || Token == TokenType.AndEquals ||
           			Token == TokenType.BarEquals || Token == TokenType.PercentEquals ||
           			Token == TokenType.CaretEquals || Token == TokenType.PlusEquals ||
           			Token == TokenType.MinusEquals || Token == TokenType.AsteriskEquals ||
           			Token == TokenType.SlashEquals)
            {
	            return 10;
            }
            else
            {
            	return int32.MaxValue;
            }
        }

        #endregion

        #region CreateBinaryExpression

        protected virtual IExpressionSyntax CreateNormalBinaryExpression(IExpressionSyntax A, IExpressionSyntax B, Token Operator)
        {
        	if (Operator.Type == TokenType.AndAnd)
        	{
        		return new LazyAndSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.And)
        	{
        		return new AndSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.BarBar)
        	{
        		return new LazyOrSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Bar)
        	{
        		return new OrSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Caret)
        	{
        		return new XorSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Percent)
        	{
        		return new RemainderSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.EqualsEquals)
        	{
        		return new CheckEqualitySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.NotEquals)
        	{
        		return new CheckInequalitySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.GreaterThanOrEquals)
        	{
        		return new GreaterThanOrEqualsSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.GreaterThan)
        	{
        		return new GreaterThanSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LessThanOrEquals)
        	{
        		return new LessThanOrEqualsSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LessThan)
        	{
        		return new LessThanSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Plus)
        	{
        		return new AddSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Minus)
        	{
        		return new SubtractSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Asterisk)
        	{
        		return new MultiplySyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Slash)
        	{
        		return new DivideSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.RightShift)
        	{
        		return new RightShiftSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.LeftShift)
        	{
        		return new LeftShiftSyntax(A, Operator, B);
        	}
        	else if (Operator.Type == TokenType.Equals || Operator.Type == TokenType.AndEquals || Operator.Type == TokenType.BarEquals ||
        			Operator.Type == TokenType.PercentEquals || Operator.Type == TokenType.CaretEquals || Operator.Type == TokenType.PlusEquals ||
        			Operator.Type == TokenType.MinusEquals || Operator.Type == TokenType.AsteriskEquals || Operator.Type == TokenType.SlashEquals)
        	{
        		return new AssignmentSyntax((IVariableSyntax)A, Operator, B);
        	}
        	else
        	{
        		return null;
        	}
        }

        protected virtual IExpressionSyntax CreateTypeBinaryExpression(IExpressionSyntax A, ITypeSyntax B, Token Operator)
        {
            if (Operator.Type == TokenType.IsKeyword)
            {
                return new IsSyntax(A, Operator, B);
            }
            else
            {
                return null;
            }
        }

        protected virtual IExpressionSyntax CreateBinaryExpression(ISyntaxNode A, ISyntaxNode B, Token Operator)
        {
            if (Operator.Type.IsTypeBinaryExpressionToken())
            {
                return CreateTypeBinaryExpression((IExpressionSyntax)A, (ITypeSyntax)B, Operator);
            }
            else
            {
                return CreateNormalBinaryExpression((IExpressionSyntax)A, (IExpressionSyntax)B, Operator);
            }
        }

        protected virtual IExpressionSyntax CreateBinaryExpression(List<ISyntaxNode> Operands, Token Operator)
        {
            IExpressionSyntax expr = CreateBinaryExpression(Operands[0], Operands[1], Operator);
            for (int i = 2; i < Operands.Count; i++)
            {
                expr = CreateBinaryExpression(expr, Operands[i], Operator);
            }
            return expr;
        }

        #endregion

        #region ParseBinaryExpression

        private static Token PeekOperator(ITokenStream Parser)
        {
        	var peek = Parser.PeekNoTrivia();

        	if (peek.Type == TokenType.GreaterThan)
        	{
        		var peek2 = Parser.Peek(peek);
        		if (peek2.Type == TokenType.GreaterThan)
        		{
        			return peek.TokenPeek.Combine(peek2.TokenPeek, TokenType.RightShift);
        		}
        	}

        	return peek.TokenPeek;
        }

        private static Token ParseOperator(ITokenStream Parser)
        {
        	var op = Parser.NextNoTrivia();

        	if (op.Type == TokenType.GreaterThan)
        	{
        		var peek = Parser.Peek();
        		if (peek.Type == TokenType.GreaterThan)
        		{
        			return op.Combine(Parser.Next(), TokenType.RightShift);
        		}
        	}

        	return op;
        }

        protected IExpressionSyntax ParseBinaryExpression(IExpressionSyntax FirstExpression, ITokenStream Parser, int MaxPrecedence)
        {
            List<ISyntaxNode> operands = new List<ISyntaxNode>();
            Token op = ParseOperator(Parser);
            operands.Add(FirstExpression);
            int currentPrecedence = GetPrecedence(op.Type);
            //var nextOpTokenPeek = PeekNoWhitespaceToken(Parser);
            var nextOpTokenPeek = op;
            do
            {
                if (nextOpTokenPeek.Type == op.Type)
                {
                    if (operands.Count > 1)
                    {
                        ParseOperator(Parser);
                    }
                    if (op.Type.IsTypeBinaryExpressionToken())
                    {
                        operands.Add(ParseType(Parser));
                    }
                    else
                    {
                        operands.Add(ParseSingleExpression(Parser));
                    }
                }
                else
                {
                    int nextPrecedence = GetPrecedence(nextOpTokenPeek.Type);
                    if (nextPrecedence < currentPrecedence)
                    {
                        var lastOperand = operands[operands.Count - 1];
                        operands.RemoveAt(operands.Count - 1);
                        var newExpr = ParseBinaryExpression((IExpressionSyntax)lastOperand, Parser, nextPrecedence);
                        operands.Add(newExpr);
                    }
                    else if (nextPrecedence > MaxPrecedence)
                    {
                        return CreateBinaryExpression(operands, op); // We're done here
                    }
                    else
                    {
                        var currentExpr = CreateBinaryExpression(operands, op);
                        return ParseBinaryExpression(currentExpr, Parser, MaxPrecedence);
                    }
                }
                nextOpTokenPeek = PeekOperator(Parser);
            } while (nextOpTokenPeek.Type.IsBinaryExpressionToken())
            return CreateBinaryExpression(operands, op);
        }

        #endregion

		#region ParseList

		protected virtual SeparatedList<T> ParseSeparatedList<T>(ITokenStream Tokens,
			T(ITokenStream) ParseItem, TokenType Separator)
			where T : ISyntaxNode
		{
			var results = new List<SeparatedItem<T>>();

			do
			{
				Token sep;
				if (results.Count == 0)
					sep = Token.Undefined;
				else
					sep = Tokens.NextNoTrivia(Separator, Log);

				var syntax = ParseItem(Tokens);
				results.Add(new SeparatedItem<T>(sep, syntax));

			} while (Tokens.PeekNoTrivia().Type == Separator)

			return new SeparatedList<T>(results);
		}

		protected virtual SeparatedList<T> ParseListContents<T>(ITokenStream Tokens,
			T(ITokenStream) ParseItem, TokenType RightDelimiter)
			where T : ISyntaxNode
		{
			var args = new List<SeparatedItem<T>>();

			while (Tokens.PeekNoTrivia().Type != RightDelimiter)
			{
				Token comma;

				if (args.Count == 0)
					comma = Token.Undefined;
				else
					comma = Tokens.NextNoTrivia(TokenType.Comma, Log);

				var syntax = ParseItem(Tokens);
				args.Add(new SeparatedItem<T>(comma, syntax));
			}

			return new SeparatedList<T>(args);
		}

		protected virtual DelimitedList<T> ParseDelimitedList<T>(ITokenStream Parser,
			T(ITokenStream) ParseItem, TokenType LeftDelimiter, TokenType RightDelimiter)
			where T : ISyntaxNode
		{
			var rParen = Parser.NextNoTrivia(LeftDelimiter, Log);

			var exprs = ParseListContents<T>(Parser, ParseItem, RightDelimiter);

			var lParen = Parser.NextNoTrivia(RightDelimiter, Log);

			return new DelimitedList<T>(rParen, exprs, lParen);
		}

		#endregion

        #region ParseInvocationExpression

        protected virtual IExpressionSyntax ParseInvocationExpression(ITypeMemberAccessSyntax Caller, ITokenStream Parser)
        {
            var exprs = ParseArgumentList(Parser);

            return new InvocationSyntax(Caller, exprs);
        }

        protected virtual DelimitedList<IExpressionSyntax> ParseArgumentList(ITokenStream Parser, TokenType LeftDelimiter, TokenType RightDelimiter)
        {
			return ParseDelimitedList<IExpressionSyntax>(Parser, ParseExpression, LeftDelimiter, RightDelimiter);
        }

        protected virtual DelimitedList<IExpressionSyntax> ParseArgumentList(ITokenStream Parser)
        {
            return ParseArgumentList(Parser, TokenType.RParen, TokenType.LParen);
        }

        #endregion

        #region ParseDefaultValueExpression

        protected virtual IExpressionSyntax ParseDefaultValueExpression(Token DefaultToken, ITokenStream Tokens)
        {
            if (DefaultToken.EnsureType(TokenType.DefaultKeyword, Log))
            {
	            var rParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
	            var type = ParseType(Tokens);
	            var lParen = Tokens.NextNoTrivia(TokenType.LParen, Log);

	            var expr = new DefaultValueSyntax(DefaultToken, rParen, type, lParen);

	            return expr;
	        }
	        else
	        {
	        	return null;
	        }
        }

        #endregion

        #region ParseNewObjectExpression

        protected virtual IExpressionSyntax ParseNewObjectExpression(Token NewToken, ITokenStream Tokens)
        {
            var type = ParseType(Tokens, false);
            var peek = Tokens.PeekNoTrivia();

            IExpressionSyntax expr;

            if (peek.Type != TokenType.RBrackets)
            {
				DelimitedList<IExpressionSyntax> args;
                if (peek.Type == TokenType.RParen)
                {
                    args = ParseArgumentList(Tokens);
                }
                else
                {
                    args = new DelimitedList<IExpressionSyntax>();
                }
                expr = new NewObjectSyntax(NewToken, type, args);
            }
            else
            {
                var arrayArgs = ParseArgumentList(Tokens, TokenType.RBrackets, TokenType.LBrackets);
                expr = new NewArraySyntax(NewToken, type, arrayArgs);
            }
            if (Tokens.PeekNoTrivia().Type == TokenType.RBraces)
            {
                return ParseInitializedListExpression(expr, Tokens);
            }
            else
            {
                return expr;
            }
        }

        #endregion

        #region ParseInitializedListExpression

        protected virtual IExpressionSyntax ParseInitializedListExpression(IExpressionSyntax List, ITokenStream Tokens)
        {
			var args = ParseArgumentList(Tokens, TokenType.RBraces, TokenType.LBraces);

            return new InitializedListSyntax(List, args);
        }

        #endregion

        #region GetValue

        protected virtual IExpressionSyntax GetValue(Token Token)
        {
            if (Token.Type == TokenType.String)
            {
            	return new StringSyntax(Token);
            }
            else if (Token.Type == TokenType.Char)
            {
            	return new CharSyntax(Token);
            }
            else if (Token.Type == TokenType.Float32)
            {
            	return new Float32Syntax(Token);
            }
            else if (Token.Type == TokenType.Float64)
            {
            	return new Float64Syntax(Token);
            }
            else if (Token.Type == TokenType.HexInteger)
            {
            	return new HexIntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.BinaryInteger)
            {
            	return new BinaryIntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.Identifier)
            {
            	return new IdentifierSyntax(Token);
            }
            else if (Token.Type == TokenType.Integer)
            {
            	return new IntegerSyntax(Token);
            }
            else if (Token.Type == TokenType.TrueLiteral || Token.Type == TokenType.FalseLiteral)
            {
            	return new BooleanSyntax(Token);
            }
            else
            {
            	Log.LogError(new LogEntry("Parser error",
					"Token '" + Token.ToString() +
					"' was mistakenly identified as a literal or could not be parsed.",
					Token.Location));
            	return null;
            }
        }

        #endregion

        #region ParsePrefixedExpression

        protected virtual IExpressionSyntax ParsePrefixedExpression(Token Token, ITokenStream Parser)
        {
            if (Token.Type == TokenType.And)
            {
                var variable = GetVariable(Parser);
                return new AddressOfSyntax(Token, variable);
            }
            else
            {
                IExpressionSyntax InnerExpression = ParseSingleExpression(Parser);
                if (Token.Type == TokenType.Plus)
                {
                	return InnerExpression;
                }
                else if (Token.Type == TokenType.PlusPlus || Token.Type == TokenType.MinusMinus)
                {
                	return new PrefixDeltaSyntax(Token, (IVariableSyntax)InnerExpression);
                }
                else if (Token.Type == TokenType.Minus)
                {
                	return new NegateSyntax(Token, InnerExpression);
                }
                else if (Token.Type == TokenType.Tilde || Token.Type == TokenType.Not)
                {
                	return new NotSyntax(Token, InnerExpression);
                }
                else if (Token.Type == TokenType.Asterisk)
                {
                	return new AtAddressSyntax(Token, InnerExpression);
                }
                else
                {
                	Log.LogError("The token " + Token.ToString() + " was mistakenly identified as an expression prefix or could not be parsed.");
                	return null;
                }
            }
        }

        #endregion

        #region IsGenericTypeArgumentSyntax

        protected virtual bool IsGenericTypeArgumentSyntax(ITokenStream Parser)
        {
            var peek = Parser.PeekNoTrivia();
            if (peek.Type == TokenType.LessThan)
            {
                int blocks = 1;
                while (blocks > 0)
                {
                    peek = Parser.PeekNoTrivia(peek);
                    if (peek.Type == TokenType.LessThan)
                    {
                        blocks++;
                    }
                    else if (peek.Type == TokenType.GreaterThan)
                    {
                        blocks--;
                    }
                    else if (!peek.Type.IsTypeToken())
                    {
                        return false;
                    }
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ParseGenericTypeArgumentExpression

        protected virtual IExpressionSyntax ParseGenericTypeArgumentExpression(ITypeMemberAccessSyntax Target, ITokenStream Tokens)
        {
            List<ITypeSyntax> typeSyntaxGroup = new List<ITypeSyntax>();

            var opener = Tokens.NextNoTrivia(TokenType.LessThan, Log);
            typeSyntaxGroup.Add(ParseType(Tokens));
            while (Tokens.PeekNoTrivia().Type == TokenType.Comma)
            {
                Tokens.NextNoTrivia(TokenType.Comma, Log);
                typeSyntaxGroup.Add(ParseType(Tokens));
            }

            var closer = Tokens.NextNoTrivia(TokenType.GreaterThan, Log);

            return new GenericTypeArgumentsSyntax(Target, opener, typeSyntaxGroup, closer);
        }

        #endregion

        #region ParseIdentifierExpression

        protected virtual IExpressionSyntax ParseIdentifierExpression(Token Identifier, ITokenStream Parser)
        {
            return ParseIdentifierExpression(new IdentifierSyntax(Identifier), Parser);
        }

        protected virtual IExpressionSyntax ParseIdentifierExpression(IExpressionSyntax Expression, ITokenStream Parser)
        {
            var peek = Parser.PeekNoTrivia();
            if (peek.Type == TokenType.Dot || peek.Type == TokenType.RArrow)
            {
                var dot = Parser.NextNoTrivia();
                var secondIdent = Parser.NextNoTrivia();
                secondIdent.EnsureType(TokenType.Identifier, Log);
                IExpressionSyntax accessExpr;
                if (peek.Type == TokenType.RArrow)
                {
                    accessExpr = new AtAddressMemberAccessSyntax(Expression, dot, secondIdent);
                }
                else
                {
                    accessExpr = new MemberAccessSyntax(Expression, dot, secondIdent);
                }
                return ParseIdentifierExpression(accessExpr, Parser);
            }
            else if (peek.Type == TokenType.RParen)
            {
                var invocation = ParseInvocationExpression((ITypeMemberAccessSyntax)Expression, Parser);
                return ParseIdentifierExpression(invocation, Parser);
            }
            else if (peek.Type == TokenType.RBrackets)
            {
                var indexerExpr = ParseIndexedElementVariable(Expression, Parser);
                return ParseIdentifierExpression(indexerExpr, Parser);
            }
            else if (IsGenericTypeArgumentSyntax(Parser))
            {
                var generic = ParseGenericTypeArgumentExpression((ITypeMemberAccessSyntax)Expression, Parser);
                return ParseIdentifierExpression(generic, Parser);
            }
            else if (peek.Type.IsPostfixUnaryToken())
            {
                var postFixExpr = new PostfixDeltaSyntax((IVariableSyntax)Expression, Parser.NextNoTrivia(peek.Type, Log));
                return ParseIdentifierExpression(postFixExpr, Parser);
            }
            else
            {
                return Expression;
            }
        }

        #endregion

        #endregion

        #region Variable Parsing

        #region GetVariable

        protected virtual IVariableSyntax GetVariable(ITokenStream Parser)
        {
            IExpressionSyntax parsedExpr = ParseExpression(Parser);
            return (IVariableSyntax)parsedExpr;
        }

        #endregion

        #region ParseIndexedElementVariable

        protected virtual IVariableSyntax ParseIndexedElementVariable(IExpressionSyntax Caller, ITokenStream Parser)
        {
            var exprs = ParseArgumentList(Parser, TokenType.RBrackets, TokenType.LBrackets);

            return new IndexedElementSyntax(Caller, exprs);
        }

        #endregion

        #endregion

        #region Statement Parsing

        public virtual IStatementSyntax ParseStatement(ITokenStream Tokens)
        {
            var syntax = ParseStatementInternal(Tokens);
            if (syntax == null)
            {
            	return new EmptySyntax();
            }
            else
            {
            	return syntax;
            }
        }

        #region ParseStatementInternal

        protected virtual IStatementSyntax ParseStatementInternal(ITokenStream Tokens)
        {
            var peek = Tokens.PeekNoTrivia();
            var tokenType = peek.TokenPeek.Type;
            if (tokenType == TokenType.EndOfFile)
            	return null;
            else if (tokenType == TokenType.Semicolon)
            	return new EmptySyntax(Tokens.NextNoTrivia());
            else if (tokenType == TokenType.ReturnKeyword)
            	return ParseReturnSyntax(Tokens);
            else if (tokenType == TokenType.ThrowKeyword)
            	return ParseThrowSyntax(Tokens);
            else if (tokenType == TokenType.AssertKeyword)
            	return ParseAssertSyntax(Tokens);
            else if (tokenType == TokenType.TryKeyword)
            	return ParseTrySyntax(Tokens);
            else if (tokenType == TokenType.YieldKeyword)
            	return ParseYieldSyntax(Tokens);
            else if (tokenType == TokenType.BreakKeyword)
            	return ParseBreakSyntax(Tokens);
            else if (tokenType == TokenType.NextKeyword)
            	return ParseNextSyntax(Tokens);
            else if (tokenType == TokenType.RBraces)
            	return ParseBlockSyntax(Tokens);
            else if (tokenType == TokenType.IfKeyword)
            	return ParseIfElseSyntax(Tokens);
            else if (tokenType == TokenType.WhileKeyword)
            	return ParseWhileSyntax(Tokens);
            else if (tokenType == TokenType.DoKeyword)
            	return ParseDoWhileSyntax(Tokens);
            else if (tokenType == TokenType.ForKeyword)
            	return ParseForSyntax(Tokens);
            else if (tokenType == TokenType.ForeachKeyword)
            	return ParseForeachSyntax(Tokens);
			else if (tokenType.IsBinderDirectiveToken)
				return new BinderDirectiveStatementSyntax(ParseBinderDirective(Tokens));
            else
            {
				var decl = MaybeParseTopLevelDeclarationSyntax(Tokens);
            	if (decl != null)
               	{
                	return decl;
               	}
             	else
             	{
               		var expr = ParseExpression(Tokens);
               		if (Tokens.PeekNoTrivia().Type == TokenType.Semicolon)
                   	{
                 		Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                   	}
                  	if (expr is ISetVariableExpressionSyntax)
                   	{
                    	return new SetVariableStatementSyntax((ISetVariableExpressionSyntax)expr);
                   	}
                    else
                    {
                    	return new ExpressionStatementSyntax(expr);
                	}
            	}
            }
        }

        #endregion

		#region IsAmbiguousType

		protected virtual bool IsAmbiguousType(ITokenTypeSyntax Syntax)
		{
			var tkns = Syntax.Tokens;
			// This is ambiguous:
			//  - p* x <-> p * x (pointer declaration and multiplication)
			//  - p^ x <-> p ^ x (pointer declaration and bitwise xor)
			// This is not:
			//  - int*[] x
			//  - List<int*> x
			//  - int(int*) x
			//  - int*(int) x ('int*(int)' is ambiguous, but 'int*(int) x' is not)

			var lastToken = tkns[tkns.Count - 1];

			return lastToken.Type == TokenType.Asterisk || lastToken.Type == TokenType.Caret;
		}

		#endregion

		#region IsSingleVariableDeclaration

		protected virtual bool IsSingleVariableDeclaration(ITokenStream Tokens, TokenIdentifier Position)
		{
			var peek = Tokens.PeekNoTrivia(Position);
			if (peek.Type != TokenType.Identifier)
			{
				return false;
			}
			peek = Tokens.PeekNoTrivia(peek);
			return peek.Type == TokenType.Semicolon ||
				   peek.Type == TokenType.Comma ||
				   peek.Type == TokenType.Equals;
		}

		#endregion

        #region ParseDeclarationSyntax

        protected virtual SingleVariableDeclaration ParseSingleVariableDeclaration(ITokenStream Tokens)
        {
            var name = Tokens.NextNoTrivia(TokenType.Identifier, Log);
            var quickPeek = Tokens.PeekNoTrivia();
            if (quickPeek.Type == TokenType.Equals)
            {
                Token op = Tokens.NextNoTrivia();
                IExpressionSyntax expr = ParseExpression(Tokens);
                return new SingleVariableDeclaration(name, op, expr);
            }
            else
            {
                return new SingleVariableDeclaration(name);
            }
        }

		protected virtual SeparatedList<SingleVariableDeclaration> ParseSingleVariableDeclarationList(ITokenStream Tokens)
		{
			return ParseSeparatedList<SingleVariableDeclaration>(Tokens,
							ParseSingleVariableDeclaration, TokenType.Comma);
		}

		protected virtual VariableDeclarationSyntax MaybeParseTopLevelDeclarationSyntax(ITokenStream Tokens)
		{
			var pos = Tokens.CurrentPosition;
			var type = PeekEntireType(Tokens, true, &pos);
			if (type == null) return null;

			if (!IsSingleVariableDeclaration(Tokens, pos))
			{
				return null;
			}

			SkipTypeTokens(Tokens, type);

            var decl = ParseSingleVariableDeclarationList(Tokens);

            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);

            return new VariableDeclarationSyntax(type, decl, semicolon);
		}

        protected virtual VariableDeclarationSyntax ParseDeclarationSyntax(ITokenStream Tokens)
        {
			var type = ParseType(Tokens);

            var decl = ParseSingleVariableDeclarationList(Tokens);

			Token semicolon;
			if (Tokens.PeekNoTrivia().Type == TokenType.Semicolon)
	            semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
			else
				semicolon = Token.Undefined;

            return new VariableDeclarationSyntax(type, decl, semicolon);
        }

        protected virtual InlineVariableDeclarationSyntax ParseInlineDeclarationSyntax(ITokenStream Tokens)
        {
			var pos = Tokens.CurrentPosition;
            var type = PeekEntireType(Tokens, true, &pos);

			if (type == null || IsAmbiguousType(type))
				return null;

			var peek = PeekTypeTokens(Tokens, type);

			if (peek.Type != TokenType.Identifier)
				return null;

			SkipTypeTokens(Tokens, type);

            var decl = ParseSingleVariableDeclaration(Tokens);

            return new InlineVariableDeclarationSyntax(type, decl);
        }

        #endregion

        #region ParseReturnSyntax

        protected virtual IStatementSyntax ParseReturnSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.ReturnKeyword, Log);
            var peek = Tokens.PeekNoTrivia();
            if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new ReturnSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                var expr = ParseExpression(Tokens);
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new ReturnSyntax(keyword, expr, semicolon);
            }
        }

        #endregion

        #region ParseThrowSyntax

        protected virtual IStatementSyntax ParseThrowSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.ThrowKeyword, Log);
            var expr = ParseExpression(Tokens);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new ThrowSyntax(expr, keyword, semicolon);
        }

        #endregion

        #region ParseAssertSyntax

        protected virtual IStatementSyntax ParseAssertSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.AssertKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new AssertSyntax(keyword, leadingParen, expr, trailingParen, semicolon);
        }

        #endregion

        #region ParseYieldSyntax

        protected virtual IStatementSyntax ParseYieldSyntax(ITokenStream Tokens)
        {
        	var yieldKeyword = Tokens.NextNoTrivia(TokenType.YieldKeyword, Log);
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type == TokenType.BreakKeyword)
        	{
        		var breakSyntax = ParseBreakSyntax(Tokens);
        		return new YieldBreakSyntax(yieldKeyword, breakSyntax);
        	}
        	else
        	{
        		var returnKeyword = Tokens.NextNoTrivia(TokenType.ReturnKeyword, Log);
        		var expr = ParseExpression(Tokens);
        		var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
        		return new YieldReturnSyntax(yieldKeyword, new ReturnSyntax(returnKeyword, expr, semicolon));
        	}
        }

        #endregion

        #region ParseBreakSyntax

        protected virtual BreakSyntax ParseBreakSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia(TokenType.BreakKeyword, Log);
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new BreakSyntax(keyword, semicolon);
            /*if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new BreakSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                return new BreakSyntax(keyword, Token.Undefined);
            }*/
        }

        #endregion

        #region ParseNextSyntax

        protected virtual IStatementSyntax ParseNextSyntax(ITokenStream Tokens)
        {
            var keyword = Tokens.NextNoTrivia();
            var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            return new NextSyntax(keyword, semicolon);
            /*if (peek.TokenPeek.Type == TokenType.Semicolon)
            {
                return new NextSyntax(keyword, Tokens.NextNoTrivia());
            }
            else
            {
                return new NextSyntax(keyword, Token.Undefined);
            }*/
        }

        #endregion

        #region ParseBlock

        protected virtual IStatementSyntax ParseBlockSyntax(ITokenStream Tokens)
        {
        	var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
        	List<IStatementSyntax> statements = new List<IStatementSyntax>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type != TokenType.LBraces && peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED)
        	{
        		statements.Add(ParseStatementInternal(Tokens));
        		peek = Tokens.PeekNoTrivia();
        	}
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);
            return new BlockSyntax(leadingBraces, trailingBraces, statements);
        }

        #endregion

        #region ParseIfElseSyntax

        protected virtual IStatementSyntax ParseIfElseSyntax(ITokenStream Tokens)
        {
            var ifKeyword = Tokens.NextNoTrivia(TokenType.IfKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var ifBody = ParseStatement(Tokens);
            if (Tokens.PeekNoTrivia().Type == TokenType.ElseKeyword)
            {
                var elseKeyword = Tokens.NextNoTrivia();
                var elseBody = ParseStatement(Tokens);
                return new IfElseSyntax(ifKeyword, leadingParen, expr, trailingParen, ifBody, elseKeyword, elseBody);
            }
            else
            {
				if (ifBody is IfElseSyntax && Log.ShowDanglingElseWarnings)
				{
					var ifElseBody = (IfElseSyntax)ifBody;
					if (ifElseBody.ElseBody != null)
					{
						var firstMessage = new MarkupNode(NodeConstants.TextNodeType,
							"Nested if statement has a dangling else clause. " +
							"(A dangling else clause is assumed to belong to the innermost " +
							"if statement.) " +
							Warnings.GetWarningNameMessage(Warnings.DanglingElse));

						var firstDiag = ifElseBody.ElseKeyword.Location.CreateDiagnosticsNode();

						var firstEntry = new MarkupNode("entry", new IMarkupNode[]
						{
							firstMessage,
							firstDiag
						});

						var node = RedefinitionHelpers.AppendDiagnosticsRemark(firstEntry,
							"Dangling else belongs to this if statement: ",
							ifElseBody.IfKeyword.Location);

						Log.LogWarning(new LogEntry("Dangling else", node));
					}
				}
                return new IfElseSyntax(ifKeyword, leadingParen, expr, trailingParen, ifBody);
            }
        }

        #endregion

        #region ParseWhileSyntax

        protected virtual IStatementSyntax ParseWhileSyntax(ITokenStream Tokens)
        {
            var whileKeyword = Tokens.NextNoTrivia(TokenType.WhileKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var body = ParseStatement(Tokens);
            return new WhileSyntax(whileKeyword, leadingParen, expr, trailingParen, body);
        }

        #endregion

        #region ParseWhileSyntax

        protected virtual IStatementSyntax ParseDoWhileSyntax(ITokenStream Tokens)
        {
            var doKeyword = Tokens.NextNoTrivia(TokenType.DoKeyword, Log);
            var body = ParseStatement(Tokens);
            var whileKeyword = Tokens.NextNoTrivia(TokenType.WhileKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            //var exprTokens = Tokens.NextBlockContents(TokenType.RParen, TokenType.LParen);
            //var expr = ParseExpression(exprTokens);
            //var trailingParen = new Token(TokenType.LParen, ")");
            var expr = ParseExpression(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            return new DoWhileSyntax(doKeyword, body, whileKeyword, leadingParen, expr, trailingParen);
        }

        #endregion

        #region ParseForSyntax

        protected virtual IStatementSyntax ParseForSyntax(ITokenStream Tokens)
        {
            var forKeyword = Tokens.NextNoTrivia(TokenType.ForKeyword, Log);
            var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
            var initStatement = ParseStatement(Tokens); //ParseDeclarationSyntax(Tokens);
            var expr = ParseExpression(Tokens);
            Tokens.NextNoTrivia(TokenType.Semicolon, Log);
            var deltaStatement = ParseStatement(Tokens);
            var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            var body = ParseStatement(Tokens);
            return new ForSyntax(forKeyword, leadingParen, initStatement, expr, deltaStatement, trailingParen, body);
        }

        #endregion

        #region ParseForeachSyntax

        #region ParseElementInCollection

        protected virtual ElementInCollectionSyntax ParseElementInCollection(ITokenStream Tokens)
        {
            var variableDecl = ParseDeclarationSyntax(Tokens);
            var inKeyword = Tokens.NextNoTrivia(TokenType.InKeyword, Log);
            var enumerable = ParseExpression(Tokens);
            return new ElementInCollectionSyntax(variableDecl, inKeyword, enumerable);
        }

        #endregion

		#region ParseElementInCollectionList

		protected virtual DelimitedList<ElementInCollectionSyntax> ParseElementInCollectionList(ITokenStream Parser)
		{
			return ParseDelimitedList<ElementInCollectionSyntax>(Parser, ParseElementInCollection, TokenType.RParen, TokenType.LParen);
		}

		#endregion

        protected virtual IStatementSyntax ParseForeachSyntax(ITokenStream Tokens)
        {
            var foreachKeyword = Tokens.NextNoTrivia(TokenType.ForeachKeyword, Log);
			var elems = ParseElementInCollectionList(Tokens);
            var body = ParseStatement(Tokens);
            return new ForeachSyntax(foreachKeyword, elems, body);
        }

        #endregion

        #region ParseCatchSyntax

        protected virtual CatchSyntax ParseCatchSyntax(ITokenStream Tokens)
        {
        	var keyword = Tokens.NextNoTrivia(TokenType.CatchKeyword, Log);
        	var leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
        	var variableDecl = ParseDeclarationSyntax(Tokens);
        	var trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
        	var body = ParseStatement(Tokens);
        	return new CatchSyntax(keyword, leadingParen, variableDecl, trailingParen, body);
        }

        #endregion

        #region ParseFinallySyntax

        protected virtual FinallySyntax ParseFinallySyntax(ITokenStream Tokens)
        {
        	var keyword = Tokens.NextNoTrivia(TokenType.FinallyKeyword, Log);
        	var body = ParseStatement(Tokens);
        	return new FinallySyntax(keyword, body);
        }

        #endregion

        #region ParseTrySyntax

        protected virtual IStatementSyntax ParseTrySyntax(ITokenStream Tokens)
        {
        	var tryKeyword = Tokens.NextNoTrivia(TokenType.TryKeyword, Log);
        	var tryBody = ParseStatement(Tokens);
        	FinallySyntax finallyClause = null;
        	var catchClauses = new List<CatchSyntax>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type == TokenType.CatchKeyword || peek.Type == TokenType.FinallyKeyword)
        	{
        		if (peek.Type == TokenType.CatchKeyword)
        		{
        			catchClauses.Add(ParseCatchSyntax(Tokens));
        		}
        		else if (peek.Type == TokenType.FinallyKeyword)
        		{
        			if (finallyClause != null)
        			{
        				Log.LogError(new LogEntry("Invalid syntax", "A try/catch/finally statement cannot have multiple finally clauses.", peek.TokenPeek.Location));
        			}
        			finallyClause = ParseFinallySyntax(Tokens);
        		}
        		peek = Tokens.PeekNoTrivia();
        	}

			if (finallyClause == null && catchClauses.Count == 0 && Log.ShowLonelyTryWarnings)
			{
				Log.LogWarning(new LogEntry("Lonely try statement",
					"This try statement does not have an associated catch or finally clause. " +
					"The 'try' keyword is therefore meaningless here. " +
					Warnings.GetWarningNameMessage(Warnings.LonelyTry),
					tryKeyword.Location));
			}

        	return new TrySyntax(tryKeyword, tryBody, finallyClause, catchClauses);
        }

        #endregion

        #endregion

        #region Structure Parsing

        #region Attribute Parsing

        public virtual IAttributeSyntax ParseAttribute(ITokenStream Tokens)
        {
            var openingToken = Tokens.NextNoTrivia(TokenType.RBrackets, Log);
            var expr = (IInvocationSyntax)ParseNewObjectExpression(Token.Undefined, Tokens);
            var closingToken = Tokens.NextNoTrivia(TokenType.LBrackets, Log);
            return new AttributeSyntax(openingToken, expr, closingToken);
        }

        public virtual IEnumerable<IAttributeSyntax> ParseAttributes(ITokenStream Tokens)
        {
            List<IAttributeSyntax> attrs = new List<IAttributeSyntax>();
            while (Tokens.PeekNoTrivia().Type == TokenType.RBrackets)
            {
                attrs.Add(ParseAttribute(Tokens));
            }
            return attrs;
        }

        protected virtual bool PeekIsUnambiguousAttribute(ITokenStream Tokens)
        {
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type != TokenType.RBrackets)
        	{
        		return false;
        	}
        	var pos = peek.Identifier;
        	var type = PeekEntireType(Tokens, false, &pos);
        	int parseCount = type.Tokens.Count;

        	if (parseCount == 0)
        		return false;

            // Skip all tokens in the type, and skip one extra token for the leading RBrackets
            for (int i = 0; i < parseCount + 1; i++)
        	{
        		peek = Tokens.PeekNoTrivia(peek);
        	}

        	if (peek.Type == TokenType.RParen)
        		return true; // Constructor syntax, i.e. [Attribute()]. This is, unambiguously, an attribute.
        	if (peek.Type != TokenType.LBrackets)
        		return false; // Not an attribute

        	peek = Tokens.PeekNoTrivia(peek);

        	if (peek.Type == TokenType.Identifier) // [T] SomeMethod() --> [T] is not an attribute, because it is trailed by an identifier
        	{
        		return false; // Parse [T] as an enumerable
        	}
        	else if (peek.Type == TokenType.ThisKeyword)
        	{
        		// 'this' is tricky:
        		// [T] this() --> attribute
        		// [T] this[int Index] --> enumerable

        		peek = Tokens.PeekNoTrivia(peek); // One last lookahead

        		return peek.Type != TokenType.RBrackets; // [T] this[int Index] syntax
        	}
        	else
        	{
        		return true; // The syntax was matched to be that of an attribute, and was not trailed by an enumerator
        	}
        }

        /// <summary>
        /// Parses a list of attributes that may or may not be trailed by an enumerator, which uses the same syntax.
        /// </summary>
        public virtual IEnumerable<IAttributeSyntax> ParseAmbiguousAttributes(ITokenStream Tokens)
        {
            List<IAttributeSyntax> attrs = new List<IAttributeSyntax>();
            while (PeekIsUnambiguousAttribute(Tokens))
            {
                attrs.Add(ParseAttribute(Tokens));
            }
            return attrs;
        }

        #endregion

        #region ParseGenericParameters

        protected IEnumerable<IGenericParameterDeclarationSyntax> ParseGenericParameters(ITokenStream Tokens)
        {
            if (Tokens.PeekNoTrivia().Type != TokenType.LessThan)
            {
                return new IGenericParameterDeclarationSyntax[0];
            }

            List<IGenericParameterDeclarationSyntax> syntaxGroup = new List<IGenericParameterDeclarationSyntax>();
            Tokens.NextNoTrivia(TokenType.LessThan, Log);

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type != TokenType.GreaterThan)
            {
                List<Token> genericParameterTokens = new List<Token>();
                while (peek.Type != TokenType.Comma && peek.Type != TokenType.GreaterThan)
                {
                    genericParameterTokens.Add(Tokens.NextNoTrivia());
                    peek = Tokens.PeekNoTrivia();
                }
                if (peek.Type == TokenType.Comma)
                {
                    Tokens.NextNoTrivia(TokenType.Comma, Log);
                    peek = Tokens.PeekNoTrivia();
                }

                GenericParameterDeclarationSyntax syntax = new GenericParameterDeclarationSyntax(Enumerable.Take<Token>(genericParameterTokens, genericParameterTokens.Count - 1), Enumerable.Last<Token>(genericParameterTokens));
                syntaxGroup.Add(syntax);
            }

            Tokens.NextNoTrivia(TokenType.GreaterThan, Log);
            return syntaxGroup;
        }

        #endregion

        #region ParseGenericConstraints

        protected virtual [GenericConstraintSyntax] ParseGenericConstraints(ITokenStream Tokens)
        {
            List<GenericConstraintSyntax> constraints = new List<GenericConstraintSyntax>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type == TokenType.WhereKeyword)
            {
                var whereKeyword = Tokens.NextNoTrivia();
                var identifier = Tokens.NextNoTrivia(TokenType.Identifier, Log);
                var genericColon = Tokens.NextNoTrivia(TokenType.Colon, Log);
                var genericBaseTypes = ParseTypeList(Tokens);

                constraints.Add(new GenericConstraintSyntax(whereKeyword, identifier, genericColon, genericBaseTypes));

                peek = Tokens.PeekNoTrivia();
            }
            return constraints;
        }

        #endregion

        #region ParsePreconditions

        protected virtual PreconditionSyntax ParsePrecondition(ITokenStream Tokens)
        {
            var inKeyword = Tokens.NextNoTrivia(TokenType.InKeyword, Log);
            var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
            var cond = ParseExpression(Tokens);
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new PreconditionSyntax(inKeyword, leadingBraces, cond, trailingBraces);
        }

        #endregion

        #region ParsePostconditions

        protected virtual PostconditionSyntax ParsePostcondition(ITokenStream Tokens)
        {
            var outKeyword = Tokens.NextNoTrivia(TokenType.OutKeyword, Log);

            Token leadingParen = null;
            Token identifier = null;
            Token trailingParen = null;
            if (Tokens.PeekNoTrivia().Type == TokenType.RParen)
            {
	            leadingParen = Tokens.NextNoTrivia(TokenType.RParen, Log);
	            identifier = Tokens.NextNoTrivia(TokenType.Identifier, Log);
	            trailingParen = Tokens.NextNoTrivia(TokenType.LParen, Log);
            }

            var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
            var cond = ParseExpression(Tokens);
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new PostconditionSyntax(outKeyword, leadingParen, identifier, trailingParen, leadingBraces, cond, trailingBraces);
        }

        #endregion

        #region ParseMethodContract

        protected virtual MethodContract ParseMethodContract(ITokenStream Tokens)
        {
        	List<PreconditionSyntax> pres = new List<PreconditionSyntax>();
        	List<PostconditionSyntax> posts = new List<PostconditionSyntax>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type == TokenType.OutKeyword || peek.Type == TokenType.InKeyword)
            {
            	if (peek.Type == TokenType.InKeyword)
            	{
            		pres.Add(ParsePrecondition(Tokens));
            	}
            	else
            	{
            		posts.Add(ParsePostcondition(Tokens));
            	}

                peek = Tokens.PeekNoTrivia();
            }

            return new MethodContract(pres, posts);
        }

        #endregion

        #region ParseParameter

        protected virtual IMemberSyntax<IParameter> ParseParameter(ITokenStream Tokens)
        {
            ParameterSyntax syntax = new ParameterSyntax(ParseCommonSignatureSyntax(Tokens));
            return syntax;
        }

        #endregion

        #region ParseParameterList

        protected virtual DelimitedList<IMemberSyntax<IParameter>> ParseParameterList(ITokenStream Tokens, TokenType LeftDelimiter, TokenType RightDelimiter)
        {
			return ParseDelimitedList<IMemberSyntax<IParameter>>(Tokens, ParseParameter, LeftDelimiter, RightDelimiter);
        }

        #endregion

        #region ParseTypeList

        protected virtual SeparatedList<ITypeSyntax> ParseTypeList(ITokenStream Tokens)
        {
			return ParseSeparatedList<ITypeSyntax>(Tokens, ParseType, TokenType.Comma);
        }

        #endregion

        #region ParseCommonSignatureSyntax

        private bool IsConstructorSyntaxIdentifier(Token LastToken, ITokenStream Tokens)
        {
        	if (LastToken != default(Token))
        	if (LastToken.Type == TokenType.ThisKeyword && Tokens.PeekNoTrivia().Type == TokenType.RParen)
        		return true;
        	return false;
        }

        protected virtual ISignatureSyntax ParseCommonSignatureSyntax(ITokenStream Tokens)
        {
            var attrs = ParseAmbiguousAttributes(Tokens);

            bool typeDef = false;

            List<Token> modifierTokens = new List<Token>();
            while (Tokens.PeekNoTrivia().Type.IsModifier())
            {
                var token = Tokens.NextNoTrivia();
                if (token.Type.IsTypeKindToken())
                {
                    typeDef = true;
                }
                modifierTokens.Add(token);
            }
            var lastToken = Enumerable.LastOrDefault<Token>(modifierTokens);
            if (IsConstructorSyntaxIdentifier(lastToken, Tokens)) // ctor
            {
                return new ConstructorSignatureSyntax(attrs, Enumerable.Take<Token>(modifierTokens, modifierTokens.Count - 1), lastToken);
            }
            else if (typeDef) // type def
            {
                var name = Tokens.NextNoTrivia(TokenType.Identifier, Log);
                var genericParams = ParseGenericParameters(Tokens);
                return new SignatureSyntax(attrs, modifierTokens, null, name, genericParams);
            }
            else
            {
                var type = ParseType(Tokens);
                var name = Tokens.NextNoTrivia();
                if (name.Type == TokenType.OperatorKeyword)
                {
                	var op = Tokens.NextNoTrivia();
                	return new OperatorSignatureSyntax(attrs, modifierTokens, type, name, op);
                }
                else
                {
	                var genericParams = ParseGenericParameters(Tokens);
	                return new SignatureSyntax(attrs, modifierTokens, type, name, genericParams);
                }
            }
        }

        #endregion

        #region Field Parsing

        protected virtual IMemberSyntax<IField> ParseField(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            if (Tokens.PeekNoTrivia().Type == TokenType.Equals)
            {
                var equality = Tokens.NextNoTrivia(TokenType.Equals, Log);
                var expr = ParseExpression(Tokens);
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new FieldSyntax(Signature, equality, expr, semicolon);
            }
            else
            {
                var semicolon = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
                return new FieldSyntax(Signature, semicolon);
            }
        }

        #endregion

        #region Enum Literal Parsing

        protected virtual IMemberSyntax<IField> ParseEnumLiteral(ITokenStream Tokens)
        {
            Token ident = Tokens.NextNoTrivia();
            Token assignmentOperator;
            IExpressionSyntax expr;
            if (Tokens.PeekNoTrivia().Type == TokenType.Equals)
            {
                assignmentOperator = Tokens.NextNoTrivia();
                expr = ParseExpression(Tokens);
            }
            else
            {
                assignmentOperator = Token.Undefined;
                expr = null;
            }
            Token comma;
            if (Tokens.PeekNoTrivia().Type == TokenType.Comma)
            {
                comma = Tokens.NextNoTrivia();
            }
            else
            {
                comma = Token.Undefined;
            }
            return new EnumLiteralSyntax(ident, assignmentOperator, expr, comma);
        }

        #endregion

		#region Base member parsing

		protected virtual DelimitedList<ITypeMemberAccessSyntax> ParseBaseMembers(ITokenStream Tokens)
		{
            if (Tokens.PeekNoTrivia().Type == TokenType.Colon)
            {
				var colon = Tokens.NextNoTrivia(TokenType.Colon, Log);
                var implProps = new List<SeparatedItem<ITypeMemberAccessSyntax>>();
                do
                {
					Token comma = Token.Undefined;
					if (Tokens.PeekNoTrivia().Type == TokenType.Comma)
					{
						comma = Tokens.NextNoTrivia(TokenType.Comma, Log);
					}
					implProps.Add(new SeparatedItem<ITypeMemberAccessSyntax>(comma, (ITypeMemberAccessSyntax)ParseExpression(Tokens)));
                } while (Tokens.PeekNoTrivia().Type == TokenType.Comma);

				return new DelimitedList<ITypeMemberAccessSyntax>(colon,
					   new SeparatedList<ITypeMemberAccessSyntax>(implProps));
            }
            else
            {
				return new DelimitedList<ITypeMemberAccessSyntax>();
            }
		}

		#endregion

		#region Base constructor parsing

		protected virtual ITypeMemberAccessSyntax ParseBaseConstructorCall(ITokenStream Tokens)
		{
			var baseKeyword = Tokens.NextNoTrivia(TokenType.BaseKeyword, Log);
			var exprs = ParseArgumentList(Tokens);

			return new BaseConstructorCallSyntax(baseKeyword, exprs);
		}

		protected virtual DelimitedList<ITypeMemberAccessSyntax> ParseBaseConstructors(ITokenStream Tokens)
		{
			if (Tokens.PeekNoTrivia().Type == TokenType.Colon)
			{
				var colon = Tokens.NextNoTrivia(TokenType.Colon, Log);
				var implProps = ParseSeparatedList<ITypeMemberAccessSyntax>(Tokens, ParseBaseConstructorCall, TokenType.Comma);

				return new DelimitedList<ITypeMemberAccessSyntax>(colon, implProps);
			}
			else
			{
				return new DelimitedList<ITypeMemberAccessSyntax>();
			}
		}

		#endregion

        #region Method Parsing

        protected virtual IMemberSyntax<IMethod> ParseMethod(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            var parameters = ParseParameterList(Tokens, TokenType.RParen, TokenType.LParen);

			DelimitedList<ITypeMemberAccessSyntax> implementedMethods;
			if (MethodSyntax.IsConstructorSignature(Signature))
			{
				implementedMethods = ParseBaseConstructors(Tokens);
			}
			else
			{
				implementedMethods = ParseBaseMembers(Tokens);
			}

            var constraints = ParseGenericConstraints(Tokens);
            var contract = ParseMethodContract(Tokens);

            IStatementSyntax body = ParseStatement(Tokens);

            return new MethodSyntax(Signature, parameters, implementedMethods, constraints, contract, body);
        }

        #endregion

        #region Accessor Parsing

        protected virtual IAccessorSyntax ParseAccessor(ITokenStream Tokens)
        {
            var attrs = ParseAttributes(Tokens);

            List<Token> modifierTokens = new List<Token>();
            var peek = Tokens.PeekNoTrivia().TokenPeek;
            while (!AccessorSignatureSyntax.IsAccessorName(peek) && peek.Type.IsModifier())
            {
                modifierTokens.Add(Tokens.NextNoTrivia());
                peek = Tokens.PeekNoTrivia().TokenPeek;
            }

            if (!AccessorSignatureSyntax.IsAccessorName(peek))
            {
            	// Parse a single token here so we don't end up in an infinite loop when parsing properties
            	var parsedToken = Tokens.NextNoTrivia();
            	Log.LogError(new LogEntry("Parser error", "Invalid accessor syntax. Expected valid accessor name, got '" + parsedToken.ToString() + "'", parsedToken.Location));
            	return null;
            }

            Token nameToken = Tokens.NextNoTrivia();
            AccessorSignatureSyntax signature = new AccessorSignatureSyntax(attrs, modifierTokens, nameToken);
            var contract = ParseMethodContract(Tokens);

            IStatementSyntax body = ParseStatement(Tokens);

            return new AccessorSyntax(signature, contract, body);
        }

        #endregion

        #region Property Parsing

        protected virtual IMemberSyntax<ITypeMember> ParseProperty(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            DelimitedList<IMemberSyntax<IParameter>> parameters;
            if (Tokens.PeekNoTrivia().Type == TokenType.RBrackets)
            {
                parameters = ParseParameterList(Tokens, TokenType.RBrackets, TokenType.LBrackets);
            }
            else
            {
                parameters = new DelimitedList<IMemberSyntax<IParameter>>();
            }

            var implementedProperties = ParseBaseMembers(Tokens);

            var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);

            List<IAccessorSyntax> accessors = new List<IAccessorSyntax>();

			var peek = Tokens.PeekNoTrivia();
            while (peek.Type != TokenType.LBraces && peek.Type != TokenType.EndOfFile)
            {
                accessors.Add(ParseAccessor(Tokens));
                peek = Tokens.PeekNoTrivia();
            }

            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            var syntax = new PropertySyntax(Signature, parameters, implementedProperties, leadingBraces, accessors, trailingBraces);
            if (syntax.IsFieldProperty)
            {
                return new FieldPropertySyntax(syntax);
            }
            else
            {
                return syntax;
            }
        }

        #endregion

        #region Member Parsing

        protected virtual IMemberSyntax<IMember> ParseMember(ITokenStream Tokens)
        {
        	if (Tokens.PeekNoTrivia().Type == TokenType.InvariantKeyword)
        	{
        		return ParseInvariant(Tokens);
        	}
			else if (Tokens.PeekNoTrivia().Type.IsBinderDirectiveToken)
			{
				return new BinderDirectiveMemberSyntax(ParseBinderDirective(Tokens));
			}

            var commonSig = ParseCommonSignatureSyntax(Tokens);

			bool isTypeDecl = false;
			foreach (var item in commonSig.ModifierTokens)
			{
				if (item.Type.IsTypeKindToken())
				{
					isTypeDecl = true;
					break;
				}
			}
            if (isTypeDecl)
            {
                return (IMemberSyntax<IType>)ParseTypeDeclaration(Tokens, commonSig);
            }
            else
            {
                var peek = Tokens.PeekNoTrivia();

                if (peek.Type == TokenType.RParen)
                {
                    return ParseMethod(Tokens, commonSig);
                }
                else if (peek.Type == TokenType.RBraces || peek.Type == TokenType.RBrackets || peek.Type == TokenType.Colon)
                {
                    return ParseProperty(Tokens, commonSig);
                }
                else
                {
                    return ParseField(Tokens, commonSig);
                }
            }
        }

        #endregion

        #region Invariant Parsing

        protected virtual IMemberSyntax<IInvariant> ParseInvariant(ITokenStream Tokens)
        {
        	var invariantKeyword = Tokens.NextNoTrivia(TokenType.InvariantKeyword, Log);
        	var leadingBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);
            var cond = ParseExpression(Tokens);
            var trailingBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new InvariantSyntax(invariantKeyword, leadingBraces, cond, trailingBraces);
        }

        #endregion

        #region Type Declaration Parsing

        protected virtual ITypeDeclarationSyntax ParseTypeDeclaration(ITokenStream Tokens, ISignatureSyntax Signature)
        {
            var peek = Tokens.PeekNoTrivia();

            Token colon;
            [ITypeSyntax] baseTypes;

            if (peek.Type == TokenType.Colon)
            {
                colon = Tokens.NextNoTrivia();
                baseTypes = ParseTypeList(Tokens);
            }
            else
            {
                colon = Token.Undefined;
                baseTypes = new ITypeSyntax[0];
            }

            var constraints = ParseGenericConstraints(Tokens);

            TypeSignatureSyntax typeSig = new TypeSignatureSyntax(Signature, colon, baseTypes, constraints);

            Tokens.NextNoTrivia(TokenType.RBraces, Log);

			bool isEnum = false;
			foreach (var item in Signature.ModifierTokens)
			{
				if (item.Type == TokenType.EnumKeyword)
				{
					isEnum = true;
					break;
				}
			}

            var members = new List<IMemberSyntax<IMember>>();

            peek = Tokens.PeekNoTrivia();
            while (peek.Type != TokenType.LBraces)
            {
                if (isEnum)
                {
                    members.Add(ParseEnumLiteral(Tokens));
                }
                else
                {
                    members.Add(ParseMember(Tokens));
                }
                peek = Tokens.PeekNoTrivia();
            }

            Tokens.NextNoTrivia(TokenType.LBraces, Log);

            TypeDeclarationSyntax syntax = new TypeDeclarationSyntax(typeSig, members);

            return syntax;
        }

        public virtual ITypeDeclarationSyntax ParseTypeDeclaration(ITokenStream Tokens)
        {
            return ParseTypeDeclaration(Tokens, ParseCommonSignatureSyntax(Tokens));
        }

        #endregion

		protected virtual IBinderDirectiveSyntax ParseAliasSyntax(Token AliasKeyword, Token Alias, Token EqualsToken, ITokenStream Tokens)
		{
			var type = ParseType(Tokens);
			var semi = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
			return new AliasSyntax(AliasKeyword, Alias, EqualsToken, type, semi);
		}

		public virtual IBinderDirectiveSyntax ParseAliasSyntax(ITokenStream Tokens)
		{
			var aliasKeyword = Tokens.NextNoTrivia(TokenType.AliasKeyword, Log);
			var ident = Tokens.NextNoTrivia(TokenType.Identifier, Log);
			var eqToken = Tokens.NextNoTrivia(TokenType.Equals, Log);
			return ParseAliasSyntax(aliasKeyword, ident, eqToken, Tokens);
		}

        public virtual IBinderDirectiveSyntax ParseUsingSyntax(ITokenStream Tokens)
        {
        	var usingKeyword = Tokens.NextNoTrivia(TokenType.UsingKeyword, Log);
			if (Tokens.PeekNoTrivia().Type == TokenType.NamespaceKeyword)
			{
				var nsTok = Tokens.NextNoTrivia();
				if (Log.ShowCppUsingNamespaceWarnings)
				{
					Log.LogWarning(new LogEntry("C++ style 'using namespace'",
						"C++ style 'using namespace' statements are not standard D#. " +
						"Consider omitting the 'namespace' keyword. " +
						Warnings.GetWarningNameMessage(Warnings.CppUsingNamespace),
						nsTok.Location));
				}
			}
            List<Token> name = new List<Token>();
            Token token = Tokens.NextNoTrivia();
            while (token.Type != TokenType.Semicolon && token.Type != TokenType.Equals && token.Type != TokenType.EndOfFile)
            {
                name.Add(token);
                token = Tokens.NextNoTrivia();
            }
			if (name.Count == 0)
			{
				Log.LogError(new LogEntry("Empty using declaration", "An empty using declaration is not legal.", usingKeyword.Location));
				if (token.Type == TokenType.Equals)
				{
					var type = ParseType(Tokens);
					var semi = Tokens.NextNoTrivia(TokenType.Semicolon, Log);
					return new AliasSyntax(usingKeyword, Token.Undefined, token, type, semi);
				}
				else return new EmptyUsingSyntax(usingKeyword, token);
			}
            if (token.Type == TokenType.Equals)
            {
				var singleIdentifier = name[0];
				if (Log.ShowBadAliasWarnings)
				{
					Log.LogWarning(new LogEntry("C++/C# style alias declaration",
						"C++/C# style alias declarations are nonstandard in D#. " +
						"Consider using the 'alias' keyword instead of 'using' when declaring aliases. " +
						Warnings.GetWarningNameMessage(Warnings.BadAlias),
						usingKeyword.Location.Concat(token.Location)));
				}
				return ParseAliasSyntax(usingKeyword, singleIdentifier, token, Tokens);
            }
            else
            {
                return new UsingSyntax(usingKeyword, name, token);
            }
        }

        public NamespaceCompilationUnit ParseNamespaceSyntax(ITokenStream Tokens)
        {
            var nsKeyword = Tokens.NextNoTrivia(TokenType.NamespaceKeyword, Log);
            List<Token> nameTokens = new List<Token>();
            nameTokens.Add(Tokens.NextNoTrivia());
            while (Tokens.PeekNoTrivia().Type == TokenType.Dot)
            {
                nameTokens.Add(Tokens.NextNoTrivia(TokenType.Dot, Log));
                nameTokens.Add(Tokens.NextNoTrivia());
            }
            var rBraces = Tokens.NextNoTrivia(TokenType.RBraces, Log);

			var peek = Tokens.PeekNoTrivia();
			List<ISyntaxNode> contents = new List<ISyntaxNode>();
			while (peek.Type != TokenType.LBraces && peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED)
			{
				contents.Add(ParseCompilationUnitChild(Tokens));
				peek = Tokens.PeekNoTrivia();
			}

            var lBraces = Tokens.NextNoTrivia(TokenType.LBraces, Log);

            return new NamespaceCompilationUnit(nsKeyword, nameTokens.ToArray(), rBraces, contents.ToArray(), lBraces);
        }

		public virtual IBinderDirectiveSyntax ParseBinderDirective(ITokenStream Tokens)
		{
			var peek = Tokens.PeekNoTrivia();
			if (peek.Type == TokenType.UsingKeyword)
			{
				return ParseUsingSyntax(Tokens);
			}
			else if (peek.Type == TokenType.AliasKeyword)
			{
				return ParseAliasSyntax(Tokens);
			}
			else return null;
		}

        public virtual ISyntaxNode ParseCompilationUnitChild(ITokenStream Tokens)
        {
        	var peek = Tokens.PeekNoTrivia();
        	if (peek.Type.IsBinderDirectiveToken)
        	{
        		return ParseBinderDirective(Tokens);
        	}
        	else if (peek.Type == TokenType.NamespaceKeyword)
        	{
        		return ParseNamespaceSyntax(Tokens);
        	}
        	else
        	{
        		return ParseTypeDeclaration(Tokens);
        	}
        }

        public virtual CompilationUnit ParseCompilationUnit(ITokenStream Tokens)
        {
        	var children = new List<ISyntaxNode>();
        	var peek = Tokens.PeekNoTrivia();
        	while (peek.Type != TokenType.EndOfFile && peek.Type != TokenType.UNDEFINED && peek.Type != TokenType.LBraces)
        	{
        		children.Add(ParseCompilationUnitChild(Tokens));
        		peek = Tokens.PeekNoTrivia();
        	}
        	return new CompilationUnit(children.ToArray());
        }

        #endregion
	}
}
