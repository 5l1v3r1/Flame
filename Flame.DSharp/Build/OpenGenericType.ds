using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
    public class OpenGenericType : SyntaxType
    {
        public const this(set TypeDeclarationSyntax syntax, set INamespace DeclaringNamespace, set IBinder Binder,
            set ICompilerLog Log, set IMemberProvider MemberProvider, set IConverter<IType, string> TypeNamer);
        public const this(set TypeDeclarationSyntax syntax, set INamespace DeclaringNamespace,
            set IBinder Binder, set ICompilerLog Log, IExtensionTypeProvider ExtensionTypeProvider, set IConverter<IType, string> TypeNamer)
        {
        	this.MemberProvider = new MemberProvider(ExtensionTypeProvider, Binder);
        }

        public override string Name
        {
            const get
            {
                int genericCount = Enumerable.Count<IGenericParameter>(this.GetGenericParameters());
                if (genericCount == 0)
                {
                    return Syntax.Signature.NameToken.TokenValue;
                }
                else
                {
                    StringBuilder sb = new StringBuilder();
                    sb.Append(Syntax.Signature.NameToken.TokenValue);
                    sb.Append('<');
                    for (int i = 0; i < genericCount - 1; i++)
                    {
                        sb.Append(',');
                    }
                    sb.Append('>');
                    return sb.ToString();
                }
            }
        }

        public override IType GetGenericDeclaration()
        {
            return this;
        }

        public override [IType] GetGenericArguments()
        {
            return Enumerable.Empty<IType>();
        }
    }
}
