using System;
using System.Collections.Generic;
using System.Text;
using Flame.Build;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Syntax;
using Flame.Syntax.DSharp;
alias FlameAccessorType = Flame.AccessorType;

namespace Flame.DSharp.Build
{
	public class SingletonInstanceAccessor : IAccessor, IBodyMethod
	{
		public const this(set IProperty DeclaringProperty, set IField BackingField);

		public IField BackingField { const get; private set; }
		public IProperty DeclaringProperty { const get; private set; }
		public IType DeclaringType { const get return DeclaringProperty.DeclaringType; }
		public string Name { const get return "get_" + DeclaringProperty.Name; }
		public string FullName { const get return MemberExtensions.CombineNames(DeclaringType.FullName, Name); }

		public FlameAccessorType AccessorType
        {
            const get return FlameAccessorType.GetAccessor;
        }

		public IType ReturnType { const get return DeclaringProperty.PropertyType; }
		public bool IsStatic { const get return true; }
		public const IParameter[] GetParameters()
		{
			return new IParameter[0];
		}
		public bool IsConstructor { const get return false; }
		public const IMethod[] GetBaseMethods()
		{
			return new IMethod[0];
		}

		public const [IAttribute] GetAttributes()
		{
			return new IAttribute[] { new AccessAttribute(AccessModifier.Public) };
		}

		public const IBoundObject Invoke(IBoundObject Target, [IBoundObject] Arguments)
		{
			return null;
		}

		public const IMethod GetGenericDeclaration()
		{
			return this;
		}

		public const IMethod MakeGenericMethod([IType] Arguments)
		{
			return null;
		}

		public const [IType] GetGenericArguments()
		{
			return new IType[0];
		}

		public const [IGenericParameter] GetGenericParameters()
		{
			return new IGenericParameter[0];
		}

		public const IStatement GetMethodBody()
        {
        	// Statement for: (initialization is done in the static constructor)
        	//
        	// if (<field> == null)
        	// {
        	//     <field> = new <type>();
        	// }
        	// return <field>;

			var singletonField = BackingField;
			if (singletonField.DeclaringType.IsGeneric)
			{
				var resolver = new DescribedGenericTypeInstance(singletonField.DeclaringType,
																ReturnType.GetGenericArguments());

				singletonField = new DescribedGenericFieldInstance(singletonField,
																   resolver,
																   ReturnType);
			}

    		var newObjExpr = new NewObjectExpression(singletonField.FieldType); // new <type>();
        	var fieldVar = new FieldVariable(singletonField, null);
        	var fieldGetExpr = fieldVar.CreateGetExpression();
        	var eqExpr = new EqualityExpression(fieldGetExpr, new NullExpression()); // <field> == null
        	var setStmt = fieldVar.CreateSetStatement(newObjExpr); // <field> = new <type>();
        	var ifStmt = new IfElseStatement(eqExpr, setStmt); // if (<field> == null)
        	var retStmt = new ReturnStatement(fieldGetExpr); // return <field>;
        	return new BlockStatement(new IStatement[] { ifStmt, retStmt });
        }

        private static string GetSingletonInstanceFieldName(IType TargetType)
        {
        	return TargetType.GetGenericFreeName().Replace('.', '_') + "_instance_value";
        }

        public static const FieldProperty CreateAccessorProperty(ISyntaxState State)
        {
        	var field = new DescribedField(GetSingletonInstanceFieldName(State.DeclaringType), State.CurrentType, true);
        	field.DeclaringType = State.DeclaringType;
        	field.AddAttribute(PrimitiveAttributes.HiddenAttribute);
        	field.AddAttribute(new AccessAttribute(AccessModifier.Private));
        	var property = new DescribedProperty("Instance", State.DeclaringType, State.CurrentType, true);
        	property.AddAttribute(new AccessAttribute(AccessModifier.Public));
        	var accessor = new SingletonInstanceAccessor(property, field);
        	property.AddAccessor(accessor);
        	return new FieldProperty(property, field);
        }

        public static const IField GetSingletonInstanceField(IType TargetType)
        {
        	return TargetType.GetField(GetSingletonInstanceFieldName(TargetType), true);
        }
	}
}
