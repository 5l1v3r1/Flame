using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
    public class SyntaxType : SyntaxTypeBase
    {
        public const this(set TypeDeclarationSyntax syntax, INamespace DeclaringNamespace, set IBinder Binder,
            set ICompilerLog Log, set IConverter<IType, string> TypeNamer)
            : base(DeclaringNamespace)
        {
        	this.MemberProvider = new MemberProvider(Binder);
        }
        public const this(set TypeDeclarationSyntax syntax, INamespace DeclaringNamespace,
            set IBinder Binder, set ICompilerLog Log, IExtensionTypeProvider ExtensionTypeProvider, set IConverter<IType, string> TypeNamer)
            : base(DeclaringNamespace)
        {
            this.MemberProvider = new MemberProvider(ExtensionTypeProvider, Binder);
        }
        public const this(set TypeDeclarationSyntax syntax, INamespace DeclaringNamespace, set IBinder Binder,
            set ICompilerLog Log, set IMemberProvider MemberProvider, set IConverter<IType, string> TypeNamer)
            : base(DeclaringNamespace);

        protected TypeDeclarationSyntax syntax;
        public override TypeDeclarationSyntax GetTypeSyntax()
        {
        	return syntax;
        }

        public IBinder Binder { const get; protected set; }
        public ICompilerLog Log { const get; protected set; }
        public IMemberProvider MemberProvider { const get; protected set; }
        public IConverter<IType, string> TypeNamer { const get; protected set; }

        public override string Name
        {
            const get
            {
                int genericCount = Enumerable.Count<IGenericParameterDeclarationSyntax>(
                    Syntax.Signature.GenericDeclarations);
                if (genericCount == 0)
                {
                    return Syntax.Signature.NameToken.TokenValue;
                }
                else
                {
                    var sb = new StringBuilder();
                    sb.Append(Syntax.Signature.NameToken.TokenValue);
                    sb.Append('<');
                    for (int i = 0; i < genericCount - 1; i++)
                    {
                        sb.Append(',');
                    }
                    sb.Append('>');
                    return sb.ToString();
                }
            }
        }

        private ISyntaxState currentState;
        public override ISyntaxState GetSyntaxState()
        {
            if (currentState == null)
            {
                var genericBinder = new PredefinedBinder(Binder);

            	foreach (var param in this.GenericParameters)
	            {
	            	genericBinder.MapType(param.Name, param);
	            }

    			var descMethod = new DescribedMethod("", this, PrimitiveTypes.Void, false);

                currentState = new SyntaxState(descMethod, genericBinder, Log, MemberProvider, TypeNamer);

                foreach (var item in Syntax.BinderDeclarations)
                {
                    item.CreateMember(currentState);
                }
            }

            return currentState;
        }

        protected override ISyntaxState GetNamespaceSyntaxState()
        {
        	var descMethod = new DescribedMethod("", this, PrimitiveTypes.Void, false);
            return new SyntaxState(descMethod, Binder, Log, MemberProvider, TypeNamer);
        }

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is SyntaxType)
            {
                return this.Syntax == ((SyntaxType)obj).Syntax;
            }
            else
            {
                return false;
            }
        }

        #endregion
    }
}
