using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
    public abstract class SyntaxMethodBase : CodeMember, IDSharpSyntaxMethod, ISyntaxNode
    {
   		public const this();
        public const this(set IType DeclaringType, set ICompilerLog Log);

        public IType DeclaringType { const get; protected set; }
        public ICompilerLog Log { const get; protected set; }

        #region Abstract

        public const IMemberSyntax<IMethod> GetSyntax() : IDSharpSyntaxMethod.GetSyntax
        {
            return Syntax;
        }


		public abstract const MethodSyntax GetMethodSyntax();

        public MethodSyntax Syntax { const get return GetMethodSyntax(); }
        public abstract ISyntaxState GetSyntaxState();
        public abstract ISyntaxState GetDeclaringSyntaxState();
        public abstract [IType] GetGenericArguments();

        #endregion

        #region CodeMember Implementation

        public override virtual string GetHeaderString()
        {
            return Syntax.Signature.GetCode().ToString();
        }

        public override virtual CodeBuilder GetBodyCode()
        {
            return Syntax.Body.GetCode();
        }

        #endregion

        #region IDSharpMethod Implementation

        public virtual const IStatement GetMethodBody()
        {
            var state = GetSyntaxState();
            IStatement statement = Syntax.Body.CreateVerifiedStatement(state);
            var parameters = GetParameters();

			var blockStatements = new List<IStatement>();

			if (this.IsConstructor)
			{
				if (!this.IsStatic)
				{
					blockStatements.Add(DSharpTypeExtensions.CreateBaseConstructorCall(state));
				}
			}

            for (int i = 0; i < parameters.Length; i++)
            {
                if (parameters[i].SetsMember)
                {
                	var setStatement = parameters[i].CreateSetMemberStatement(i, state.CurrentType, this.IsStatic);
                	if (setStatement == null)
                	{
                		state.Log.LogError(new LogEntry("Invalid 'set' modifier",
                            "'set' modifier on parameter '" + parameters[i].Name + "' in '" + this.GetHeaderString() + "' could not be mapped to a field or property of type '" + this.DeclaringType.FullName + "'."));
                	}
                	else
                	{
                    	blockStatements.Add(setStatement);
                    }
                }
            }

            blockStatements.Add(statement);

            if (!this.HasReturnValue)
            {
            	blockStatements.Add(new ReturnStatement());
            }

            return Syntax.Contract.CreateContractBody(new BlockStatement(blockStatements.ToArray()), state);
        }

        private IType returnTypeVal;
        public IType ReturnType
        {
            const get
            {
                if (returnTypeVal == null)
                {
                    returnTypeVal = Syntax.Signature.TypeSyntax.CreateVerifiedType(GetSyntaxState());
                }
                return returnTypeVal;
            }
        }

        private IParameter[] parameterVals;
        public const IParameter[] GetParameters()
        {
            if (parameterVals == null)
            {
                var state = GetSyntaxState();
                var paramList = new List<IParameter>();
                foreach (var item in Syntax.Parameters)
                {
                	paramList.Add(item.CreateMember(state));
                }
                parameterVals = paramList.ToArray();
            }
            return parameterVals;
        }

        public bool IsConstructor
        {
            const get { return Syntax.Name.Equals("this"); }
        }

        public IBoundObject Invoke(IBoundObject Caller, IEnumerable<IBoundObject> Arguments)
        {
        	var environment = GetDeclaringSyntaxState();
        	if (environment is IDynamicEnvironment)
        	{
        		return ((IDynamicEnvironment)environment).InvokeDynamic(this, Caller, Arguments);
        	}
            return null;
        }

        #endregion

        #region Common Properties

        public bool IsStatic
        {
            const get { return Syntax.Signature.ModifierTokens.IsStatic && !DeclaringType.IsSingleton; }
        }

        public string Name
        {
            const get
            {
            	if (Syntax.Signature.IsOperator)
            	{
            		string tokenVal = Syntax.Signature.NameToken.TokenValue;
            		if (tokenVal.Equals("hash"))
            		{
            			return "GetHashCode";
            		}
            		else if (tokenVal.Equals("cast"))
            		{
            			var retType = ReturnType;
            			if (retType.Equals(PrimitiveTypes.String))
            				return "ToString";
            			else
            				return "cast<" + retType.FullName + ">";
            		}
            		else
            		{
            			return "operator" + tokenVal;
            		}
            	}
            	else
            		return Syntax.Signature.NameToken.TokenValue;
           	}
        }

        public string FullName
        {
            const get { return MemberExtensions.CombineNames(DeclaringType.FullName, Name); }
        }

		private IAttribute[] attrCache;
		public [IAttribute] Attributes { const get return GetAttributes(); }

        public const [IAttribute] GetAttributes()
        {
        	if (attrCache == null)
        	{
	            var state = GetSyntaxState();

	            var modifierAttrs = Syntax.Signature.ModifierTokens.GetModifiers();
	            var extraAttrs = new List<IAttribute>();
	            // Singleton constructor handling
	            bool singletonCtor = DeclaringType.IsSingleton && this.IsConstructor;
	            if (!modifierAttrs.HasAccessAttribute && !singletonCtor)
	            {
	                extraAttrs.Add(new AccessAttribute(AccessModifier.Public));
	            }
	            else if (singletonCtor)
	            {
	            	AccessModifier accessMod;
	            	if (DeclaringType.IsVirtual || DeclaringType.IsAbstract)
	            	{
	            		accessMod = AccessModifier.Protected;
	            	}
	            	else
	            	{
	            		accessMod = AccessModifier.Private;
	            	}
	            	int i = 0;
	            	while (i < extraAttrs.Count)
	            	{
	            		if (extraAttrs[i] is AccessAttribute)
	            	  	{
	            	  		var providedAccess = ((AccessAttribute)extraAttrs[i]).Access;
	            	  		if (providedAccess != accessMod)
	            	  		{
	            	  			state.Log.LogWarning(new LogEntry("Invalid access modifier", "Invalid explicit access modifier at '" + this.GetHeaderString() + "' in singleton '" + DeclaringType.FullName + "': expected '" + accessMod + "', got '" + providedAccess + "'"));
	            	  		}
	            	  		extraAttrs.RemoveAt(i);
	            		}
	            		else
	            		{
	            			i++;
	            		}
	            	}
	            	extraAttrs.Add(new AccessAttribute(accessMod));
	            }

	            foreach (var item in modifierAttrs)
		            extraAttrs.Add(item);
		        foreach (var item in Syntax.Signature.Attributes)
		        	extraAttrs.Add(item.CreateAttribute(state, this));

		        if (Syntax.Signature.IsOperator)
		        {
		        	string opName = Syntax.Signature.NameToken.TokenValue;
		        	if (opName.Equals("cast"))
		        	{
		        		extraAttrs.Add(PrimitiveAttributes.CastAttribute);
		        	}
		        	else
		        	{
		        		var op = Operator.GetOperator(Syntax.Signature.NameToken.TokenValue);
		        		if (!op.IsDefined)
		        		{
		        			state.Log.LogError(new LogEntry("Unknown operator overload", "Overloaded operator '" + opName + "' in '" + this.FullName + "' is not a known operator."));
		        		}
		        		extraAttrs.Add(new OperatorAttribute(op));
		        	}
		        }

		       	extraAttrs.AddRange(Syntax.GetDescriptionAttributes(GetDeclaringSyntaxState()));

	            attrCache = extraAttrs.ToArray();
	    	}
	    	return ([IAttribute])attrCache;
        }

        #endregion

        #region Base Methods

        private IMethod[] baseMethodCache;
        public IMethod[] BaseMethods { const get return GetBaseMethods(); }

        public virtual IMethod[] GetBaseMethods()
        {
        	if (baseMethodCache == null)
        	{
	        	var state = GetSyntaxState();
	        	var baseMethods = new List<IMethod>();
	        	var paramTypes = this.GetParameters().GetTypes();
	        	foreach (var item in Syntax.ImplementedMethods)
	            {
	                var member = Enumerable.OfType<IMethod>(item.GetAccessedMembers(state)).GetMethod(this.IsStatic, this.ReturnType, paramTypes);
	                if (member == null)
	                {
	                	state.Log.LogError(new LogEntry("Base method resolution error", "Could not resolve base method '" + item.GetCode().ToString() + "'.", item.GetSourceLocation()));
	                }
	                baseMethods.Add(member);
	            }
	            if (baseMethods.Count == 0)
	            {
	            	foreach (var item in DeclaringType.GetAllBaseTypes())
	            	{
	            		var match = item.GetMethods().GetMethod(this.Name, this.IsStatic, this.ReturnType, paramTypes);
	            		if (match != null)
	            		if (match.IsVirtual)
	            		if (!baseMethods.Contains(match))
	            		{
	            			baseMethods.Add(match);
	            		}
	            	}
	            	if (baseMethods.Count == 0 && Syntax.Signature.ModifierTokens.IsOverride)
	            	{
	            		state.Log.LogError(new LogEntry("No suitable base methods", "Override method '" + FullName + "' could not find any suitable base methods to override."));
	            	}
	            }
	            baseMethodCache = baseMethods.ToArray();
            }
            return baseMethodCache;
        }

        #endregion

        #region Generics

        public virtual [IGenericParameter] GetGenericParameters()
        {
            return DSharpTypeExtensions.CreateConstrainedGenericParameters(GetDeclaringSyntaxState(), this, Syntax.Signature.GenericDeclarations, Syntax.GenericConstraints);
        }

        public virtual IMethod MakeGenericMethod([IType] TypeArguments)
        {
            var state = GetSyntaxState();
            return new ClosedGenericMethod(Syntax, DeclaringType, state.Binder,
                state.Log, state.MemberProvider, state.TypeNamer, TypeArguments);
        }

        public virtual IMethod GetGenericDeclaration()
        {
            var state = GetSyntaxState();
            return new OpenGenericMethod(Syntax, DeclaringType, state.Binder,
                state.Log, state.MemberProvider, state.TypeNamer);
        }

        #endregion

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override virtual bool Equals(object obj)
        {
            if (obj is OpenGenericMethod)
            {
            	var otherMethod = (SyntaxMethodBase)obj;
                return (this is OpenGenericMethod) && this.Syntax.Equals(otherMethod.Syntax) && this.DeclaringType.Equals(otherMethod.DeclaringType);
            }
            else if (obj is SyntaxMethodBase)
            {
                var otherMethod = (SyntaxMethodBase)obj;
                if (!this.Syntax.Equals(otherMethod.Syntax) || !this.DeclaringType.Equals(otherMethod.DeclaringType))
                {
                    return false;
                }

                var genArgs1 = Enumerable.ToArray<IType>(GetGenericArguments());
                var genArgs2 = Enumerable.ToArray<IType>(otherMethod.GetGenericArguments());

				return genArgs1.AreEqual(genArgs2);
            }
            return false;
        }

        #endregion

        #region GetCode

        public override virtual string ToString()
        {
            return Syntax.ToString();
        }

        public CodeBuilder GetCode()
        {
            return Syntax.GetCode();
        }

        #endregion
    }
}
