using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
    public class SyntaxProperty : CodeMember, IProperty, ISyntaxNode, ISourceMember
    {
        public const this(set PropertySyntax Syntax, set IType DeclaringType, set IBinder Binder,
            set ICompilerLog Log, set IMemberProvider MemberProvider, set IConverter<IType, string> TypeNamer);

        public PropertySyntax Syntax { const get; private set; }
        public IType DeclaringType { const get; private set; }
        public ICompilerLog Log { const get; private set; }
        public IBinder Binder { const get; private set; }
        public IMemberProvider MemberProvider { const get; private set; }
        public IConverter<IType, string> TypeNamer { const get; private set; }

        #region GetSyntaxState

        public virtual const ISyntaxState GetSyntaxState()
        {
        	var descMethod = new DescribedMethod();
			descMethod.DeclaringType = DeclaringType;
            return new SyntaxState(descMethod, Binder, Log, MemberProvider, TypeNamer);
        }

        #endregion

        #region ISourceMember Implementation

        public SourceLocation Location
        {
            const get return Syntax.Location;
        }

        #endregion

        #region IProperty Implementation

        public IType PropertyType
        {
            const get { return Syntax.Signature.TypeSyntax.CreateVerifiedType(GetSyntaxState()); }
        }

		private IAccessor[] accessorVals;
		public IAccessor[] Accessors { const get return GetAccessors(); }

        public const IAccessor[] GetAccessors()
        {
        	if (accessorVals == null)
        	{
	        	List<IAccessor> accessors = new List<IAccessor>();
	        	foreach (var item in Syntax.Accessors)
	        	{
	        		accessors.Add(item.CreateAccessor(this, Binder));
	        	}
	        	accessorVals = accessors.ToArray();
            }
            return accessorVals;
        }

		private IParameter[] indexerParams;
		public IParameter[] IndexerParameters { const get return GetIndexerParameters(); }

        public const IParameter[] GetIndexerParameters()
        {
        	if (indexerParams == null)
        	{
        		var indexParams = new List<IParameter>();
        		foreach (var item in Syntax.IndexerParameters)
        		{
        			indexParams.Add(item.CreateMember(GetSyntaxState()));
        		}
        		indexerParams = indexParams.ToArray();
        	}
        	return indexerParams;
        }

        public bool IsStatic
        {
            const get { return Syntax.Signature.ModifierTokens.IsStatic && !DeclaringType.IsSingleton; }
        }

        public string Name
        {
            const get { return Syntax.Signature.NameToken.TokenValue; }
        }

        public string FullName
        {
            const get { return MemberExtensions.CombineNames(DeclaringType.FullName, Name); }
        }

		private IAttribute[] attrCache;
		public [IAttribute] Attributes { const get return GetAttributes(); }

        public const [IAttribute] GetAttributes()
        {
        	if (attrCache == null)
        	{
	            var state = GetSyntaxState();

	            var modifierAttrs = Syntax.Signature.ModifierTokens.GetModifiers();
	            var extraAttributes = new List<IAttribute>();
	            /*foreach (var item in Syntax.ImplementedProperties)
	            {
	                var member = item.GetAccessedMembers(state).First();
	                extraAttributes.Add(new OverrideAttribute(member.Name, member.DeclaringType.FullName));
	            }*/
	            if (Syntax.Signature.NameToken.Type == TokenType.ThisKeyword && GetIndexerParameters().Length > 0)
	            {
	                extraAttributes.Add(PrimitiveAttributes.IndexerAttribute);
	            }
	            if (!modifierAttrs.HasAccessAttribute)
	            {
	                extraAttributes.Add(DeclaringType.GetAccessAttribute());
	            }
	            foreach (var item in modifierAttrs)
	            	extraAttributes.Add(item);
	            foreach (var item in Syntax.Signature.Attributes)
	            	extraAttributes.Add(item.CreateAttribute(state, this));

	            extraAttributes.AddRange(Syntax.GetDescriptionAttributes(GetSyntaxState()));

	            attrCache = extraAttributes.ToArray();
            }
            return attrCache;
        }

        #endregion GetBaseProperties

        private IProperty[] basePropertyCache;
        public [IProperty] BaseProperties { const get return GetBaseProperties(); }

        public virtual [IProperty] GetBaseProperties()
        {
        	if (basePropertyCache == null)
        	{
	        	var state = GetSyntaxState();
	        	var baseMethods = new HashSet<IProperty>();
	        	var paramTypes = this.GetIndexerParameters().GetTypes();
	        	foreach (var item in Syntax.ImplementedProperties)
	            {
	                var member = Enumerable.OfType<IProperty>(item.GetAccessedMembers(state)).GetProperty(this.IsStatic, this.PropertyType, paramTypes);
	                baseMethods.Add(member);
	            }
	            if (baseMethods.Count == 0)
	            {
	            	foreach (var item in DeclaringType.GetAllBaseTypes())
	            	{
	            		var match = item.GetProperties().GetProperty(this.Name, this.IsStatic, this.PropertyType, paramTypes);
	            		if (match != null)
	            		{
	            			baseMethods.Add(match);
	            		}
	            	}
	            	if (baseMethods.Count == 0 && Syntax.Signature.ModifierTokens.IsOverride)
	            	{
	            		state.Log.LogError(new LogEntry("Base property missing",
                            "Override property '" + FullName + "' could not find any suitable base properties to override.",
                            Location));
	            	}
	            }
	            basePropertyCache = Enumerable.ToArray<IProperty>(baseMethods);
            }
            return basePropertyCache;
        }

        #region

        #endregion

        #region CodeMember Implementation

        public override string GetHeaderString()
        {
            return Syntax.Signature.GetCode().ToString();
        }

        public override CodeBuilder GetBodyCode()
        {
            CodeBuilder cb = new CodeBuilder();
            cb.AddLine("{");
            cb.IncreaseIndentation();
            foreach (var item in Syntax.Accessors)
            {
                cb.AddCodeBuilder(item.GetCode());
            }
            cb.IncreaseIndentation();
            cb.AddLine("}");
            return cb;
        }

        #endregion

        #region ISyntaxNode Implementation

        public CodeBuilder GetCode()
        {
            return Syntax.GetCode();
        }

        #endregion

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is SyntaxProperty)
            {
            	var syntaxProp = (SyntaxProperty)obj;
                return DeclaringType.Equals(syntaxProp.DeclaringType) && Syntax.Equals(syntaxProp.Syntax);
            }
            else
            {
                return false;
            }
        }

        #endregion
    }
}
