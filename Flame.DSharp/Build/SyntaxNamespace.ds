using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Binding;
using Flame.Compiler;
using Flame.Syntax;

namespace Flame.DSharp.Build
{
	public abstract class SyntaxNamespaceBase : INamespaceBranchBuilder
	{
		public const this()
		{
			this.namespaceList = new List<INamespace>();
			this.typeList = new List<IType>();
			this.cachedGraph = new Lazy<AncestryGraph>(RetrieveAncestryGraph);
		}

		public abstract string FullName { get; }
		public abstract string Name { get; }
		public abstract IAssembly DeclaringAssembly { get; }
		public abstract IExtensionTypeProvider ExtensionTypeProvider { get; }
		public abstract IConverter<IType, string> TypeNamer { get; }

		private List<INamespace> namespaceList;
		private List<IType> typeList;

		public [INamespace] NestedNamespaces { const get { return namespaceList; } }
		public [IType] Types { const get { return typeList; } }

		private Lazy<AncestryGraph> cachedGraph;
		public AncestryGraph Graph
		{
			const get { return cachedGraph.Value; }
		}

		private AncestryGraph RetrieveAncestryGraph()
		{
			return DeclaringAssembly.GetAncestryGraph();
		}

		public [IAttribute] Attributes
		{
			const get { return new IAttribute[] { new AncestryGraphAttribute(Graph) }; }
		}

		public [INamespaceBranch] Namespaces
		{
			const get
			{
				return Enumerable.Concat<INamespaceBranch>(
						   Enumerable.OfType<INamespaceBranch>(NestedNamespaces),
						   Enumerable.OfType<INamespaceBranch>(Types));
			}
		}

		public void AddNamespace(INamespace Namespace)
		{
			this.namespaceList.Add(Namespace);
		}
		public void AddType(IType Type)
		{
			this.typeList.Add(Type);
		}
	}

	public class SyntaxNamespace : SyntaxNamespaceBase, ISyntaxNode
	{
		public const this(set string name, set INamespaceBranchBuilder DeclaringNamespace);

		private string name;
		public INamespaceBranchBuilder DeclaringNamespace { const get; private set; }

		public override string FullName { const get return MemberExtensions.CombineNames(DeclaringNamespace.FullName, Name); }
		public override string Name { const get return name; }
		public override IAssembly DeclaringAssembly { const get return DeclaringNamespace.DeclaringAssembly; }
		public override IExtensionTypeProvider ExtensionTypeProvider { const get return DeclaringNamespace.ExtensionTypeProvider; }
		public override IConverter<IType, string> TypeNamer { const get return DeclaringNamespace.TypeNamer; }

		public const CodeBuilder GetCode()
		{
			var cb = new CodeBuilder();
			cb.AddLine("namespace " + Name);
			cb.AddLine("{");
			cb.IncreaseIndentation();
			foreach (var item in Namespaces)
				if (item is ISyntaxNode)
					cb.AddCodeBuilder(((ISyntaxNode)item).GetCode());
			foreach (var item in Types)
				if (item is ISyntaxNode)
					cb.AddCodeBuilder(((ISyntaxNode)item).GetCode());
			cb.DecreaseIndentation();
			cb.AddLine("}");
			return cb;
		}

		public override const string ToString()
		{
			return "namespace " + Name;
		}
	}
}
