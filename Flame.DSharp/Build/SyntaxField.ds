using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
	public class SyntaxField : CodeMember, IDSharpField, ISyntaxNode
    {
        public const this(set FieldSyntax Syntax, set ISyntaxState State);

        public FieldSyntax Syntax { const get; private set; }
        public ISyntaxState State { const get; private set; }

        #region CodeMember Implementation

        public string Name
        {
            const get { return Syntax.Name; }
        }

        public string FullName
        {
            const get { return MemberExtensions.CombineNames(DeclaringType.FullName, Name); }
        }

        public override const string GetHeaderString()
        {
            return Syntax.GetCode().ToString();
        }

        public override const CodeBuilder GetBodyCode()
        {
            return null;
        }

        #endregion

		#region ISourceMember Implementation

		public SourceLocation Location
		{
			const get return Syntax.NameLocation;
		}

		#endregion

		private IExpression cachedFieldValue;
		private const IExpression GetValue(bool UseDefault)
		{
			if (cachedFieldValue == null)
			{
				if (UseDefault && Syntax.FieldValueSyntax == null)
	            {
	                cachedFieldValue = new DefaultValueExpression(FieldType);
	            }
	            else
	            {
	                cachedFieldValue = Syntax.FieldValueSyntax.CreateVerifiedExpression(State);
	            }
            }
            return cachedFieldValue;
		}

        public const IExpression GetValue()
        {
        	return GetValue(true);
        }

		private IType cachedFieldType;
        public IType FieldType
        {
            const get
            {
            	if (cachedFieldType == null)
            	{
	                var type = Syntax.Signature.TypeSyntax;
	                if (type.IsVariable)
	                {
	                    cachedFieldType = GetValue(false).Type;
	                }
	                else
	                {
	                    cachedFieldType = type.CreateVerifiedType(State);
	                }
                }
                return cachedFieldType;
            }
        }

        /*public const IBoundObject GetField(IBoundObject Target)
        {
            if (this.IsConstant && this.IsStatic)
            {
                return GetValue().Evaluate();
            }
            return null;
        }

        public void SetField(IBoundObject Target, IBoundObject Value)
        {
            return null;
        }*/

        public IType DeclaringType
        {
            const get
            {
                return State.DeclaringType;
            }
        }

        public bool IsStatic
        {
            const get { return (Syntax.Signature.ModifierTokens.IsStatic && !DeclaringType.IsSingleton) || this.IsConstant; }
        }


		private IAttribute[] attrCache;
        public const [IAttribute] GetAttributes()
        {
        	if (attrCache == null)
        	{
	            var modifierAttrs = Syntax.Signature.ModifierTokens.GetModifiers();
	            var extraAttributes = new List<IAttribute>();

	            if (!modifierAttrs.HasAccessAttribute)
	                extraAttributes.Add(DeclaringType.GetAccessAttribute());

	            foreach (var item in modifierAttrs)
	            	extraAttributes.Add(item);

	            foreach (var item in Syntax.Signature.Attributes)
	            	extraAttributes.Add(item.CreateAttribute(State, this));

	            extraAttributes.AddRange(Syntax.GetDescriptionAttributes(State));

	            attrCache = extraAttributes.ToArray();
            }
            return attrCache;
        }

        public const CodeBuilder GetCode()
        {
            return Syntax.GetCode();
        }

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is SyntaxField)
            {
            	var syntaxField = (SyntaxField)obj;
                return DeclaringType.Equals(syntaxField.DeclaringType) && Syntax.Equals(syntaxField.Syntax);
            }
            else
            {
                return false;
            }
        }

        #endregion
    }
}
