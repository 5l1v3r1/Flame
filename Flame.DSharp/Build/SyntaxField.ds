using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
	public class SyntaxField : CodeMember, IDSharpField, ISyntaxNode
    {
        public const this(set FieldSyntax Syntax, set ISyntaxState State)
		{
			this.attrCache = new Lazy<AttributeMap>(CreateAttributes);
		}

        public FieldSyntax Syntax { const get; private set; }
        public ISyntaxState State { const get; private set; }

        #region CodeMember Implementation

        public UnqualifiedName Name
        {
            const get { return new SimpleName(Syntax.Name); }
        }

        public QualifiedName FullName
        {
            const get { return Name.Qualify(DeclaringType.FullName); }
        }

        public override const string GetHeaderString()
        {
            return Syntax.GetCode().ToString();
        }

        public override const CodeBuilder GetBodyCode()
        {
            return null;
        }

        #endregion

		#region ISourceMember Implementation

		public SourceLocation Location
		{
			const get return Syntax.NameLocation;
		}

		#endregion

		private IExpression cachedFieldValue;
		private const IExpression GetValue(bool UseDefault)
		{
			if (cachedFieldValue == null)
			{
				if (UseDefault && Syntax.FieldValueSyntax == null)
	            {
	                cachedFieldValue = new DefaultValueExpression(FieldType);
	            }
	            else
	            {
	                cachedFieldValue = CastSyntax.CreateImplicitCast(
						State,
						Syntax.FieldValueSyntax,
						FieldType);
	            }
            }
            return cachedFieldValue;
		}

        public const IExpression GetValue()
        {
        	return GetValue(true);
        }

		private IType cachedFieldType;
        public IType FieldType
        {
            const get
            {
            	if (cachedFieldType == null)
            	{
	                var type = Syntax.Signature.TypeSyntax;
	                if (type.IsVariable)
	                {
	                    cachedFieldType = GetValue(false).Type;
	                }
	                else
	                {
	                    cachedFieldType = type.CreateVerifiedType(State);
	                }
                }
                return cachedFieldType;
            }
        }

        /*public const IBoundObject GetField(IBoundObject Target)
        {
            if (this.IsConstant && this.IsStatic)
            {
                return GetValue().Evaluate();
            }
            return null;
        }

        public void SetField(IBoundObject Target, IBoundObject Value)
        {
            return null;
        }*/

        public IType DeclaringType
        {
            const get
            {
                return State.DeclaringType;
            }
        }

        public bool IsStatic
        {
            const get
			{
				return DeclaringType.IsStaticType
					|| (Syntax.Signature.ModifierTokens.IsStatic && !DeclaringType.IsSingleton)
					|| this.IsConstant;
			}
        }

		public AttributeMap Attributes { get { return attrCache.Value; } }

		private Lazy<AttributeMap> attrCache;

		private AttributeMap CreateAttributes()
		{
			var modifierAttrs = Syntax.Signature.ModifierTokens.GetModifiers();
			var results = new AttributeMapBuilder();

			if (!modifierAttrs.HasAccessAttribute)
				results.Add(DeclaringType.GetAccessAttribute());

			results.AddRange(modifierAttrs);

			foreach (var item in Syntax.Signature.Attributes)
				results.Add(item.CreateAttribute(State, this));

			results.AddRange(Syntax.GetDescriptionAttributes(State));

			return new AttributeMap(results);
		}

        public const CodeBuilder GetCode()
        {
            return Syntax.GetCode();
        }

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is SyntaxField)
            {
            	var syntaxField = (SyntaxField)obj;
                return DeclaringType.Equals(syntaxField.DeclaringType) && Syntax.Equals(syntaxField.Syntax);
            }
            else
            {
                return false;
            }
        }

        #endregion
    }
}
