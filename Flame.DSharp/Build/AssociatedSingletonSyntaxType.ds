using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
	public class AssociatedSingletonSyntaxType : IType, IEquatable<IType>
	{
		public const this(set ISyntaxState InstanceState, set TypeDeclarationSyntax Syntax);

		public ISyntaxState InstanceState { const get; private set; }
		public IType InstanceType { const get return InstanceState.CurrentType; }
		public TypeDeclarationSyntax Syntax { const get; private set; }

        public const ISyntaxState GetSyntaxState()
        {
	    	var descMethod = new DescribedMethod();
			descMethod.DeclaringType = this;

            return new SyntaxState(descMethod, InstanceState.Binder,
				InstanceState.Log, InstanceState.MemberProvider,
				InstanceState.TypeNamer);
        }

		public string Name { const get return "Static_Singleton"; }
		public string FullName { const get return MemberExtensions.CombineNames(DeclaringNamespace.FullName, Name); }
		public INamespace DeclaringNamespace { const get return (INamespace)InstanceType; }

		public [IAttribute] Attributes { const get return GetAttributes(); }
		private [IAttribute] attrCache;
		public const IEnumerable<IAttribute> GetAttributes()
		{
			if (attrCache == null)
			{
				List<IAttribute> attrs = new List<IAttribute>();
				attrs.Add(new AccessAttribute(AccessModifier.Public));
				attrs.Add(PrimitiveAttributes.HiddenAttribute);
				attrs.Add(new AssociatedTypeAttribute(InstanceType));
				attrs.Add(new SingletonAttribute("Instance"));
		    	if (InstanceType.IsAbstract || InstanceType.IsVirtual)
		    	{
		    		attrs.Add(PrimitiveAttributes.VirtualAttribute);
		    	}
		    	this.attrCache = attrs;
	    	}
			return attrCache;
		}

		public bool IsContainerType { const get return false; }
		public const IContainerType AsContainerType() return null;
		public const IType GetGenericDeclaration() return this;
		public const IType MakeGenericType(IEnumerable<IType> TypeArguments) return null;
		public const [IType] GetGenericArguments() return Enumerable.Empty<IType>();
		public const [IGenericParameter] GetGenericParameters() return Enumerable.Empty<IGenericParameter>();
		public const IArrayType MakeArrayType(int Rank) return new DescribedArrayType(this, Rank);
		public const IVectorType MakeVectorType(int[] Dimensions) return new DescribedVectorType(this, Dimensions);
		public const IPointerType MakePointerType(PointerKind PtrType) return new DescribedPointerType(this, PtrType);
		public const IBoundObject GetDefaultValue()
		{
			return null;
		}

		private IType[] baseTypes;
		public const IType[] GetBaseTypes()
		{
			if (baseTypes == null)
			{
				var instanceParent = InstanceType.GetParent();
				while (instanceParent != null)
				{
					var associated = instanceParent.GetAssociatedSingleton();
					if (associated != null)
					{
						baseTypes = new IType[] { associated };
						return baseTypes;
					}
					instanceParent = instanceParent.GetParent();
				}
				// No 'real' base types found. Look for root type
				var rootType = InstanceState.Binder.Environment.RootType;
            	if (rootType != null)
            		baseTypes = new IType[] { rootType };
            	else
					baseTypes = new IType[0];
			}
			return baseTypes;
		}

		private IMethod[] methodCache;
		private void BuildMethodCache()
		{
			if (methodCache == null)
			{
				var state = GetSyntaxState();
	        	var methods = new List<IMethod>();

	        	foreach (var item in Syntax.Methods)
        		if (item.IsSingletonMember)
        		{
	        		methods.Add(item.CreateMember(state));
        		}

        		methods.AddRange(DSharpTypeExtensions.GenerateOperators(methods, state));

	            methodCache = methods.ToArray();
            }
		}

		private IMethod[] noCtorCache;
		public const IMethod[] GetMethods()
		{
			if (noCtorCache == null)
			{
				BuildMethodCache();
				List<IMethod> methods = new List<IMethod>();
				foreach (var item in methodCache)
				if (!item.IsConstructor)
				{
					methods.Add(item);
				}

				noCtorCache = methods.ToArray();
            }
            return noCtorCache;
		}

		private IMethod[] ctorCache;
		public const IMethod[] GetConstructors()
		{
			if (ctorCache == null)
			{
				BuildMethodCache();
				List<IMethod> methods = new List<IMethod>();

				foreach (var item in methodCache)
				if (item.IsConstructor)
				{
					methods.Add(item);
				}

				if (methods.Count == 0)
		    	{
		    		var state = GetSyntaxState();
		    		var defaultCtor = DSharpTypeExtensions.CreateParameterlessConstructor(state);
	            	methods.Add(defaultCtor);
		    	}

				ctorCache = methods.ToArray();
            }
            return ctorCache;
		}

		private FieldProperty singletonInstanceProp;
		public FieldProperty SingletonInstanceProperty
		{
			const get
			{
				if (singletonInstanceProp == null)
				{
					singletonInstanceProp = SingletonInstanceAccessor.CreateAccessorProperty(GetSyntaxState());
				}
		    	return singletonInstanceProp;
			}
		}

		private FieldProperty[] fieldPropertyCache;
		public const FieldProperty[] GetFieldProperties()
		{
			if (fieldPropertyCache == null)
			{
			   	var state = GetSyntaxState();
	        	var props = new List<FieldProperty>();

	        	foreach (var item in Syntax.FieldProperties)
	        		if (item.IsSingletonMember)
	        	{
        			props.Add(item.CreateMember(state));
	        	}

		    	props.Add(SingletonInstanceProperty);

	            fieldPropertyCache = props.ToArray();
			}
			return fieldPropertyCache;
		}

		private IProperty[] propertyCache;
		public const IProperty[] GetProperties()
		{
			if (propertyCache == null)
        	{
        		var state = GetSyntaxState();
	        	var props = new List<IProperty>();
	        	foreach (var item in Syntax.Properties)
	        	if (item.IsSingletonMember)
	        	{
        			props.Add(item.CreateMember(state));
	        	}

		    	foreach (var item in GetFieldProperties())
		    	{
		    		props.Add(item.Property);
		    	}

	            propertyCache = props.ToArray();
            }
            return propertyCache;
		}

		private IField[] fieldCache;
		public const IField[] GetFields()
		{
			if (fieldCache == null)
        	{
        		var state = GetSyntaxState();
	        	var fields = new List<IField>();
	        	foreach (var item in Syntax.Fields)
	        	if (item.IsSingletonMember)
	        	{
	        		fields.Add(item.CreateMember(state));
	        	}

	        	foreach (var item in GetFieldProperties())
		    	{
		    		fields.Add(item.Field);
		    	}

	            fieldCache = fields.ToArray();
            }
            return fieldCache;
		}

		public const ITypeMember[] GetMembers()
		{
			List<ITypeMember> members = new List<ITypeMember>();
			foreach (var item in GetFields())
				members.Add(item);
			foreach (var item in GetProperties())
				members.Add(item);
			foreach (var item in GetMethods())
				members.Add(item);
			foreach (var item in GetConstructors())
				members.Add(item);
			return members.ToArray();
		}

		public const bool Equals(AssociatedSingletonSyntaxType Other)
		{
			return InstanceType.Equals(Other.InstanceType);
		}
		public const bool Equals(IType Other)
		{
			if (Other is AssociatedSingletonSyntaxType)
			{
				return Equals((AssociatedSingletonSyntaxType)Other);
			}
			else return false;
		}
		public override const bool Equals(object Other)
		{
			if (Other is IType)
			{
				return Equals((IType)Other);
			}
			else return false;
		}
		public override const int GetHashCode()
		{
			return InstanceType.GetHashCode() ^ Name.GetHashCode();
		}

		public override const string operator cast()
		{
			return FullName;
		}
	}
}
