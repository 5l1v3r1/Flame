using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.Compiler.Build;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.DSharp.Lexer;
using Flame.Syntax;
using Flame.Syntax.DSharp;

namespace Flame.DSharp.Build
{
    public abstract class SyntaxTypeBase : CodeMember, IDSharpSyntaxType, IInvariantType
    {
    	public const this()
    	{
    		this.AllowMemberCaching = true;
    	}
        public const this(set INamespace DeclaringNamespace)
        {
            this.AllowMemberCaching = true;
        }

        public const ITypeDeclarationSyntax GetSyntax() : IDSharpSyntaxType.GetSyntax
        {
            return Syntax;
        }

		public abstract const TypeDeclarationSyntax GetTypeSyntax();

        public TypeDeclarationSyntax Syntax { const get return GetTypeSyntax(); }

        public INamespace DeclaringNamespace { const get; protected set; }

        public abstract ISyntaxState GetSyntaxState();
        protected abstract ISyntaxState GetNamespaceSyntaxState();

        #region ISourceMember Implementation

        public SourceLocation Location
        {
            const get return Syntax.NameLocation;
        }

        #endregion

        #region IMember

        public virtual string Name
        {
            const get { return Syntax.Signature.NameToken.TokenValue; }
        }

        public virtual string FullName
        {
            const get { return MemberExtensions.CombineNames(DeclaringNamespace.FullName, Name); }
        }

		public bool HasStaticModifier
		{
			const get return Syntax.Signature.ModifierTokens.IsStatic;
		}

		public bool IsExtensionType
		{
			const get
			{
				foreach (var member in Syntax.Members)
	            {
	            	if (member.IsExtensionMember)
	            	{
	            		return true;
	            	}
	            }
	            return false;
			}
		}

		public bool HasAssociatedSingleton
		{
			const get
			{
				if (!HasStaticModifier)
    			{
    				foreach (var item in Syntax.Members)
    				{
    					if (item.IsSingletonMember)
    					{
    						return true;
    					}
    				}
    			}
    			return false;
			}
		}

		private AncestryGraph RetrieveAncestryGraph()
		{
			if (DeclaringNamespace == null)
			{
				return new AncestryGraph();
			}
			else
			{
				return DeclaringNamespace.GetAncestryGraph();
			}
		}

		private IAttribute[] attrCache;
		public [IAttribute] Attributes { const get return GetAttributes(); }

        public virtual [IAttribute] GetAttributes()
        {
        	if (attrCache == null)
        	{
	            var state = GetSyntaxState();
	            var modifiers = Syntax.Signature.ModifierTokens;
	            List<IAttribute> attrs = new List<IAttribute>();
	            attrs.Add(new AncestryGraphAttribute(RetrieveAncestryGraph()));
	            attrs.AddRange(modifiers.GetModifiers());
	            if (IsExtensionType)
	            {
	            	attrs.Add(PrimitiveAttributes.ExtensionAttribute);
	            	if (modifiers.IsStatic)
	            	{
	            		attrs.Add(PrimitiveAttributes.StaticTypeAttribute);
	            	}
	            }
	            else if (modifiers.IsStatic)
	            {
	            	attrs.Add(new SingletonAttribute("Instance"));
	            }

	            foreach (var item in Syntax.Signature.Attributes)
	            {
	            	attrs.Add(item.CreateAttribute(state, this));
	            }

	            foreach (var related in AssociatedTypes)
	            {
	            	attrs.Add(new AssociatedTypeAttribute(related));
	            }

	            attrs.AddRange(Syntax.Signature.GetDescriptionAttributes(GetNamespaceSyntaxState()));

	            if (this.AllowMemberCaching)
	            	this.attrCache = attrs.ToArray();
	            return attrs;
            }
            return this.attrCache;
        }

        #endregion

        #region INamespace

		private IType[] nestedTypeCache;
		public IType[] NestedTypes { const get return GetTypes(); }

        public const IType[] GetTypes()
        {
        	if (nestedTypeCache == null)
        	{
	            var state = GetSyntaxState();
	            var types = new List<IType>();
	            foreach (var item in Syntax.Types)
	            {
	            	types.Add(item.CreateMember(state));
	            }
	            foreach (var item in AssociatedTypes)
	            if (item.DeclaringNamespace is IType)
	            if (((IType)item.DeclaringNamespace).GetGenericDeclaration().Equals(this))
	            {
	            	types.Add(item);
	            }
	            nestedTypeCache = types.ToArray();
            }
            return nestedTypeCache;
        }

		public [INamespaceBranch] NestedNamespaces { const get return GetNamespaces(); }
        public const [INamespaceBranch] GetNamespaces()
        {
            var state = GetSyntaxState();
            List<INamespaceBranch> branches = new List<INamespaceBranch>();
            foreach (var item in Syntax.Types)
            {
            	var member = item.CreateMember(state);
            	if (member is INamespaceBranch)
            	{
            		branches.Add(member);
            	}
            }
            return branches;
        }

        public IAssembly DeclaringAssembly
        {
            const get { return DeclaringNamespace.DeclaringAssembly; }
        }

        #endregion

        #region Associated Types

        /// <summary>
        /// Gets all associated types for this type.
        /// </summary>
        public IType[] AssociatedTypes
        {
        	const get
        	{
        		if (AllowMemberCaching && typeMemberCache.ContainsKey("AssociatedTypes"))
        		{
        			return (IType[])typeMemberCache["AssociatedTypes"];
        		}
        		else
        		{
        			var related = new List<IType>();
        			if (HasAssociatedSingleton)
        			{
        				related.Add(new AssociatedSingletonSyntaxType(GetSyntaxState(), Syntax));
        			}
        			var relatedArr = related.ToArray();

        			if (AllowMemberCaching)
        				typeMemberCache["AssociatedTypes"] = relatedArr;

        			return relatedArr;
        		}
        	}
        }

        #endregion

        #region IType

        private Dictionary<string, object> typeMemberCache;

        protected bool AllowMemberCaching
        {
            const get
            {
                return typeMemberCache != null;
            }
            set
            {
                if (!value)
                {
                    typeMemberCache = (Dictionary<string, object>)null;
                    attrCache = null;
                }
                else if (typeMemberCache == null)
                {
                    typeMemberCache = new Dictionary<string, object>();
                }
            }
        }

        protected T[] CreateTypeMembers<T>([IMemberSyntax<T>] Syntax, string CacheKey) where T : ITypeMember
        {
            if (AllowMemberCaching && typeMemberCache.ContainsKey(CacheKey))
            {
                return (T[])typeMemberCache[CacheKey];
            }
            else
            {
                var value = CreateTypeMembers<T>(Syntax);
                if (AllowMemberCaching)
                {
                    typeMemberCache[CacheKey] = value;
                }
                return value;
            }
        }
        protected T[] CreateTypeMembers<T>([IMemberSyntax<T>] Syntax)
            where T : ITypeMember
        {
            var state = GetSyntaxState();
            List<T> members = new List<T>();
            bool isStaticType = this.IsSingleton || this.IsExtensionType;
            foreach (var item in Syntax)
                if (isStaticType || !item.IsSingletonMember)
            {
            	members.Add(item.CreateMember(state));
            }
            return members.ToArray();
        }

        public virtual ITypeMember[] GetMembers()
        {
            return CreateTypeMembers<ITypeMember>(Syntax.GetMembersOfType<ITypeMember>());
        }

        protected FieldProperty GetSingletonInstanceProperty()
        {
        	if (AllowMemberCaching && typeMemberCache.ContainsKey("Instance"))
        	{
        		return (FieldProperty)typeMemberCache["Instance"];
        	}
        	else
        	{
        		var instProp = SingletonInstanceAccessor.CreateAccessorProperty(GetSyntaxState());
        		if (AllowMemberCaching)
        		{
        			typeMemberCache["Instance"] = instProp;
        		}
        		return instProp;
        	}
        }

        protected IEnumerable<FieldProperty> GetFieldProperties()
        {
        	var definedFieldProps = (IEnumerable<FieldProperty>)CreateTypeMembers<FieldProperty>(Syntax.FieldProperties, "FieldProperties");
        	if (this.IsSingleton)
        	{
        		return Enumerable.Concat<FieldProperty>(definedFieldProps, new FieldProperty[] { GetSingletonInstanceProperty() });
        	}
        	else
        	{
            	return definedFieldProps;
            }
        }

        private const IExpression CreateNotThisOp(IMethod Method, Operator Op)
        {
        	//return new NotExpression(new InvocationExpression(Method, new ThisVariable(GetSyntaxState().CurrentType).CreateGetExpression(), (IEnumerable<IExpression>)new IExpression[0]));
        	return new NotExpression(new DirectBinaryExpression(new ThisVariable(GetSyntaxState().CurrentType).CreateGetExpression(), Op, new ArgumentVariable(Method.GetParameters()[0], 0).CreateGetExpression()));
        }

        private const IMethod CreateNotOperator(IMethod Method, Operator Op)
        {
    	    var bodyMethod = new DescribedBodyMethod("operator" + Op.ToString(), this, Method.ReturnType, false);
    	    foreach (var item in Method.GetParameters())
    	    {
    	    	bodyMethod.AddParameter(item);
    	    }
    		bodyMethod.AddAttribute(new OperatorAttribute(Op));
    		if (Method.IsConstant)
    		{
    			bodyMethod.AddAttribute(PrimitiveAttributes.ConstantAttribute);
    		}
    		bodyMethod.Body = new ReturnStatement(CreateNotThisOp(bodyMethod, Method.GetOperator()));
    		return bodyMethod;
        }

		private IMethod[] methodCache;
        public virtual IMethod[] GetMethods()
        {
        	if (methodCache == null)
        	{
	        	var methods = new List<IMethod>();
	        	foreach (var item in CreateTypeMembers<IMethod>(Syntax.Methods, "Methods"))
	        	{
	        		if (!item.IsConstructor)
	        			methods.Add(item);
	        	}

	        	var state = GetSyntaxState();

	        	methods.AddRange(DSharpTypeExtensions.GenerateOperators(methods, state));

	            methodCache = methods.ToArray();
            }
            return methodCache;
        }
        public IMethod[] Methods { const get return GetMethods(); }

        public virtual IProperty[] GetProperties()
        {
        	var properties = new List<IProperty>(CreateTypeMembers<IProperty>(Syntax.Properties, "Properties"));
        	foreach (var item in GetFieldProperties())
        	{
        		properties.Add(item.Property);
        	}
        	return properties.ToArray();
        }
        public IProperty[] Properties { const get return GetProperties(); }

        public virtual IField[] GetFields()
        {
            var normalTypeMembers = CreateTypeMembers<IField>(Syntax.Fields, "Fields");
            if (!this.IsInterface)
            {
            	var allFields = new List<IField>(normalTypeMembers);
            	foreach (var item in GetFieldProperties())
            	{
            		allFields.Add(item.Field);
            	}
            	return allFields.ToArray();
            }
            else
            {
                return normalTypeMembers;
            }
        }
        public IField[] Fields { const get return GetFields(); }

        public virtual IMethod[] GetConstructors()
        {
        	bool hasInstanceCtors = false;
            var methods = new List<IMethod>();
        	foreach (var item in CreateTypeMembers<IMethod>(Syntax.Methods, "Methods"))
        	{
        		if (item.IsConstructor)
        		{
        			methods.Add(item);
        			if (!item.IsStatic)
        			{
        				hasInstanceCtors = true;
        			}
        		}
        	}
        	if (!hasInstanceCtors && !this.IsInterface && !this.IsValueType && !this.IsEnum && (this.IsSingleton || !this.HasStaticModifier))
        	{
        		var defaultCtor = DSharpTypeExtensions.CreateParameterlessConstructor(GetSyntaxState());
            	methods.Add(defaultCtor);
        	}
            return methods.ToArray();
        }
        public IMethod[] Constructors { const get return GetConstructors(); }

        public virtual [IInvariant] GetInvariants()
        {
            return CreateTypeMembers<IInvariant>(Syntax.Invariants, "Invariants");
        }
        public [IInvariant] Invariants { const get return GetInvariants(); }

        public IBoundObject GetDefaultValue()
        {
            return null;
        }

        public virtual IType[] GetBaseTypes()
        {
            if (AllowMemberCaching && typeMemberCache.ContainsKey("BaseTypes"))
            {
                return (IType[])typeMemberCache["BaseTypes"];
            }
            var state = GetSyntaxState();
            List<IType> bTypes = new List<IType>();
            bool allInterfaces = true;
            foreach (var item in Syntax.Signature.BaseTypes)
            {
            	var type = item.CreateVerifiedType(state);
            	if (type != null)
            	{
	            	if (allInterfaces && !type.IsInterface)
	            		allInterfaces = false;
	            	bTypes.Add(type);
            	}
            }
            if (allInterfaces && !this.IsInterface)
            {
            	var rootType = state.Binder.Environment.RootType;
            	if (rootType != null)
            		bTypes.Add(rootType);
            }

            var baseTypes = bTypes.ToArray();

            if (AllowMemberCaching)
            {
                typeMemberCache["BaseTypes"] = baseTypes;
            }
            return baseTypes;
        }
        public IType[] BaseTypes { const get return GetBaseTypes(); }

        #region Container Type Functionality

        public bool IsContainerType
        {
            const get { return false; }
        }

        public IContainerType AsContainerType()
        {
            return null;
        }

        public IArrayType MakeArrayType(int Rank)
        {
            return new DescribedArrayType(this, Rank);
        }

        public IPointerType MakePointerType(PointerKind PointerKind)
        {
            return new DescribedPointerType(this, PointerKind);
        }

        public IVectorType MakeVectorType(int[] Dimensions)
        {
            return new DescribedVectorType(this, Dimensions);
        }

        #endregion

        #endregion

        #region Generics

        public virtual IType MakeGenericType([IType] TypeArguments)
        {
            var state = GetSyntaxState();
            return new ClosedGenericType(Syntax, DeclaringNamespace, state.Binder,
                state.Log, state.MemberProvider, state.TypeNamer, TypeArguments);
        }

        public virtual IType GetGenericDeclaration()
        {
            var state = GetNamespaceSyntaxState();
            return new OpenGenericType(Syntax, DeclaringNamespace, state.Binder,
                state.Log, state.MemberProvider, state.TypeNamer);
        }

		public [IGenericParameter] GenericParameters { const get return GetGenericParameters(); }

		protected virtual [IGenericParameter] CreateGenericParameters()
		{
			return DSharpTypeExtensions.CreateConstrainedGenericParameters(GetNamespaceSyntaxState(), this, Syntax.Signature.GenericDeclarations, Syntax.Signature.GenericConstraints);
		}

        public virtual [IGenericParameter] GetGenericParameters()
        {
            if (AllowMemberCaching && typeMemberCache.ContainsKey("GenericParameters"))
            {
                return ([IGenericParameter])typeMemberCache["GenericParameters"];
            }

            var genericParams = CreateGenericParameters();

        	if (AllowMemberCaching)
        	{
            	typeMemberCache["GenericParameters"] = genericParams;
        	}

        	return genericParams;
        }

        public abstract [IType] GetGenericArguments();

        #endregion

        #region Equality

        public override int GetHashCode()
        {
            return Syntax.GetHashCode();
        }

        public override bool Equals(object obj)
        {
            if (obj is OpenGenericType)
            {
                return (this is OpenGenericType) && this.Syntax.Equals(((SyntaxTypeBase)obj).Syntax);
            }
            else if (obj is SyntaxTypeBase)
            {
                bool syntaxSame = this.Syntax.Equals(((SyntaxTypeBase)obj).Syntax);
                if (syntaxSame)
                {
                    var genArgs1 = Enumerable.ToArray<IType>(GetGenericArguments());
                    var genArgs2 = Enumerable.ToArray<IType>(((SyntaxTypeBase)obj).GetGenericArguments());

					return genArgs1.AreEqual(genArgs2);
                }
            }
            return false;
        }

        #endregion

        #region Code

        public override const string GetHeaderString()
        {
            return Syntax.Signature.GetCode().ToString();
        }

        public override const CodeBuilder GetBodyCode()
        {
            CodeBuilder cb = new CodeBuilder();
            cb.AddLine("{");
            cb.IncreaseIndentation();
            foreach (var item in Syntax.Members)
            {
                cb.AddCodeBuilder(item.GetCode());
            }
            foreach (var item in Syntax.Types)
            {
                cb.AddCodeBuilder(item.GetCode());
            }
            cb.DecreaseIndentation();
            cb.AddLine("}");
            return cb;
        }

        public const CodeBuilder GetCode()
        {
            return Syntax.GetCode();
        }

        #endregion
    }
}
