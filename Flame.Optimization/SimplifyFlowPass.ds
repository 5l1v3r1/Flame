using System;
using Flame.Compiler;
using Flame.Compiler.Statements;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// Defines a flow simplification pass: a pass that will simplify control flow statements.
    /// Applying this pass can simplify the code generated by the back-end,
    /// and allow other passes to make more accurate predictions about control flow.
    ///
    /// This pass will reduce high-level control flow into lower-level constrol flow,
    /// usually tagged statements, if it deems said operation possibly profitable, but will not
    /// attempt to convert low-level control flow into higher-level control flow,
    /// regardless of the feasibility of the operation.
    /// </summary>
    /// <remarks>
    /// Currently, this pass does the following:
    ///   * Remove final 'break' statements from tagged statements, and then
    ///     try to reduce those to sequential flow.
    ///   * Convert 'while' blocks that end in 'break' statements
    ///     into 'if' blocks wrapped by a tagged statement,
    ///     and try to reduce those to sequential flow.
    ///   * Convert 'do...while' blocks that end in 'break' statements
    ///     into tagged statements, and try to reduce those to sequential flow.
    /// </remarks>
    public static class SimplifyFlowPass : IPass<IStatement, IStatement>
    {
        private const bool MatchesTagged(IStatement Value)
        {
            return Value is TaggedStatement;
        }
        private const bool MatchesWhile(IStatement Value)
        {
            return Value is WhileStatement;
        }
        private const bool MatchesDoWhile(IStatement Value)
        {
            return Value is DoWhileStatement;
        }

        private const IStatement GetTaggedBody(IStatement Value)
        {
            return ((TaggedStatement)Value).Body;
        }

        private const IStatement GetWhileBody(IStatement Value)
        {
            return ((WhileStatement)Value).Body;
        }

        private const IStatement GetDoWhileBody(IStatement Value)
        {
            return ((DoWhileStatement)Value).Body;
        }

        private const bool MatchesFinalTaggedBreak(IStatement Flow, IStatement Final)
        {
            if (Final is BreakStatement)
            {
                return ((TaggedStatement)Flow).Tag == ((BreakStatement)Final).Target;
            }
            else return false;
        }

        private const bool MatchesFinalWhileBreak(IStatement Flow, IStatement Final)
        {
            if (Final is BreakStatement)
                return ((WhileStatement)Flow).Tag == ((BreakStatement)Final).Target;
            else
                return false;
        }

        private const bool MatchesFinalDoWhileBreak(IStatement Flow, IStatement Final)
        {
            if (Final is BreakStatement)
                return ((DoWhileStatement)Flow).Tag == ((BreakStatement)Final).Target;
            else
                return false;
        }

        private const IStatement TransformEnclosingTagged(IStatement Enclosing, IStatement Body)
        {
            var tagged = (TaggedStatement)Enclosing;
            return new TaggedStatement(tagged.Tag, Body).Simplify();
        }

        private const IStatement TransformEnclosingWhile(IStatement Enclosing, IStatement Body)
        {
            var whileBlock = (WhileStatement)Enclosing;
            var ifBlock = new IfElseStatement(whileBlock.Condition, Body).Simplify();
            return new TaggedStatement(whileBlock.Tag, ifBlock).Simplify();
        }

        private const IStatement TransformEnclosingDoWhile(IStatement Enclosing, IStatement Body)
        {
            var doWhileBlock = (DoWhileStatement)Enclosing;
            return new TaggedStatement(doWhileBlock.Tag, Body).Simplify();
        }

        public INodeVisitor TaggedBreakVisitor
        {
            const get return new FinalFlowVisitor(MatchesTagged,
                                                  GetTaggedBody,
                                                  MatchesFinalTaggedBreak,
                                                  TransformEnclosingTagged);
        }

        public INodeVisitor WhileBreakVisitor
        {
            const get return new FinalFlowVisitor(MatchesWhile,
                                                  GetWhileBody,
                                                  MatchesFinalWhileBreak,
                                                  TransformEnclosingWhile);
        }

        public INodeVisitor DoWhileBreakVisitor
        {
            const get return new FinalFlowVisitor(MatchesDoWhile,
                                                  GetDoWhileBody,
                                                  MatchesFinalDoWhileBreak,
                                                  TransformEnclosingDoWhile);
        }

        public IStatement Apply(IStatement Statement)
        {
            return TaggedBreakVisitor.Aggregate(WhileBreakVisitor)
                                     .Aggregate(DoWhileBreakVisitor)
                                     .Visit(Statement);
        }
    }
}
