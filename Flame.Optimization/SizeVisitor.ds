using System;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// A node visitor that computes an approximate size of a syntax tree.
    /// Metadata nodes are optionally ignored.
    /// </summary>
    public virtual class SizeVisitor : INodeVisitor
    {
        public const this(set bool IgnoreMetadata);

        /// <summary>
        /// Gets a boolean value that specifies whether metadata is ignored
        /// or not.
        /// </summary>
        public bool IgnoreMetadata { get; private set; }

        /// <summary>
        /// Gets the approximate total size of all syntax nodes this visitor
        /// has come across.
        /// </summary>
        public int Size { get; protected set; }

        /// <summary>
        /// Approximates the given statement's size, based on the given parameters.
        /// </summary>
        public static int ApproximateSize(IStatement Statement, bool IgnoreMetadata)
        {
            var visitor = new SizeVisitor(IgnoreMetadata);
            visitor.Visit(Statement);
            return visitor.Size;
        }

        /// <summary>
        /// Approximates the given statement's size. Metadata nodes are
        /// ignored.
        /// </summary>
        public static int ApproximateSize(IStatement Statement)
        {
            return ApproximateSize(Statement, true);
        }

        /// <summary>
        /// "Visits" an expression: an expression is taken as input and transformed into another expression.
        /// This is the default implementation of the 'Visit' method.
        /// </summary>
        protected IExpression DefaultVisitImpl(IExpression Value)
        {
            if (!IgnoreMetadata || !(Value is IMetadataNode<IExpression>))
                Size++;

            if (Value is IPredicateNode)
            {
                ((IPredicateNode)Value).AcceptPredicate(this);
                return Value;
            }
            else
            {
                Value.Accept(this);
                return Value;
            }
        }

        /// <summary>
        /// "Visits" an expression: an expression is taken as input and transformed into another expression.
        /// </summary>
        public virtual IExpression Visit(IExpression Value)
        {
            return DefaultVisitImpl(Value);
        }

        /// <summary>
        /// "Visits" a statement: an statement is taken as input and transformed into another statement.
        /// This is the default implementation of the 'Visit' method.
        /// </summary>
        protected IStatement DefaultVisitImpl(IStatement Value)
        {
            if (Value.IsEmpty)
                return Value;

            if (!IgnoreMetadata || !(Value is IMetadataNode<IStatement>))
                Size++;
            if (Value is IPredicateNode)
            {
                ((IPredicateNode)Value).AcceptPredicate(this);
                return Value;
            }
            else
            {
                Value.Accept(this);
                return Value;
            }
        }

        /// <summary>
        /// "Visits" a statement: an statement is taken as input and transformed into another statement.
        /// </summary>
        public virtual IStatement Visit(IStatement Value)
        {
            return DefaultVisitImpl(Value);
        }
    }

    /// <summary>
    /// A size visitor that is tailored for block duplication. It inflates the size of invocation expressions
    /// to make blocks that contain them less attractive for duplication; invocation expressions may be inlined
    /// duplicating blocks that contain them may needlessly increase code size.
    /// </summary>
    public class BlockDuplicationSizeVisitor : SizeVisitor
    {
        public this()
            : base(true)
        {
            this.InvocationExpressionSize = 6;
        }

        public this(int InvocationExpressionSize)
            : base(true)
        {
            this.InvocationExpressionSize = InvocationExpressionSize;
        }

        /// <summary>
        /// Gets or sets the size that is assigned to invocation expressions.
        /// </summary>
        /// <returns>The size that is assigned to invocation expressions.</returns>
        public int InvocationExpressionSize { get; private set; }

        /// <summary>
        /// "Visits" an expression: an expression is taken as input and transformed into another expression.
        /// </summary>
        public override IExpression Visit(IExpression Value)
        {
            if (Value is InvocationExpression)
            {
                var invExpr = (InvocationExpression)Value;
                Size += InvocationExpressionSize;
                invExpr.AcceptPredicate(this);
                return invExpr;
            }
            else
            {
                return DefaultVisitImpl(Value);
            }
        }
    }
}
