using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;
using Pixie;

namespace Flame.Optimization
{
    /// <summary>
    /// A method call that has been decomposed into a callee, a 'this' object,
    /// and a sequence of arguments.
    /// </summary>
    public class DissectedCall
    {
        /// <summary>
        /// Creates a new dissected call from the given 'this' value,
        /// callee, and sequence of arguments.
        /// </summary>
        public const this(
            set IExpression ThisValue, set IMethod Method,
            set [IExpression] Arguments);

        /// <summary>
        /// Gets the expression that produces the 'this' object for
        /// this call.
        /// </summary>
        public IExpression ThisValue { const get; private set; }

        /// <summary>
        /// Gets the callee of this call.
        /// </summary>
        public IMethod Method { const get; private set; }

        /// <summary>
        /// Gets the sequence of arguments that are passed to the
        /// callee.
        /// </summary>
        public [IExpression] Arguments { const get; private set; }
    }

    /// <summary>
    /// A pass that performs a number of iterations, which consist of
    /// inlining followed by whole-body optimization.
    /// </summary>
    public abstract class InliningPassBase : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// Gets the default inlining pass name.
        /// </summary>
        public const string InliningPassName = "inline";

        /// <summary>
        /// The remarks option for inlining: applying this pass to
        /// a function will emit a message if this is option set to true.
        /// </summary>
        public string InliningRemarksOption
        {
            get { return Flags.GetRemarkOptionName(InliningPassName); }
        }

        /// <summary>
        /// Creates a delegate that determines whether the given dissected
        /// direct call should be inlined.
        /// </summary>
        public abstract bool(DissectedCall) GetInliningCriteria(BodyPassArgument Argument);

        /// <summary>
        /// Creates a statement optimizer. Note that this should perform
        /// simple intraprocedural optimizations, rather than more advance
        /// optimizations, such as inlining.
        /// </summary>
        public abstract IStatement(IStatement) GetBodyOptimizer(BodyPassArgument Argument);

        /// <summary>
        /// Gets the number of times this pass is allowed to
        /// inline functions recursively. This corresponds
        /// to the maximal number of inline-optimize iterations this pass makes.
        /// </summary>
        public abstract int GetMaxRecursion(BodyPassArgument Argument);

        /// <summary>
        /// Names the given method. This includes any quotation marks, or other
        /// delimiters.
        /// </summary>
        protected virtual string NameMethod(IMethod Method)
        {
            string name = Method.Name;
            if (string.IsNullOrWhiteSpace(name))
                return "anonymous method";
            else
                return "'" + name + "'";
        }

        /// <summary>
        /// Logs a message that proclaims that an inlining operation
        /// has occurred.
        /// </summary>
        protected virtual void LogInlinedCall(
            BodyPassArgument Argument, SourceLocation CallLocation,
            DissectedCall InlinedCall, int RecursionDepth)
        {
            var nodes = new List<MarkupNode>();
            if (RecursionDepth == 0)
            {
                // Add a description
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                    "Inlined direct call to " + NameMethod(InlinedCall.Method) + ". "));
            }
            else
            {
                // Add a description
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                    "Recursively inlined direct call to " +
                    NameMethod(InlinedCall.Method) + ". (Recursion depth: " +
                    RecursionDepth + ") "));
            }
            // Add a cause node ('[-Rinline]')
            nodes.Add(Flags.CreateCauseNode(InliningRemarksOption));
            // Add diagnostics for the inlined call
            nodes.Add(CallLocation.CreateDiagnosticsNode());

            var log = Argument.PassEnvironment.Log;
            log.LogMessage(new LogEntry("pass remark", nodes));
        }

        /// <summary>
        /// Applies this pass to the given body pass argument.
        /// </summary>
        public IStatement Apply(BodyPassArgument Argument)
            in { VerifyCFGPass.Apply(Argument.Body) }
            in { VerifySSAPass.Apply(Argument.Body) }
            out (result) { VerifyCFGPass.Apply(result) }
            out (result) { VerifySSAPass.Apply(result) }
        {
            int maxRec = GetMaxRecursion(Argument);
            var shouldInline = GetInliningCriteria(Argument);
            var optimizeBody = GetBodyOptimizer(Argument);
            var result = Argument.Body;
            var log = Argument.PassEnvironment.Log;
            for (int i = 0; i < maxRec; i++)
            {
                var visitor = new InliningVisitor(Argument, shouldInline);
                result = visitor.Visit(result);
                if (visitor.HasInlined)
                {
                    if (log.Options.ShouldRemark(InliningPassName))
                    {
                        // Let's print some diagnostics, because we're so proud of
                        // our work.
                        foreach (var item in visitor.InlinedCallLocations)
                        {
                            LogInlinedCall(Argument, item.Value, item.Key, i);
                        }
                    }

                    // Perform variable/control flow optimizations
                    // to expose more inlining opportunities, and to
                    // reconstruct the CFG form of choice (which the inlining
                    // visitor may have violated)
                    result = optimizeBody(result);
                }
                else
                {
                    // Visitor hasn't inlined anything, which implies the following:
                    //   1. The method body has not changed.
                    //   2. There are no viable candidates for
                    //      inlining in the method body.
                    //
                    // In other words, we're done here, and the statement
                    // need not be optimized again, either.
                    break;
                }
            }
            return result;
        }
    }

    /// <summary>
    /// A visitor that inlines direct calls, if they meet certain criteria.
    /// </summary>
    public class InliningVisitor : LocationVisitorBase
    {
        public const this(
            set BodyPassArgument PassArgument,
            set bool(DissectedCall) ShouldInline)
        {
            this.inlineCount = new Dictionary<IMethod, int>();
            this.inlinedCallLocs = new List<KeyValuePair<DissectedCall, SourceLocation>>();
        }

        /// <summary>
        /// Gets this visitor's body pass argument.
        /// </summary>
        public BodyPassArgument PassArgument { const get; private set; }

        /// <summary>
        /// Gets the current method, whose body is being processed.
        /// </summary>
        public IMethod CurrentMethod { get { return PassArgument.DeclaringMethod; } }

        /// <summary>
        /// Determines whether the given dissected direct call should be inlined.
        /// </summary>
        public bool(DissectedCall) ShouldInline { const get; private set; }

        /// <summary>
        /// Checks if this inlining visitor has inlined anything yet.
        /// </summary>
        public bool HasInlined { get { return inlineCount.Count != 0; } }

        /// <summary>
        /// Gets a read-only dictionary that maps methods to the number
        /// of times they have been inlined by this visitor.
        /// </summary>
        public IReadOnlyDictionary<IMethod, int> InlinedCount { const get return inlineCount; }

        /// <summary>
        /// Gets all call locations that have been inlined.
        /// </summary>
        public [KeyValuePair<DissectedCall, SourceLocation>] InlinedCallLocations
        {
            get { return inlinedCallLocs; }
        }

        private Dictionary<IMethod, int> inlineCount;
        private List<KeyValuePair<DissectedCall, SourceLocation>> inlinedCallLocs;

        protected override const bool MatchesCore(IStatement Statement)
        {
            return false;
        }

        private const DissectedCall DissectCall(IExpression Expression)
        {
            if (Expression is InvocationExpression)
            {
                var invExpr = (InvocationExpression)Expression;
                var invTrgt = invExpr.Target.GetEssentialExpression();
                if (invTrgt is GetMethodExpression)
                {
                    var target = (GetMethodExpression)invTrgt;
                    return new DissectedCall(target.Caller, target.Target, invExpr.Arguments);
                }
            }
            return null;
        }

        /// <summary>
        /// Inlines the given dissected call: its arguments and return value
        /// are replaced by local variables, and control will resume when the
        /// inlined callee is done. Null is returned if the inlining operation
        /// could not be performed.
        /// </summary>
        public IExpression Inline(DissectedCall Call)
        {
            // Acquire the method body.
            var oldMethodBody = PassArgument.PassEnvironment.GetMethodBody(Call.Method);
            if (oldMethodBody == null)
                return null;

            // Copy the method body.
            var body = CloningVisitor.Visit(oldMethodBody);
            // Create a variable for the return value.
            var lbVariable = new LocalVariable(Call.Method.ReturnType);

            // Transforms the copied body to match our needs.
            var visitedBody = InliningReturnVisitor.InlineReturns(
                                InliningVariableVisitor.InlineVariables(body,
                                    Call.ThisValue,
                                    Enumerable.ToArray<IExpression>(Call.Arguments)),
                                lbVariable);

            if (lbVariable.Type.Equals(PrimitiveTypes.Void))
            {
                return new InitializedExpression(
                    visitedBody, VoidExpression).Simplify();
            }
            else
            {
                return new InitializedExpression(
                    visitedBody, lbVariable.CreateGetExpression(),
                    lbVariable.CreateReleaseStatement()).Simplify();
            }
        }

        protected override const bool MatchesCore(IExpression Expression)
        {
            var result = this.DissectCall(Expression);
            if (result == null)
            {
                return false;
            }

            return InliningExtensions.CanInline(result.Method, result.ThisValue) &&
                   this.ShouldInline(result);
        }

        protected override IExpression TransformCore(IExpression Expression)
        {
            // We know we *should* inline this because it survived the "match"
            // step.
            var dissected = DissectCall((InvocationExpression)Expression);

            // Perform the actual inlining.
            var result = Inline(dissected);

            if (result == null)
            {
                return Expression;
            }
            else
            {
                if (CurrentLocation != null)
                {
                    // Log the inlining operation.
                    inlinedCallLocs.Add(new KeyValuePair<DissectedCall, SourceLocation>(dissected, CurrentLocation));
                }

                // Increment the inlining counter.
                int preCount = 0;
                if (inlineCount.ContainsKey(dissected.Method))
                {
                    preCount = inlineCount[dissected.Method];
                }
                inlineCount[dissected.Method] = preCount + 1;

                return result;
            }
        }
        protected override IStatement TransformCore(IStatement Statement)
        {
            return Statement;
        }
    }

    public class InliningVariableVisitor : VariableSubstitutingVisitorBase,
                                           IBasicBlockVisitor
    {
        public const this(set IVariable ThisArgument, set IVariable[] Arguments)
        {
            this.locals = new Dictionary<UniqueTag, LocalVariable>();
            this.ssaLocals = new Dictionary<UniqueTag, SSAVariable>();
        }

        public IVariable ThisArgument { const get; private set; }
        public IVariable[] Arguments { const get; private set; }

        private Dictionary<UniqueTag, LocalVariable> locals;
        private Dictionary<UniqueTag, SSAVariable> ssaLocals;

        private LocalVariable inlineLocal(LocalVariable localVar)
        {
            if (!locals.ContainsKey(localVar.Tag))
            {
                locals[localVar.Tag] = new LocalVariable(localVar.Member);
            }
            return locals[localVar.Tag];
        }

        private SSAVariable inlineSSALocal(SSAVariable localVar)
        {
            if (!ssaLocals.ContainsKey(localVar.Tag))
            {
                ssaLocals[localVar.Tag] = new SSAVariable(localVar.Member);
            }
            return ssaLocals[localVar.Tag];
        }

        public static IStatement InlineVariables(IStatement Target, IExpression ThisArgument, IExpression[] Arguments)
        {
            var results = new List<IStatement>();
            var cleanup = new List<IStatement>();

            IVariable thisVar;
            if (ThisArgument == null)
            {
                thisVar = null;
            }
            else
            {
                thisVar = new LocalVariable(ThisArgument.Type);
                results.Add(thisVar.CreateSetStatement(ThisArgument));
                cleanup.Add(thisVar.CreateReleaseStatement());
            }

            var argVars = new IVariable[Arguments.Length];
            foreach (var input in Arguments, var output in argVars)
            {
                output = new LocalVariable(input.Type);
                results.Add(output.CreateSetStatement(input));
                cleanup.Add(output.CreateReleaseStatement());
            }

            var visitor = new InliningVariableVisitor(thisVar, argVars);

            results.Add(visitor.Visit(Target));

            results.AddRange(cleanup);

            return new BlockStatement(results);
        }

        protected override bool CanSubstituteVariable(IVariable Variable)
        {
            return Variable is ArgumentVariable || Variable is ThisVariable ||
                   Variable is LocalVariable || Variable is SSAVariable;
        }
        protected override IVariable SubstituteVariable(IVariable Variable)
        {
            if (Variable is ThisVariable)
            {
                return ThisArgument;
            }
            else if (Variable is ArgumentVariable)
            {
                var argVar = (ArgumentVariable)Variable;
                return Arguments[argVar.Index];
            }
            else if (Variable is SSAVariable)
            {
                var localVar = (SSAVariable)Variable;
                return inlineSSALocal(localVar);
            }
            else
            {
                assert(Variable is LocalVariable);
                var localVar = (LocalVariable)Variable;
                return inlineLocal(localVar);
            }
        }

        /// <summary>
        /// Visits the given SSA local variable, which will always be
        /// a parameter definition.
        /// </summary>
        public SSAVariable VisitParameter(SSAVariable Variable)
        {
            return inlineSSALocal(Variable);
        }

        /// <summary>
        /// Visits the given block branch instruction.
        /// </summary>
        public BlockBranch Visit(BlockBranch Branch)
        {
            var newArgs = new List<SSAVariable>();
            foreach (var arg in Branch.Arguments)
            {
                newArgs.Add(inlineSSALocal(arg));
            }
            return new BlockBranch(Branch.TargetTag, newArgs);
        }
    }

    public class InliningReturnVisitor : NodeVisitorBase
    {
        public const this(set IVariable ReturnVariable, set UniqueTag ReturnTag);

        public IVariable ReturnVariable { const get; private set; }
        public UniqueTag ReturnTag { const get; private set; }

        public static IStatement InlineReturns(IStatement Statement, IVariable ReturnVariable)
        {
            var label = new UniqueTag();
            var visitor = new InliningReturnVisitor(ReturnVariable, label);
            var body = visitor.Visit(Statement);
            return new TaggedStatement(label, body);
        }

        public override const bool Matches(IExpression Value)
        {
            return false;
        }
        public override const bool Matches(IStatement Value)
        {
            return Value is ReturnStatement;
        }
        protected const override IExpression Transform(IExpression Expression)
        {
            return Expression;
        }
        protected const override IStatement Transform(IStatement Statement)
        {
            var retStmt = (ReturnStatement)Statement;
            if (retStmt.Value == null || ReturnVariable.Type == null)
            {
                return new BreakStatement(ReturnTag);
            }
            else
            {
                return new BlockStatement(new IStatement[]
                {
                    ReturnVariable.CreateSetStatement(retStmt.Value),
                    new BreakStatement(ReturnTag)
                });
            }
        }
    }
}
