using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    public class DissectedCall
    {
        public const this(set IExpression ThisValue, set IMethod Method, set [IExpression] Arguments);

        public IExpression ThisValue { const get; private set; }
        public IMethod Method { const get; private set; }
        public [IExpression] Arguments { const get; private set; }
    }

    public class InliningVisitor : LocationVisitorBase
    {
        public const this(set IMethod CurrentMethod, set bool(DissectedCall) ShouldInline,
                          set IStatement(IMethod) GetMethodBody, set IStatement(IStatement) Optimize,
                          set int MaxRecursion)
        {
            this.inlineCount = new Dictionary<IMethod, int>();
            this.inlinedCallLocs = new List<KeyValuePair<DissectedCall, SourceLocation>>();
        }

        public IMethod CurrentMethod { const get; private set; }
        public bool(DissectedCall) ShouldInline { const get; private set; }
        public IStatement(IMethod) GetMethodBody { const get; private set; }
        public IStatement(IStatement) Optimize { const get; private set; }
        public int MaxRecursion { const get; private set; }

        public bool HasInlined { const get return inlineCount.Count != 0; }
        public IReadOnlyDictionary<IMethod, int> InlinedCount { const get return inlineCount; }

        public IEnumerable<KeyValuePair<DissectedCall, SourceLocation>> InlinedCallLocations
        {
            const get return inlinedCallLocs;
        }

        private Dictionary<IMethod, int> inlineCount;
        private List<KeyValuePair<DissectedCall, SourceLocation>> inlinedCallLocs;

        protected override const bool MatchesCore(IStatement Statement)
        {
            return false;
        }

        private const DissectedCall DissectCall(IExpression Expression)
        {
            if (Expression is InvocationExpression)
            {
                var invExpr = (InvocationExpression)Expression;
                var invTrgt = invExpr.Target.GetEssentialExpression();
                if (invTrgt is GetMethodExpression)
                {
                    var target = (GetMethodExpression)invTrgt;
                    return new DissectedCall(target.Caller, target.Target, invExpr.Arguments);
                }
            }
            return null;
        }

        private const IExpression OptimizeExpr(IExpression Value)
        {
            var rawExprStmt = new RawExpressionStatement(Value);
            var optStmt = Optimize(rawExprStmt);
            if (optStmt.IsEmpty)
            {
                return VoidExpression;
            }
            else if (optStmt is RawExpressionStatement)
            {
                return ((RawExpressionStatement)optStmt).Expression;
            }
            else
            {
                throw new Exception("The inlining pass' optimizer may not optimize away a " +
                                    "RawExpressionStatement.");
            }
        }

        public const IExpression Inline(DissectedCall Call)
        {
            int preCount = 0;
            if (inlineCount.ContainsKey(Call.Method))
            {
                preCount = inlineCount[Call.Method];
            }
            inlineCount[Call.Method] = preCount + 1;

            // Acquire and copy the method body.
            var body = CloningVisitor.Visit(GetMethodBody(Call.Method));
            // Create a variable for the return value.
            var lbVariable = new LocalVariable(Call.Method.ReturnType);

            // Transforms the copied body to match our needs.
            var visitedBody = InliningReturnVisitor.InlineReturns(
                                InliningVariableVisitor.InlineVariables(body,
                                    Call.ThisValue,
                                    Enumerable.ToArray<IExpression>(Call.Arguments)),
                                lbVariable);

            if (lbVariable.Type.Equals(PrimitiveTypes.Void))
            {
                return OptimizeExpr(new InitializedExpression(visitedBody,
                                                              VoidExpression));
            }
            else
            {
                return OptimizeExpr(new InitializedExpression(
                    visitedBody,
                    lbVariable.CreateGetExpression(),
                    lbVariable.CreateReleaseStatement()));
            }
        }

        protected override const bool MatchesCore(IExpression Expression)
        {
            var result = this.DissectCall(Expression);
            if (result == null)
            {
                return false;
            }

            int preCount = 0;
            if (inlineCount.ContainsKey(result.Method))
            {
                preCount = inlineCount[result.Method];
            }

            return preCount < MaxRecursion &&
                   InliningExtensions.CanInline(result.Method, result.ThisValue) &&
                   this.ShouldInline(result);
        }

        protected override IExpression TransformCore(IExpression Expression)
        {
            // We know we *should* inline this because it survived the "match"
            // step.
            var dissected = DissectCall((InvocationExpression)Expression);

            inlinedCallLocs.Add(new KeyValuePair<DissectedCall, SourceLocation>(dissected, CurrentLocation));

            return Visit(Inline(dissected));
        }
        protected override IStatement TransformCore(IStatement Statement)
        {
            return Statement;
        }
    }

    public class InliningVariableVisitor : VariableSubstitutingVisitorBase
    {
        public const this(set IVariable ThisArgument, set IVariable[] Arguments)
        {
            this.locals = new Dictionary<LateBoundVariable, LocalVariable>();
        }

        public IVariable ThisArgument { const get; private set; }
        public IVariable[] Arguments { const get; private set; }

        private Dictionary<LateBoundVariable, LocalVariable> locals;

        private LocalVariable GetLocal(LateBoundVariable Variable)
        {
            if (!locals.ContainsKey(Variable))
            {
                locals[Variable] = new LocalVariable(Variable.Member);
            }
            return locals[Variable];
        }

        public static IStatement InlineVariables(IStatement Target, IExpression ThisArgument, IExpression[] Arguments)
        {
            var results = new List<IStatement>();
            var cleanup = new List<IStatement>();

            IVariable thisVar;
            if (ThisArgument == null)
                thisVar = null;
            else
            {
                thisVar = new LocalVariable(ThisArgument.Type);
                results.Add(thisVar.CreateSetStatement(ThisArgument));
                cleanup.Add(thisVar.CreateReleaseStatement());
            }

            var argVars = new IVariable[Arguments.Length];
            foreach (var input in Arguments, var output in argVars)
            {
                output = new LocalVariable(input.Type);
                results.Add(output.CreateSetStatement(input));
                cleanup.Add(output.CreateReleaseStatement());
            }

            var visitor = new InliningVariableVisitor(thisVar, argVars);

            results.Add(visitor.Visit(Target));

            foreach (var item in visitor.locals)
            {
                cleanup.Add(item.Value.CreateReleaseStatement());
            }

            results.AddRange(cleanup);

            return new BlockStatement(results);
        }

        protected override bool CanSubstituteVariable(IVariable Variable)
        {
            return Variable is ArgumentVariable || Variable is ThisVariable ||
                   (Variable is LateBoundVariable && !(Variable is ManuallyBoundVariable));
        }
        protected override IVariable SubstituteVariable(IVariable Variable)
        {
            if (Variable is ThisVariable)
            {
                return ThisArgument;
            }
            else if (Variable is ArgumentVariable)
            {
                var argVar = (ArgumentVariable)Variable;
                return Arguments[argVar.Index];
            }
            else
            {
                return GetLocal((LateBoundVariable)Variable);
            }
        }
    }

    public class InliningReturnVisitor : NodeVisitorBase
    {
        public const this(set IVariable ReturnVariable, set UniqueTag ReturnTag);

        public IVariable ReturnVariable { const get; private set; }
        public UniqueTag ReturnTag { const get; private set; }

        public static const IStatement InlineReturns(IStatement Statement, IVariable ReturnVariable)
        {
            var label = new UniqueTag();
            var visitor = new InliningReturnVisitor(ReturnVariable, label);
            var body = visitor.Visit(Statement);
            return SimplifyFlowPass.TaggedBreakVisitor.Visit(new TaggedStatement(label, body));
        }

        public override const bool Matches(IExpression Value)
        {
            return false;
        }
        public override const bool Matches(IStatement Value)
        {
            return Value is ReturnStatement;
        }
        protected const override IExpression Transform(IExpression Expression)
        {
            return Expression;
        }
        protected const override IStatement Transform(IStatement Statement)
        {
            var retStmt = (ReturnStatement)Statement;
            if (retStmt.Value == null || ReturnVariable.Type == null)
            {
                return new BreakStatement(ReturnTag);
            }
            else
            {
                return new BlockStatement(new IStatement[]
                {
                    ReturnVariable.CreateSetStatement(retStmt.Value),
                    new BreakStatement(ReturnTag)
                });
            }
        }
    }
}
