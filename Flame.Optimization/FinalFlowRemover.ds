using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// A state for the `FinalFlowRemover` node visitor.
    /// </summary>
    public class FinalFlowState
    {
        /// <summary>
        /// Creates a new final flow state from the given speculative final statements
        /// and a boolean that signals flow termination.
        /// </summary>
        public const this(set [SpeculativeStatement] FinalStatements, set bool IsTerminated);

        /// <summary>
        /// Gets the speculative final statements for this state.
        /// </summary>
        public [SpeculativeStatement] FinalStatements { const get; private set; }
        /// <summary>
        /// Finds out if this final flow state has been terminated.
        /// </summary>
        public bool IsTerminated { const get; private set; }

        /// <summary>
        /// Determines whether this final flow state has any final statements.
        /// </summary>
        public bool HasFinalStatements
        {
            const get return Enumerable.Any<SpeculativeStatement>(FinalStatements);
        }

        /// <summary>
        /// Creates a new final flow state that represents the current state with
        /// the addition of a speculative statement.
        /// </summary>
        public const FinalFlowState WithStatement(SpeculativeStatement Value)
        {
            var concatStmts = Enumerable.Concat<SpeculativeStatement>(
                this.FinalStatements,
                new SpeculativeStatement[] { Value });

            return new FinalFlowState(concatStmts, this.IsTerminated);
        }

        /// <summary>
        /// Removes all speculative final statements for this state.
        /// `false` is returned if no speculative final statements were removed
        /// (because this state didn't have any), otherwise `true`.
        /// </summary>
        public bool RemoveFinalStatements()
        {
            if (!this.HasFinalStatements)
            {
                return false;
            }
            else
            {
                foreach (var item in FinalStatements)
                {
                    item.IsAlive = false;
                }
                return true;
            }
        }

        /// <summary>
        /// Creates a final flow state that represents the sequence of the
        /// this flow state followed by the give state.
        /// </summary>
        public FinalFlowState Sequence(FinalFlowState Second)
        {
            if (this.IsTerminated)
            {
                return this;
            }
            else
            {
                return Second;
            }
        }

        public FinalFlowState Select(FinalFlowState Other)
        {
            bool isTerminated = this.IsTerminated && Other.IsTerminated;

            if (!this.HasFinalStatements || !Other.HasFinalStatements)
            {
                return new FinalFlowState(Enumerable.Empty<SpeculativeStatement>(),
                                          isTerminated);
            }
            else
            {
                var finalStmts = Enumerable.Concat<SpeculativeStatement>(
                    this.FinalStatements,
                    Other.FinalStatements);

                return new FinalFlowState(finalStmts, isTerminated);
            }
        }

        /// <summary>
        /// Gets a final flow state that represents terminated flow.
        /// </summary>
        public static FinalFlowState TerminatedFlow
        {
            const get return new FinalFlowState(Enumerable.Empty<SpeculativeStatement>(), true);
        }

        /// <summary>
        /// Gets a final flow state that represents initial flow.
        /// </summary>
        public static FinalFlowState InitialFlow
        {
            const get return new FinalFlowState(Enumerable.Empty<SpeculativeStatement>(), false);
        }
    }

    /// <summary>
    /// A visitor that matches control flow statements, such as `break` and `continue`
    /// at the end of an enclosing control flow statement such as a tagged block, a
    /// `while` loop, a `do...while` loop or a `for` loop.
    /// Said enclosing statement is then transformed.
    /// </summary>
    public class FinalFlowRemover : NodeVisitorBase, IFlowVisitor<FinalFlowState, FinalFlowState>
    {
        /// <summary>
        /// Creates a new final flow remover from the given enclosing flow
        /// and a function that matches final flow.
        /// </summary>
        public const this(set IStatement EnclosingFlow,
                          set bool(IStatement, IStatement) MatchesFinalFlow)
        {
            this.CurrentFlow = FinalFlowState.InitialFlow;
        }

        /// <summary>
        /// Gets the final flow remover's enclosing flow statement.
        /// </summary>
        public IStatement EnclosingFlow { const get; private set; }

        /// <summary>
        /// Matches the final flow statement.
        /// This delegate's first argument represents the enclosing statement,
        /// whereas the second argument represents the potential final flow statement.
        /// </summary>
        public bool(IStatement, IStatement) MatchesFinalFlow { const get; private set; }

        /// <summary>
        /// Gets or sets the current flow state.
        /// </summary>
        public FinalFlowState CurrentFlow { const get; set; }

        /// <summary>
        /// Gets a flow delta that represents flow termination:
        /// sequential flow that succeeds it will never be executed.
        /// </summary>
        public FinalFlowState TerminatedFlow { const get return FinalFlowState.TerminatedFlow; }

        /// <summary>
        /// Computes the "sum" of a flow state and a control flow delta.
        /// </summary>
        public const FinalFlowState CreateCollapsedFlow(FinalFlowState First, FinalFlowState Second)
        {
            return First.Sequence(Second);
        }

        /// <summary>
        /// Computes the "difference" between two flow states, such that
        /// the "sum" of the first flow state and the result of this operation
        /// results in the second state.
        /// </summary>
        public const FinalFlowState CreateDeltaFlow(FinalFlowState First, FinalFlowState Second)
        {
            return Second;
        }

        /// <summary>
        /// Creates a flow delta that represents the sequential execution of
        /// two flow deltas.
        /// </summary>
        public const FinalFlowState CreateSequenceFlow(FinalFlowState First, FinalFlowState Second)
        {
            return First.Sequence(Second);
        }

        /// <summary>
        /// Creates a flow delta that represents selecting precisely one of two
        /// flow deltas.
        /// </summary>
        public const FinalFlowState CreateSelectFlow(FinalFlowState First, FinalFlowState Second)
        {
            return First.Select(Second);
        }

        /// <summary>
        /// Creates a flow delta that will be executed zero or more
        /// times.
        /// </summary>
        public const FinalFlowState CreateLoopFlow(FinalFlowState Flow)
        {
            return FinalFlowState.InitialFlow; // Loops really just aren't constructs
                                               // we can easily make smart predictions
                                               // about.
        }

        public override const bool Matches(IExpression Value)
        {
            return Value is IFlowExpression;
        }
        public override const bool Matches(IStatement Value)
        {
            return CurrentFlow.IsTerminated || Value is IFlowStatement;
        }

        private IStatement VisitStmt(IStatement Statement)
        {
            if (Statement is IFlowStatement)
            {
                return ((IFlowStatement)Statement).AcceptFlow<FinalFlowState, FinalFlowState>(this);
            }
            else
            {
                return Statement.Accept(this);
            }
        }

        protected override IExpression Transform(IExpression Expression)
        {
            return ((IFlowExpression)Expression).AcceptFlow<FinalFlowState, FinalFlowState>(this);
        }

        protected override IStatement Transform(IStatement Statement)
        {
            var visitedStmt = VisitStmt(Statement);

            if (MatchesFinalFlow(EnclosingFlow, visitedStmt))
            {
                var speculativeStmt = new SpeculativeStatement(visitedStmt);
                CurrentFlow = CurrentFlow.WithStatement(speculativeStmt);
                return speculativeStmt;
            }
            else
            {
                return visitedStmt;
            }
        }
    }
}
