using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// A flow graph visitor that eliminates dead blocks.
    /// </summary>
    public class DeadBlockEliminationVisitor : FlowGraphVisitorBase
    {
        public const this(set ICompilerLog Log, set IMethod DeclaringMethod);

        /// <summary>
        /// Gets this dead block eliminating visitor's associated
        /// compiler log, which it uses to issue diagnostics.
        /// </summary>
        public ICompilerLog Log { const get; private set; }

        /// <summary>
        /// Gets the declaring method.
        /// </summary>
        public IMethod DeclaringMethod { const get; private set; }

        /// <summary>
        /// Emits a warning that informs the user that the given basic
        /// block is unreachable.
        /// </summary>
        private void WarnDeadBlock(BasicBlock Block)
        {
            if (Warnings.DeadCodeWarning.UseWarning(Log.Options))
            {
                // TODO: extract a source location from the given block,
                //       issue a warning
            }
        }

        /// <summary>
        /// Emits a warning that advises the user to insert a flow-terminating
        /// statement, such as a "return".
        /// </summary>
        private void WarnMissingReturn()
        {
            if (Warnings.MissingReturnWarning.UseWarning(Log.Options))
            {
                Log.LogWarning(new LogEntry("Missing return statement?",
                    Warnings.MissingReturnWarning.CreateMessage(
                        "This method may not always return or throw. "),
                    DeclaringMethod.GetSourceLocation()));
            }
        }

        protected override FlowGraph Visit(FlowGraph Graph)
        {
            // Maintain a boolean value that tells whether we found
            // an "unreachable" block that actually turned
            // out to be reachable.

            bool unreachableIsReachable = false;

            var reachable = new HashSet<UniqueTag>(Graph.FindReachableBlocks());
            var results = new Dictionary<UniqueTag, BasicBlock>();
            foreach (var item in Graph.Blocks)
            {
                if (reachable.Contains(item.Tag))
                {
                    results[item.Tag] = item;
                    unreachableIsReachable = true;
                }
                else
                {
                    WarnDeadBlock(item);
                }
            }

            if (unreachableIsReachable)
            {
                WarnMissingReturn();
            }

            return new FlowGraph(Graph.EntryPointTag, results);
        }
    }

    /// <summary>
    /// A pass that eliminates dead blocks from flow graphs. A warning is
    /// issued for dead blocks that contain non-empty source statements or
    /// non-constant source expressions.
    /// </summary>
    public static class DeadBlockEliminationPass : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// This pass' name string.
        /// </summary>
        public const string DeadBlockEliminationPassName = "dead-block-elimination";

        public IStatement Apply(BodyPassArgument Args)
        {
            var log = Args.PassEnvironment.Log;
            var rewriter = new DeadBlockEliminationVisitor(log, Args.DeclaringMethod);
            return rewriter.Visit(Args.Body);
        }
    }
}
