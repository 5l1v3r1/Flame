using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Emit;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;
using Pixie;

namespace Flame.Optimization
{
    /// <summary>
    /// A base class for heap-to-stack visitors: specific constructs are
    /// recognized, which must then be handled by derived classes.
    /// </summary>
    public abstract class HeapToStackVisitorBase : IBasicBlockVisitor
    {
        public this(set EscapeAnalysisData AnalysisData);

        /// <summary>
        /// Gets the escape analysis data that this visitor maintains.
        /// </summary>
        public EscapeAnalysisData AnalysisData { get; private set; }

        // Remembers the current flow graph.
        private FlowGraph currentFlowGraph;

        protected UniqueTag TryGetTag(IVariable Variable)
        {
            if (Variable is ArgumentVariable)
            {
                var argVar = (ArgumentVariable)Variable;
                return AnalysisData.GetParameterTag(argVar.Index);
            }
            else if (Variable is ThisVariable)
            {
                return AnalysisData.ThisParameterTag;
            }
            else if (Variable is LocalVariableBase)
            {
                var locVar = (LocalVariableBase)Variable;
                return locVar.Tag;
            }
            else
            {
                return null;
            }
        }

        protected UniqueTag TryGetAndRegisterTag(IVariable Variable)
        {
            var tag = TryGetTag(Variable);
            if (tag != null)
                AnalysisData.RegisterTag(tag, Variable.Type);

            return tag;
        }

        /// <summary>
        /// An action that is invoked just before a node is visited.
        /// </summary>
        protected virtual void AcknowledgeNode(INode Node)
        {

        }

        protected abstract IExpression VisitNewObject(NewObjectExpression Expression);
        protected abstract IExpression VisitDynamicCast(DynamicCastExpression Expression);
        protected abstract IExpression VisitReinterpretCast(ReinterpretCastExpression Expression);
        protected abstract IExpression VisitLoad(IExpression LoadExpression, IVariable Variable);
        protected abstract IExpression VisitCall(InvocationExpression Expression, DissectedCall Call);
        protected abstract IExpression VisitAnalyzedCall(EscapeAnalysisCallExpression Expression);
        protected abstract IExpression VisitUnknown(IExpression Expression);

        protected abstract IStatement VisitReturn(ReturnStatement Statement);
        protected abstract IStatement VisitStore(IStatement StoreStatement, IVariable Variable, IExpression StoreValue);
        protected abstract IStatement VisitRelease(IStatement ReleaseStatement, IVariable Variable);
        protected abstract IStatement VisitExpressionStatement(ExpressionStatement Statement);
        protected abstract IStatement VisitUnknown(IStatement Statement);

        /// <summary>
        /// Visits a basic block argument. The parameter for which it
        /// is an argument, is also given.
        /// </summary>
        protected abstract SSAVariable VisitPhiArgument(SSAVariable Argument, SSAVariable Parameter);

        /// <summary>
        /// Visits a basic block parameter.
        /// </summary>
        protected abstract SSAVariable VisitPhiParameter(SSAVariable Parameter);

        protected virtual IExpression VisitMetadata(IExpression Expression)
        {
            return Expression.Accept(this);
        }

        protected virtual IStatement VisitMetadata(IStatement Statement)
        {
            return Statement.Accept(this);
        }

        public IExpression Visit(IExpression Value)
        {
            AcknowledgeNode(Value);
            if (Value is IMetadataNode<IExpression>)
            {
                return VisitMetadata(Value);
            }
            else if (Value is NewObjectExpression)
            {
                return VisitNewObject((NewObjectExpression)Value);
            }
            else if (Value is EscapeAnalysisCallExpression)
            {
                return VisitAnalyzedCall((EscapeAnalysisCallExpression)Value);
            }
            else if (Value is InvocationExpression)
            {
                var invExpr = (InvocationExpression)Value;
                var invTrgt = invExpr.Target.GetEssentialExpression();
                if (invTrgt is GetMethodExpression)
                {
                    var target = (GetMethodExpression)invTrgt;
                    if (!target.Op.Equals(Operator.GetVirtualDelegate))
                    {
                        return VisitCall(
                            invExpr, new DissectedCall(
                                target.Caller, target.Target, invExpr.Arguments));
                    }
                }
            }
            else if (Value is ReinterpretCastExpression)
            {
                return VisitReinterpretCast((ReinterpretCastExpression)Value);
            }
            else if (Value is DynamicCastExpression)
            {
                return VisitDynamicCast((DynamicCastExpression)Value);
            }
            else if (Value is IVariableNode)
            {
                var varNode = (IVariableNode)Value;
                if (varNode.Action == VariableNodeAction.Get)
                {
                    return VisitLoad(Value, varNode.GetVariable());
                }
            }
            return VisitUnknown(Value);
        }

        public IStatement Visit(IStatement Value)
        {
            AcknowledgeNode(Value);
            if (Value is IMetadataNode<IStatement>)
            {
                return VisitMetadata(Value);
            }
            else if (Value is ReturnStatement)
            {
                return VisitReturn((ReturnStatement)Value);
            }
            else if (Value is FlowGraphStatement)
            {
                var oldGraph = currentFlowGraph;
                currentFlowGraph = ((FlowGraphStatement)Value).Graph;
                var result = new FlowGraphStatement(currentFlowGraph.Accept(this));
                currentFlowGraph = oldGraph;
                return result;
            }
            else if (Value is ExpressionStatement)
            {
                return VisitExpressionStatement((ExpressionStatement)Value);
            }
            else if (Value is ISetVariableNode)
            {
                var varNode = (ISetVariableNode)Value;
                if (varNode.Action == VariableNodeAction.Set)
                {
                    return VisitStore(Value, varNode.GetVariable(), varNode.Value);
                }
            }
            else if (Value is IVariableNode)
            {
                var varNode = (IVariableNode)Value;
                if (varNode.Action == VariableNodeAction.Release)
                {
                    return VisitRelease(Value, varNode.GetVariable());
                }
            }
            return VisitUnknown(Value);
        }

        /// <summary>
        /// Visits the given SSA local variable, which will always be
        /// a parameter definition.
        /// </summary>
        public SSAVariable VisitParameter(SSAVariable Variable)
        {
            return VisitPhiParameter(Variable);
        }

        /// <summary>
        /// Visits the given block branch instruction.
        /// </summary>
        public BlockBranch Visit(BlockBranch Branch)
        {
            assert(currentFlowGraph != null);
            var targetBlock = currentFlowGraph.GetBlock(Branch.TargetTag);
            var argList = new List<SSAVariable>(Branch.Arguments.Count);
            foreach (var arg in Branch.Arguments, var param in targetBlock.Parameters)
            {
                argList.Add(VisitPhiArgument(arg, param));
            }
            return new BlockBranch(Branch.TargetTag, argList);
        }
    }

    /// <summary>
    /// A heap-to-stack visitor that performs escape analysis, to figure
    /// out which heap objects can safely be allocated on the stack.
    /// No attempt is made to
    /// </summary>
    public class HeapToStackAnalyzer : HeapToStackVisitorBase
    {
        public this(
            EscapeAnalysisData AnalysisData,
            set IBodyPassEnvironment Environment,
            set Dictionary<IMethod, EscapeAnalysisData> FunctionAnalysis,
            set bool CallsEscape)
            : base(AnalysisData)
        {
            exprTag = null;
            this.callList = new List<CallEscapeDependencies>();
            this.shouldLog = Environment.Log.Options.GetOption<bool>(
                HeapToStackRemarksOption, false);
        }

        private List<CallEscapeDependencies> callList;

        /// <summary>
        /// Gets the heap-to-stack analyzer's pass environment.
        /// </summary>
        public IBodyPassEnvironment Environment { get; private set; }

        /// <summary>
        /// Gets the function analysis dictionary.
        /// </summary>
        public Dictionary<IMethod, EscapeAnalysisData> FunctionAnalysis { get; private set; }

        /// <summary>
        /// Gets the set of all calls that were found and analyzed by this
        /// heap-to-stack analyzer.
        /// </summary>
        public IReadOnlyList<CallEscapeDependencies> Calls { get { return callList; } }

        /// <summary>
        /// Gets a boolean value that specifies whether function arguments
        /// and return values escape. 'this' pointers created by constructor
        /// invocation are exempted from this rule.
        /// </summary>
        /// <remarks>
        /// This should be set to 'true' if
        /// interprocedural heap-to-stack replacement is desired, and can be
        /// set to 'false' for intraprocedural heap-to-stack replacement.
        /// </remarks>
        public bool CallsEscape { get; private set; }

        /// <summary>
        /// Gets the remarks option for the heap-to-stack pass.
        /// </summary>
        public static string HeapToStackRemarksOption
        {
            get { return Flags.GetRemarkOptionName("heap2stack"); }
        }

        // A unique tag for the value that the top-of-stack
        // expression represents.
        private UniqueTag exprTag;

        // A boolean value that records whether this visitor should log
        // remarks.
        private bool shouldLog;

        private UniqueTag PopExpressionTag()
        {
            var result = exprTag;
            exprTag = null;
            return result;
        }

        private void PopGlobalExpressionTag()
        {
            UpdateTag(exprTag, EscapeAnalysisResult.Global);
            exprTag = null;
        }

        private void ReplaceExpressionTag(UniqueTag Tag)
        {
            exprTag = Tag;
        }

        /// <summary>
        /// Creates escape analysis data for the given method's signature.
        /// All input and output values are assumed to escape.
        /// </summary>
        public static EscapeAnalysisData CreateConservativeAnalysis(IMethod Method)
        {
            var result = new EscapeAnalysisData(Method);
            // Mark all input and output as global.
            for (int i = 0; i < result.ParameterCount; i++)
                result.UpdateResult(result.GetParameterTag(i), EscapeAnalysisResult.Global);

            result.UpdateResult(result.ThisParameterTag, EscapeAnalysisResult.Global);
            result.UpdateResult(result.ReturnValueTag, EscapeAnalysisResult.Global);
            return result;
        }

        private static string NameType(IType Type)
        {
            return Type.Name.ToString();
        }

        private static string NameMethod(IMethod Method)
        {
            var mName = Method.Name;
            if (Method.DeclaringType == null)
                return mName.ToString();
            else
                return mName.Qualify(Method.DeclaringType.Name.Qualify()).ToString();
        }

        private static string NameAnalysisResult(EscapeAnalysisResult Result)
        {
            if (Result == EscapeAnalysisResult.In)
                return "in";
            else if (Result == EscapeAnalysisResult.Local)
                return "local";
            else if (Result == EscapeAnalysisResult.Out)
                return "out";
            else if (Result == EscapeAnalysisResult.Global)
                return "global";
            else
                return "undefined";
        }

        private static void LogAnalysisRemark(
            EscapeAnalysisData Data, ICompilerLog Log)
        {
            var method = Data.Method;

            var nodes = new List<MarkupNode>();
            // Describe the signature
            if (!method.IsConstructor)
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                    NameType(method.ReturnType) + " "));

            nodes.Add(new MarkupNode(NodeConstants.BrightNodeType,
                NameMethod(method)));
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "("));
            int index = 0;
            foreach (var param in method.Parameters)
            {
                if (index > 0)
                    nodes.Add(new MarkupNode(NodeConstants.TextNodeType, ", "));

                nodes.Add(new MarkupNode(
                    NodeConstants.TextNodeType,
                    NameType(param.ParameterType) + " " + param.Name + " : " +
                    NameAnalysisResult(Data.GetParameterResult(index))));

                index++;
            }
            nodes.Add(new MarkupNode(
                NodeConstants.TextNodeType,
                ") : " + NameAnalysisResult(Data.ReturnValueResult)));

            nodes.Add(new MarkupNode(
                NodeConstants.TextNodeType,
                ", this : " + NameAnalysisResult(Data.ThisParameterResult) + " "));

            // Add a cause node ('[-Rheap2stack]')
            nodes.Add(Flags.CreateCauseNode(HeapToStackRemarksOption));
            // Add diagnostics for the analyzed call
            nodes.Add(method.GetSourceLocation().CreateDiagnosticsNode());

            Log.LogMessage(new LogEntry("escape analysis", nodes));
        }

        /// <summary>
        /// Analyzes the given method.
        /// </summary>
        public static EscapeAnalysisData Analyze(
            IMethod Method, IBodyPassEnvironment PassEnvironment,
            Dictionary<IMethod, EscapeAnalysisData> AnalyzedFunctions,
            bool CallsEscape, ICompilerLog Log)
        {
            var genDecl = Method.GetRecursiveGenericDeclaration();
            EscapeAnalysisData result;
            if (AnalyzedFunctions.TryGetValue(genDecl, &result))
            {
                return new EscapeAnalysisData(Method, result);
            }
            else
            {
                var conservative = CreateConservativeAnalysis(genDecl);
                AnalyzedFunctions[genDecl] = conservative;
                var body = PassEnvironment.GetMethodBody(genDecl);
                if (body == null)
                    return new EscapeAnalysisData(Method, conservative);

                result = new EscapeAnalysisData(genDecl);
                var visitor = new HeapToStackAnalyzer(
                    result, PassEnvironment, AnalyzedFunctions, CallsEscape);
                visitor.Visit(body);
                // Immediately elide locals. This saves memory, and makes
                // embedding graphs cheaper.
                result = result.ElideLocals().DiscardOut();

                if (Log != null)
                    LogAnalysisRemark(result, Log);

                AnalyzedFunctions[genDecl] = result;
                return new EscapeAnalysisData(Method, result);
            }
        }

        /// <summary>
        /// Analyzes the given method.
        /// </summary>
        public EscapeAnalysisData Analyze(IMethod Method)
        {
            ICompilerLog log = null;
            if (shouldLog)
                log = Environment.Log;
            return Analyze(Method, Environment, FunctionAnalysis, CallsEscape, log);
        }

        private void UpdateTag(UniqueTag Tag, EscapeAnalysisResult Result)
        {
            if (Tag != null)
                AnalysisData.UpdateResult(Tag, Result);
        }

        private Tuple<IExpression, UniqueTag> AnalyzeExpression(IExpression Expression)
        {
            var oldTag = PopExpressionTag();
            var tuple = Tuple.Create<IExpression, UniqueTag>(
                Visit(Expression), PopExpressionTag());
            ReplaceExpressionTag(oldTag);
            return tuple;
        }

        /// <summary>
        /// Analyzes an argument list.
        /// </summary>
        private Tuple<IReadOnlyList<IExpression>, IReadOnlyList<UniqueTag>> AnalyzeArguments(
            IEnumerable<IExpression> Arguments)
        {
            var oldTag = PopExpressionTag();
            var exprs = new List<IExpression>();
            var tags = new List<UniqueTag>();
            foreach (var arg in Arguments)
            {
                exprs.Add(Visit(arg));
                tags.Add(PopExpressionTag());
            }
            ReplaceExpressionTag(oldTag);
            return Tuple.Create<IReadOnlyList<IExpression>, IReadOnlyList<UniqueTag>>(
                exprs, tags);
        }

        /// <summary>
        /// Embeds a call in the escape analysis graph, and adds it
        /// to the call list.
        /// </summary>
        private CallEscapeDependencies EmbedCall(
            EscapeAnalysisData CalleeAnalysis,
            UniqueTag ThisTag, IReadOnlyList<UniqueTag> Arguments)
        {
            var method = CalleeAnalysis.Method;
            // Start by embedding the actual call.
            var result = AnalysisData.EmbedCall(
                CalleeAnalysis, ThisTag, Arguments);

            if (CallsEscape)
            {
                // If all calls escape, then we should proceed by marking
                // all arguments as global. However, we should not mark
                // the 'this' parameter as global, because we need it to
                // make heap-to-stack allocation viable.
                // So don't do this:
                //     UpdateTag(ThisTag, EscapeAnalysisResult.Global);
                //
                foreach (var arg in Arguments)
                {
                    UpdateTag(arg, EscapeAnalysisResult.Global);
                }
            }

            callList.Add(result);
            return result;
        }

        /// <summary>
        /// An action that is invoked just before a node is visited.
        /// </summary>
        protected override void AcknowledgeNode(INode Node)
        {
            // Pop the previous node's result.
            PopGlobalExpressionTag();
        }

        protected override IExpression VisitNewObject(NewObjectExpression Expression)
        {
            var ctorData = Analyze(Expression.Constructor);
            // Creates a new tag to hold the result.
            var newTag = AnalysisData.CreateTag(
                "new-object", Expression.Type, EscapeAnalysisResult.Local);
            var args = AnalyzeArguments(Expression.Arguments);
            var callDepends = EmbedCall(ctorData, newTag, args.Item2);
            // Replace the old top-of-stack tag by the new tag.
            ReplaceExpressionTag(newTag);
            return new EscapeAnalysisCallExpression(
                new NewObjectExpression(
                    Expression.Constructor, args.Item1),
                callDepends);
        }

        protected override IExpression VisitDynamicCast(DynamicCastExpression Expression)
        {
            // Don't modify the expression result.
            return Expression.Accept(this);
        }

        protected override IExpression VisitReinterpretCast(ReinterpretCastExpression Expression)
        {
            // Don't modify the expression result.
            return Expression.Accept(this);
        }

        protected override IExpression VisitLoad(IExpression LoadExpression, IVariable Variable)
        {
            if (Variable is FieldVariable)
            {
                var fieldVar = (FieldVariable)Variable;
                if (fieldVar.Field.IsStatic)
                    return VisitUnknown(LoadExpression);

                // Analyze the field's target, then discard its tag.
                // Loading a field does not impose any additional restrictions
                // on heap-to-stack allocation.
                // Note that we're not trying to replace heap-allocated fields
                // by stack-allocated fields, so we don't have to create a new
                // value tag here.
                // We can just assume that the loaded value is global.
                var result = LoadExpression.Accept(this);
                PopExpressionTag();
                return result;
            }

            ReplaceExpressionTag(TryGetAndRegisterTag(Variable));
            if (exprTag != null)
            {
                return LoadExpression;
            }
            else
            {
                return VisitUnknown(LoadExpression);
            }
        }

        protected override IExpression VisitCall(InvocationExpression Expression, DissectedCall Call)
        {
            var thisVal = AnalyzeExpression(Call.ThisValue);
            var args = AnalyzeArguments(Call.Arguments);
            var callResults = EmbedCall(
                Analyze(Call.Method), thisVal.Item2, args.Item2);
            ReplaceExpressionTag(callResults.ReturnValue);
            return new EscapeAnalysisCallExpression(
                new InvocationExpression(
                    callResults.Method, thisVal.Item1, args.Item1),
                callResults);
        }

        protected override IExpression VisitAnalyzedCall(
            EscapeAnalysisCallExpression Expression)
        {
            return Visit(Expression.Expression);
        }

        protected override IExpression VisitUnknown(IExpression Expression)
        {
            if (Expression == null)
                return Expression;

            var result = Expression.Accept(this);
            // Escape analysis result becomes global.
            PopGlobalExpressionTag();
            return result;
        }

        protected override IStatement VisitExpressionStatement(ExpressionStatement Statement)
        {
            var result = Statement.Accept(this);
            PopExpressionTag();
            return result;
        }

        protected override IStatement VisitReturn(ReturnStatement Statement)
        {
            if (Statement.Value != null)
            {
                // Returned values become linked to the return value tag.
                var val = Visit(Statement.Value);
                var valueTag = PopExpressionTag();
                AnalysisData.TryAddSymmetricDependency(
                    valueTag, AnalysisData.ReturnValueTag);
                return new ReturnStatement(val);
            }
            else
            {
                return Statement;
            }
        }

        protected override IStatement VisitStore(
            IStatement StoreStatement, IVariable Variable,
            IExpression StoreValue)
        {
            if (Variable is FieldVariable)
            {
                var fieldVar = (FieldVariable)Variable;
                if (fieldVar.Field.IsStatic)
                    return VisitUnknown(StoreStatement);

                // Analyze the field's target, then discard its tag.
                // Stores to a field do not impose any additional restrictions
                // on heap-to-stack allocation.
                // Note that we're not trying to replace heap-allocated fields
                // by stack-allocated fields, so we don't have to create a new
                // value tag here.
                // We cannot give the value the same treatment, because it
                // does escape to the global scope.
                var tgt = Visit(fieldVar.Target);
                PopExpressionTag();
                return new FieldVariable(fieldVar.Field, tgt)
                    .CreateSetStatement(VisitUnknown(StoreValue));
            }

            var varTag = TryGetAndRegisterTag(Variable);
            if (exprTag != null)
            {
                var val = Visit(StoreValue);
                var valueTag = PopExpressionTag();
                AnalysisData.TryAddSymmetricDependency(varTag, valueTag);
                return Variable.CreateSetStatement(val);
            }
            else
            {
                return VisitUnknown(StoreStatement);
            }
        }

        protected override IStatement VisitRelease(
            IStatement ReleaseStatement, IVariable Variable)
        {
            return ReleaseStatement.Accept(this);
        }

        /// <summary>
        /// Visits a basic block argument. The parameter for which it
        /// is an argument, is also given.
        /// </summary>
        protected override SSAVariable VisitPhiArgument(
            SSAVariable Argument, SSAVariable Parameter)
        {
            var paramTag = TryGetAndRegisterTag(Parameter);
            var argTag = TryGetAndRegisterTag(Argument);
            assert(paramTag != null);
            assert(argTag != null);
            AnalysisData.AddSymmetricDependency(argTag, paramTag);
            return Argument;
        }

        /// <summary>
        /// Visits a basic block parameter.
        /// </summary>
        protected override SSAVariable VisitPhiParameter(SSAVariable Parameter)
        {
            var tag = TryGetAndRegisterTag(Parameter);
            assert(tag != null);
            return Parameter;
        }

        protected override IStatement VisitUnknown(IStatement Statement)
        {
            var result = Statement.Accept(this);
            // Escape analysis result becomes global.
            PopGlobalExpressionTag();
            return result;
        }
    }

    /// <summary>
    /// A type of expression that represents a call that has been analyzed by
    /// the escape analysis pass. Rewriters can recognize these expressions,
    /// and use them to connect IR trees to escape analysis results.
    /// </summary>
    public class EscapeAnalysisCallExpression : IExpression
    {
        public this(
            set IExpression Expression,
            set CallEscapeDependencies Dependencies);

        public IExpression Expression { get; private set; }
        public CallEscapeDependencies Dependencies { get; private set; }

        public bool IsNewObject { get { return Expression is NewObjectExpression; } }

        /// <summary>
        /// Replaces this escape-analyzed call expresison's method
        /// by the given method. The escape analysis information is
        /// discarded from the resulting expression.
        /// </summary>
        public IExpression ReplaceMethod(IMethod Method)
        {
            if (IsNewObject)
            {
                var newObjExpr = (NewObjectExpression)Expression;
                return new NewObjectExpression(Method, newObjExpr.Arguments);
            }
            else
            {
                assert(Expression is InvocationExpression);
                var invExpr = (InvocationExpression)Expression;
                var invTarget = invExpr.Target.GetEssentialExpression();
                assert(invTarget is GetMethodExpression);
                var getMethodExpr = (GetMethodExpression)invTarget;
                assert(!getMethodExpr.Op.Equals(Operator.GetVirtualDelegate));

                var args = invExpr.Arguments;
                var thisArg = getMethodExpr.Caller;
                if (Method.IsStatic && !getMethodExpr.Target.IsStatic)
                {
                    args = Enumerable.ToArray<IExpression>(
                        Enumerable.Concat<IExpression>(
                            new IExpression[] { thisArg }, args));
                    thisArg = null;
                }

                return new InvocationExpression(
                    new GetMethodExpression(Method, thisArg, getMethodExpr.Op),
                    args);
            }
        }

        public IType Type
		{
			get { return Expression.Type; }
		}

		public IExpression Accept(INodeVisitor Visitor)
		{
			return new EscapeAnalysisCallExpression(
                Visitor.Visit(Expression), Dependencies);
		}

		public IExpression Optimize()
		{
			return Expression.Optimize();
		}

		public ICodeBlock Emit(ICodeGenerator CodeGenerator)
		{
			return Expression.Emit(CodeGenerator);
		}

        public bool IsConstantNode { get { return true; } }

        public IBoundObject Evaluate()
        {
        	return null;
        }

        public override string ToString()
        {
            return "escape-analyzed(" + Expression.ToString() + ")";
        }
    }

    /// <summary>
    /// Describes a rewritten method.
    /// </summary>
    public class RewrittenMethodSignature
    {
        public this(
            set IMethod Method,
            set bool HasReplacedThis,
            set bool HasReplacedReturn)
            in { Method != null }
        { }

        /// <summary>
        /// Gets the rewritten method.
        /// </summary>
        public IMethod Method { get; private set; }

        /// <summary>
        /// Gets a boolean value that tells if the 'this' parameter has been
        /// replaced.
        /// </summary>
        public bool HasReplacedThis { get; private set; }

        /// <summary>
        /// Gets a boolean value that tells if the return value has been
        /// replaced.
        /// </summary>
        public bool HasReplacedReturn { get; private set; }
    }

    public class HeapToStackRewriter : HeapToStackVisitorBase
    {
        public this(
            EscapeAnalysisData AnalysisData,
            set IMethod Method,
            set IReadOnlyDictionary<IType, IType> TypeMap,
            set IReadOnlyDictionary<CallEscapeDependencies, RewrittenMethodSignature> FunctionMap)
            : base(AnalysisData)
            in { Method != null }
            in { AnalysisData != null }
            in { TypeMap != null }
            in { FunctionMap != null }
            in { AnalysisData.CheckTypes() }
        {
            this.replacedVariables = new Dictionary<UniqueTag, IVariable>();
            int argIndex = 0;
            int paramIndex = 0;
            [IParameter] parameterList = Method.Parameters;
            if (!AnalysisData.Method.IsStatic && Method.IsStatic)
            {
                this.replacedVariables[AnalysisData.ThisParameterTag] =
                    new ArgumentVariable(
                        Enumerable.First<IParameter>(parameterList), 0);
                parameterList = Enumerable.Skip<IParameter>(parameterList, 1);
                paramIndex = 1;
            }
            else
            {
                this.replacedVariables[AnalysisData.ThisParameterTag] =
                    new ThisVariable(Method.DeclaringType);
            }
            foreach (var param in parameterList)
            {
                this.replacedVariables[AnalysisData.GetParameterTag(argIndex)] =
                    new ArgumentVariable(param, paramIndex);
                paramIndex++;
                argIndex++;
            }
        }

        private Dictionary<UniqueTag, IVariable> replacedVariables;

        // A boolean value that tracks whether the top-of-stack expression
        // has been replaced by a stack-allocated variable.
        private bool hasReplaced;

        /// <summary>
        /// Gets the method that this heap-to-stack rewriter is actually
        /// rewriting.
        /// </summary>
        public IMethod Method { get; private set; }

        /// <summary>
        /// Gets a dictionary that maps reference types to the value
        /// types they have been rewritten as.
        /// </summary>
        public IReadOnlyDictionary<IType, IType> TypeMap { get; private set; }

        /// <summary>
        /// Gets a dictionary that maps all escaping calls
        /// to the methods they have been rewritten as.
        /// </summary>
        public IReadOnlyDictionary<CallEscapeDependencies, RewrittenMethodSignature> FunctionMap { get; private set; }

        /// <summary>
        /// Gets a re-written version of the given method. Null is returned
        /// if there is no re-written version. The original method should
        /// be used in that case.
        /// </summary>
        private RewrittenMethodSignature GetRewrittenMethod(CallEscapeDependencies Dependencies)
        {
            if (FunctionMap.TryGetValue(Dependencies, &RewrittenMethodSignature result))
                return result;
            else
                return null;
        }

        /// <summary>
        /// Tries to get a rewritten version of the given type. The result
        /// is stored in the given type reference.
        /// </summary>
        public bool TryGetRewrittenType(IType Type, out IType^ Result)
        {
            if (TypeMap.TryGetValue(Type, Result))
            {
                return true;
            }
            else
            {
                var recGenDecl = Type.GetRecursiveGenericDeclaration();
                if (TypeMap.TryGetValue(recGenDecl, Result))
                {
                    if (Result == null)
                    {
                        Console.WriteLine("Type '" + Type.FullName + "' was not in the rewritten-types dictionary.");
                        return false;
                    }

                    *Result = Result->MakeGenericType(Type.GetRecursiveGenericArguments());
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }

        /// <summary>
        /// Tries to replace the given variable by another variable. Null
        /// is returned if the given variable was not a local variable,
        /// argument variable, or 'this' variable.
        /// </summary>
        private IVariable TryReplaceVariable(IVariable Variable)
        {
            var tag = TryGetTag(Variable);
            IVariable result;
            if (tag == null
                || AnalysisData.GetResult(tag) == EscapeAnalysisResult.Global)
            {
                if (tag == null)
                    Console.WriteLine("'" + Variable.ToString() + "' in method '" + Method.FullName + "' was not tagged.");
                else if (AnalysisData.GetResult(tag) == EscapeAnalysisResult.Global)
                    Console.WriteLine("'" + Variable.ToString() + "' in method '" + Method.FullName + "' was global.");
                return null;
            }
            else if (replacedVariables.TryGetValue(tag, &result))
            {
                return result;
            }
            else
            {
                assert(Variable is LocalVariableBase);
                var otherVar = (LocalVariableBase)Variable;
                if (TryGetRewrittenType(otherVar.Type, &IType newType))
                {
                    // We found a non-escaping local variable whose type
                    // can be replaced by a reference type.
                    // Replace it by a reference pointer to a value type.
                    Console.WriteLine("Replaced variable '" + otherVar.Member.Name + "'");
                    result = new LocalVariable(new RetypedVariableMember(
                        otherVar.Member,
                        newType.MakePointerType(PointerKind.ReferencePointer)));
                }
                else
                {
                    result = Variable;
                }
                replacedVariables[tag] = result;
                return result;
            }
        }

        protected override void AcknowledgeNode(INode Node)
        {
            this.hasReplaced = false;
        }

        protected override IExpression VisitNewObject(NewObjectExpression Expression)
        {
            // We can't handle standalone (non-analyzed) new-object expressions.
            return VisitUnknown(Expression);
        }

        protected override IExpression VisitCall(
            InvocationExpression Expression, DissectedCall Call)
        {
            // We will handle one special case here: calls to the parameterless
            // root constructor.
            if (!Enumerable.Any<IExpression>(Call.Arguments)
                && Call.ThisValue != null
                && Call.Method.IsConstructor
                && !Call.Method.IsStatic)
            {
                var declType = Call.Method.DeclaringType;
                if (declType != null && declType.IsRootType)
                {
                    // We found a call to the parameterless root type
                    // constructor, which is a no-op if the 'this' value
                    // is stack-allocated, and must be preserved otherwise.
                    var thisVal = Visit(Call.ThisValue);
                    if (hasReplaced)
                        return VoidExpression;
                    else
                        return new InvocationExpression(
                            Call.Method, thisVal,
                            Enumerable.Empty<IExpression>());
                }
            }

            // We can't handle generalized standalone (non-analyzed) call expressions.
            return VisitUnknown(Expression);
        }

        protected override IExpression VisitDynamicCast(DynamicCastExpression Expression)
        {
            var innerExpr = Visit(Expression.Value);
            if (hasReplaced)
                return innerExpr;
            else
                return new DynamicCastExpression(innerExpr, Expression.Type);
        }

        protected override IExpression VisitReinterpretCast(ReinterpretCastExpression Expression)
        {
            var innerExpr = Visit(Expression.Value);
            if (hasReplaced)
                return innerExpr;
            else
                return new ReinterpretCastExpression(innerExpr, Expression.Type);
        }

        protected override IExpression VisitLoad(IExpression LoadExpression, IVariable Variable)
        {
            var replVar = TryReplaceVariable(Variable);
            if (replVar == null)
            {
                Console.WriteLine("Visiting unknown load statement: '" + LoadExpression.ToString() + "'");
                return VisitUnknown(LoadExpression);
            }
            else
            {
                Console.WriteLine("Visiting known load statement: '" + LoadExpression.ToString() + "'");
                this.hasReplaced = true;
                return replVar.CreateGetExpression();
            }
        }

        protected override IExpression VisitAnalyzedCall(
            EscapeAnalysisCallExpression Expression)
        {
            var newSignature = GetRewrittenMethod(Expression.Dependencies);
            if (newSignature == null)
            {
                Console.WriteLine("Visiting unreplaced call: '" + Expression.Expression + "'");
                return Visit(Expression.Expression);
            }
            else
            {
                Console.WriteLine("Visiting replaced call: '" + Expression.Expression + "'");
                var newMethod = newSignature.Method;
                // First replace the callee, then visit the call.
                var result = Visit(Expression.ReplaceMethod(newMethod));
                if (Expression.IsNewObject && newSignature.HasReplacedThis)
                {
                    // A new-object expression that produces a reference type
                    // which we intend to replace by a value type, is handled
                    // as a special case here.
                    var newObjectExpr = (NewObjectExpression)Expression.Expression;

                    this.hasReplaced = true;

                    // Create a new local variable, initialize that, and take
                    // its address.
                    var tmpLocal = new LocalVariable("tmp", newMethod.DeclaringType);
                    return new InitializedExpression(
                        tmpLocal.CreateSetStatement(result),
                        tmpLocal.CreateAddressOfExpression());
                }
                else
                {
                    this.hasReplaced = newSignature.HasReplacedReturn;
                    return result;
                }
            }
        }

        protected override IExpression VisitUnknown(IExpression Expression)
        {
            var result = Expression.Accept(this);
            hasReplaced = false;
            return result;
        }

        protected override IStatement VisitExpressionStatement(ExpressionStatement Statement)
        {
            return Statement.Accept(this);
        }

        protected override IStatement VisitReturn(ReturnStatement Statement)
        {
            return Statement.Accept(this);
        }

        protected override IStatement VisitStore(IStatement StoreStatement, IVariable Variable, IExpression StoreValue)
        {
            var replVar = TryReplaceVariable(Variable);
            if (replVar == null)
            {
                Console.WriteLine("Visiting unknown store statement: '" + StoreStatement.ToString() + "'");
                return VisitUnknown(StoreStatement);
            }
            else
            {
                Console.WriteLine("Visiting known store statement: '" + StoreStatement.ToString() + "'");
                // Visit the value, and create a 'store' statement.
                return replVar.CreateSetStatement(Visit(StoreValue));
            }
        }

        protected override IStatement VisitRelease(
            IStatement ReleaseStatement, IVariable Variable)
        {
            var replVar = TryReplaceVariable(Variable);
            if (replVar == null)
            {
                return VisitUnknown(ReleaseStatement);
            }
            else
            {
                // Visit the value, and create a 'store' statement.
                return replVar.CreateReleaseStatement();
            }
        }

        protected override IStatement VisitUnknown(IStatement Statement)
        {
            return Statement.Accept(this);
        }

        /// <summary>
        /// Visits a basic block argument. The parameter for which it
        /// is an argument, is also given.
        /// </summary>
        protected override SSAVariable VisitPhiArgument(SSAVariable Argument, SSAVariable Parameter)
        {
            var replVar = TryReplaceVariable(Argument);
            if (replVar == null)
            {
                return Argument;
            }
            else
            {
                assert(replVar is SSAVariable);
                return (SSAVariable)replVar;
            }
        }

        /// <summary>
        /// Visits a basic block parameter.
        /// </summary>
        protected override SSAVariable VisitPhiParameter(SSAVariable Parameter)
        {
            var replVar = TryReplaceVariable(Parameter);
            if (replVar == null)
            {
                return Parameter;
            }
            else
            {
                assert(replVar is SSAVariable);
                return (SSAVariable)replVar;
            }
        }
    }
}
