using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// Represents a thread of jumps: a list of branches that are taken unconditionally.
    /// </summary>
    public class JumpThread
    {
        /// <summary>
        /// Creates an empty jump thread.
        /// </summary>
        public this(IReadOnlyDictionary<SSAVariable, IExpression> Definitions)
        {
            this.Definitions = Definitions;
            this.argAssignment = new Dictionary<SSAVariable, SSAVariable>();
            this.argValues = new Dictionary<SSAVariable, IExpression>();
            this.threadBlocks = new HashSet<UniqueTag>();
        }

        /// <summary>
        /// A dictionary that maps basic block parameters to arguments.
        /// </summary>
        private Dictionary<SSAVariable, SSAVariable> argAssignment;

        /// <summary>
        /// A dictionary that maps basic block parameters to the values they have been
        /// defined as.
        /// </summary>
        private Dictionary<SSAVariable, IExpression> argValues;

        /// <summary>
        /// The set of all blocks in this thread of jumps.
        /// </summary>
        private HashSet<UniqueTag> threadBlocks;

        /// <summary>
        /// Gets a read-only view of a dictionary that maps basic block parameters to arguments
        /// for this jump thread.
        /// </summary>
        public IReadOnlyDictionary<SSAVariable, SSAVariable> ArgumentAssignment
        {
            get { return argAssignment; }
        }

        /// <summary>
        /// Gets a read-only view of a dictionary that maps basic block parameters the values
        /// they have been defined as.
        /// </summary>
        public IReadOnlyDictionary<SSAVariable, IExpression> ArgumentValues
        {
            get { return argValues; }
        }

        /// <summary>
        /// Gets the final block in this jump thread.
        /// </summary>
        /// <returns>The final block in this jump thread.</returns>
        public BasicBlock FinalBlock { get; private set; }

        /// <summary>
        /// Gets a mapping of variables to definitions.
        /// </summary>
        public IReadOnlyDictionary<SSAVariable, IExpression> Definitions { get; private set; }

        /// <summary>
        /// Gets the length of this jump thread: the number of branches it is comprised of.
        /// </summary>
        /// <returns>The length of this jump thread.</returns>
        public int Length { get { return threadBlocks.Count; } }

        /// <summary>
        /// Checks if this jump thread includes the block with the given tag.
        /// </summary>
        /// <param name="BlockTag">The block with the given tag.</param>
        /// <returns><c>true</c> if this jump thread includes the block with the given tag; otherwise, <c>false</c>.</returns>
        public bool Contains(UniqueTag BlockTag)
        {
            return threadBlocks.Contains(BlockTag);
        }

        /// <summary>
        /// Tries to simplify the given expression.
        /// </summary>
        /// <param name="Expression">The expression to simplify.</param>
        /// <returns>Either the original expression or the simplified expression.</returns>
        private IExpression Simplify(IExpression Expression)
        {
            var visitor = new GlobalValuePropagationUseVisitor(ArgumentValues, false);
            return visitor.Visit(Expression);
        }

        /// <summary>
        /// Tries to evaluate the given expression within the context of this jump thread.
        /// </summary>
        /// <param name="Expression">The expression to evaluate.</param>
        /// <returns>A value if the expression could be evaluated; otherwise, <c>null</c>.</returns>
        public IBoundObject EvaluateOrNull(IExpression Expression)
        {
            return Simplify(Expression).EvaluateConstant();
        }

        /// <summary>
        /// Tries to append the given branch to this thread.
        /// </summary>
        /// <param name="Branch">The branch to append to this thread.</param>
        /// <param name="Target">The branch's target block.</param>
        /// <returns><c>true</c> if the given branch was appended to this thread; otherwise, <c>false</c>.</returns>
        public bool TryAddBranch(BlockBranch Branch, BasicBlock Target)
        {
            assert(Branch.TargetTag == Target.Tag);

            // A jump thread cannot include a cycle. If we allowed this, then
            // we'd slip into an infinite loop.
            if (!threadBlocks.Add(Target.Tag))
            {
                return false;
            }

            foreach (var param in Target.Parameters, var arg in Branch.Arguments)
            {
                SSAVariable actualArg;
                if (!argAssignment.TryGetValue(arg, &actualArg))
                {
                    actualArg = arg;
                }
                argAssignment[param] = actualArg;

                IExpression argVal;
                if (argValues.TryGetValue(actualArg, &argVal)
                    || Definitions.TryGetValue(actualArg, &argVal))
                {
                    argValues[param] = Simplify(argVal);
                }
            }

            FinalBlock = Target;
            return true;
        }

        /// <summary>
        /// Tries to create an (initialization statement, branch) pair that performs a direct
        /// jump to this jump thread's final block. The initialization statement needs to be
        /// placed on a path that always leads to the branch.
        /// </summary>
        /// <returns>
        /// An (initialization statement, branch) pair if the jump thread can be improved upon.
        /// Otherwise, <c>null</c>.
        /// </returns>
        public Tuple<IStatement, BlockBranch> TryCreateInitStatementAndBranch()
        {
            if (Length <= 1)
            {
                // There's no point in trying to rewrite this jump thread as a single jump,
                // because the jump thread *is* a single jump.
                return null;
            }

            var intermediateArgs = new Dictionary<IVariable, IVariable>();
            var finalParamSet = new HashSet<SSAVariable>(FinalBlock.Parameters);
            foreach (var pair in argAssignment)
            {
                if (!finalParamSet.Contains(pair.Key))
                {
                    intermediateArgs[pair.Key] = pair.Value;
                }
            }
            var finalArgs = new List<SSAVariable>();
            foreach (var param in FinalBlock.Parameters)
            {
                finalArgs.Add(argAssignment[param]);
            }
            return new Tuple<IStatement, BlockBranch>(
                VariableHelpers.CreateParallelSetStatement(
                    intermediateArgs, new Dictionary<IType, IVariable>()),
                new BlockBranch(FinalBlock.Tag, finalArgs));
        }
    }

    /// <summary>
    /// A branch visitor that tries to replace threads of branches by direct branches.
    /// </summary>
    public class JumpThreadingVisitor : BranchVisitorBase
    {
        /// <summary>
        /// Creates a jump-threading visitor from the given control-flow graph.
        /// </summary>
        public this(FlowGraph Graph, IReadOnlyDictionary<SSAVariable, IExpression> Definitions)
        {
            this.Graph = Graph;
            this.Definitions = Definitions;
            this.newBlocks = new Dictionary<UniqueTag, BasicBlock>();
        }

        private Dictionary<UniqueTag, BasicBlock> newBlocks;

        /// <summary>
        /// Gets the control-flow graph that this jump-threading visitor operates on.
        /// </summary>
        /// <returns>The control-flow graph for this visitor.</returns>
        public FlowGraph Graph { get; private set; }

        /// <summary>
        /// Gets a mapping of variables to definitions.
        /// </summary>
        public IReadOnlyDictionary<SSAVariable, IExpression> Definitions { get; private set; }

        /// <summary>
        /// Gets a dictionary that maps visited basic block tags to basic blocks in
        /// the transformed graph.
        /// </summary>
        /// <returns>A dictionary that maps basic block tags to basic blocks.</returns>
        public IReadOnlyDictionary<UniqueTag, BasicBlock> Blocks { get { return newBlocks; } }

        /// <summary>
        /// Tries to discover a jump thread for the given branch in the given graph.
        /// </summary>
        /// <param name="Graph">The flow graph that contains the block.</param>
        /// <param name="Branch">The first branch in the thread.</param>
        /// <returns>A jump thread for the given branch.</returns>
        private JumpThread DiscoverJumpThread(BlockBranch Branch)
        {
            var thread = new JumpThread(Definitions);
            while (true)
            {
                // Append the branch to the thread.
                var block = Graph.GetBlock(Branch.TargetTag);
                if (!thread.TryAddBranch(Branch, block))
                {
                    break;
                }

                // If the branch target's block is non-empty then we can't append it
                // to the thread (doing so anyway would duplicate code).
                if (!block.Contents.IsEmpty)
                {
                    break;
                }

                if (block.Flow is JumpFlow)
                {
                    // Make this jump's branch the next branch in the thread.
                    var jump = (JumpFlow)block.Flow;
                    Branch = jump.Branch;
                }
                else if (block.Flow is SelectFlow)
                {
                    // The selection flow instruction's condition might evaluate to a constant
                    // value within the context of this jump thread. If so, then we can pick
                    // a branch and append that to the thread.
                    var selection = (SelectFlow)block.Flow;
                    var condVal = thread.EvaluateOrNull(selection.Condition);
                    if (condVal == null)
                    {
                        break;
                    }
                    else if (condVal.GetValue<bool>())
                    {
                        Branch = selection.ThenBranch;
                    }
                    else
                    {
                        Branch = selection.ElseBranch;
                    }
                }
                else
                {
                    break;
                }
            }
            return thread;
        }

        public override BlockBranch Visit(BlockBranch Branch)
        {
            var thread = DiscoverJumpThread(Branch);
            var initAndBranch = thread.TryCreateInitStatementAndBranch();
            if (initAndBranch == null)
            {
                return Branch;
            }

            // If the initialization statement does nothing, then we can simply
            // return the rewritten branch.
            var init = initAndBranch.Item1;
            var newBranch = initAndBranch.Item2;
            if (init.IsEmpty)
            {
                return newBranch;
            }

            // If the initialization statement actually does something, then we need to
            // create a temporary ('thunk') block and have that perform both the initialization
            // and the branch.
            var thunkBlock = new BasicBlock(
                new UniqueTag("thunk_block"), new List<SSAVariable>(),
                init, new JumpFlow(newBranch));
            newBlocks[thunkBlock.Tag] = thunkBlock;

            // Return a branch to the thunk.
            return new BlockBranch(thunkBlock.Tag);
        }

        private BasicBlock VisitImpl(BasicBlock Block)
        {
            if (Block.Flow is JumpFlow)
            {
                var jump = (JumpFlow)Block.Flow;
                var thread = DiscoverJumpThread(jump.Branch);
                var initAndBranch = thread.TryCreateInitStatementAndBranch();
                if (initAndBranch == null)
                {
                    return Block;
                }

                return new BasicBlock(
                    Block.Tag, Block.Parameters,
                    new BlockStatement(new IStatement[]
                    {
                        Block.Contents,
                        initAndBranch.Item1
                    }).Simplify(),
                    new JumpFlow(initAndBranch.Item2));
            }
            else if (Block.Flow is SelectFlow)
            {
                return new BasicBlock(
                    Block.Tag, Block.Parameters, Block.Contents,
                    Block.Flow.Accept(this));
            }
            else
            {
                return Block;
            }
        }

        /// <summary>
        /// Visits the given basic block.
        /// </summary>
        /// <param name="Block">The basic block to visit.</param>
        /// <returns>The transformed basic block.</returns>
        public BasicBlock Visit(BasicBlock Block)
        {
            BasicBlock result;
            if (newBlocks.TryGetValue(Block.Tag, &result))
            {
                return result;
            }

            result = VisitImpl(Block);
            newBlocks[result.Tag] = result;
            return result;
        }
    }

    /// <summary>
    /// A pass that applies simple jump threading to flow graphs.
    /// </summary>
    public static class JumpThreadingPass : FlowGraphVisitorBase, IPass<IStatement, IStatement>
    {
        // The jump threading algorithm as implemented by this pass works like so:
        //
        //     For each jump:
        //
        //         1. Construct a thread of jumps: a list of branches
        //            that are taken unconditionally.
        //
        //         2. If the thread contains only one branch, then proceed to the next thread, if any.
        //
        //         3. Otherwise, try to convert the thread into a single jump or at worst a jump to a thunk
        //            block.

        /// <summary>
        /// This pass' name.
        /// </summary>
        public const string JumpThreadingPassName = "jump-threading";

        protected override FlowGraph Visit(FlowGraph Graph)
        {
            // Look up all definitions.
            var defFinder = new SSAVariableDefFinder();
            foreach (var block in Graph.Blocks)
            {
                defFinder.Visit(block.Contents);
            }

            // Perform jump threading.
            var visitor = new JumpThreadingVisitor(Graph, defFinder.Definitions);
            foreach (var block in Graph.Blocks)
            {
                visitor.Visit(block);
            }

            return new FlowGraph(Graph.EntryPointTag, visitor.Blocks);
        }

        public IStatement Apply(IStatement Statement)
            in { VerifyCFGPass.Apply(Statement) }
            in { VerifySSAPass.Apply(Statement) }
            out (result) { VerifyCFGPass.Apply(result) }
            out (result) { VerifySSAPass.Apply(result) }
        {
            // First jump threads, then delete dead blocks and finally fix broken SSA form.
            // Note that dead block elimination is a relatively cheap operation that eases the
            // burden of the SSA construction algorithm.
            return FixBrokenSSAPass.Apply(SilentDeadBlockEliminationPass.Apply(Visit(Statement)));
        }
    }
}
