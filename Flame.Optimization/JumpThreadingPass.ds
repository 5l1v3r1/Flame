using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// Represents a thread of jumps: a collection of blocks to which control is transferred
    /// once a single initial block is reached.
    /// </summary>
    public class JumpThread
    {
        /// <summary>
        /// Creates a jump thread from the given block and branch.
        /// </summary>
        public this(BasicBlock Block, BlockBranch Branch)
        {
            this.threadBody = new List<IStatement>();
            this.varValues = new Dictionary<SSAVariable, IExpression>();
            this.threadBlocks = new HashSet<UniqueTag>();
            this.threadBlocks.Add(Block.Tag);
            AnalyzeBlockBody(Block.Contents);
            this.FinalFlow = new JumpFlow(Branch);
        }

        /// <summary>
        /// A list of body statements for this jump thread.
        /// </summary>
        private List<IStatement> threadBody;

        /// <summary>
        /// A dictionary that maps variables to the values they have been
        /// defined as.
        /// </summary>
        private Dictionary<SSAVariable, IExpression> varValues;

        /// <summary>
        /// The set of all blocks in this thread.
        /// </summary>
        private HashSet<UniqueTag> threadBlocks;

        /// <summary>
        /// Gets a read-only view of a dictionary that maps SSA variables to the values
        /// they have been defined as.
        /// </summary>
        public IReadOnlyDictionary<SSAVariable, IExpression> VariableValues
        {
            get { return varValues; }
        }

        /// <summary>
        /// Gets the final flow instruction in this jump thread.
        /// </summary>
        /// <returns>The final flow instruction in this jump thread.</returns>
        public BlockFlow FinalFlow { get; private set; }

        /// <summary>
        /// Gets the length of this jump thread: the number of blocks it is comprised of.
        /// </summary>
        /// <returns>The length of this jump thread.</returns>
        public int Length { get { return threadBlocks.Count - 1; } }

        /// <summary>
        /// Gets this jump thread's body statement.
        /// </summary>
        /// <returns>The jump thread's body statement.</returns>
        public IStatement Body { get { return new BlockStatement(threadBody); } }

        /// <summary>
        /// Checks if this jump thread includes the block with the given tag.
        /// </summary>
        /// <param name="BlockTag">The block with the given tag.</param>
        /// <returns><c>true</c> if this jump thread includes the block with the given tag; otherwise, <c>false</c>.</returns>
        public bool Contains(UniqueTag BlockTag)
        {
            return threadBlocks.Contains(BlockTag);
        }

        /// <summary>
        /// Tries to simplify the given expression.
        /// </summary>
        /// <param name="Expression">The expression to simplify.</param>
        /// <returns>Either the original expression or the simplified expression.</returns>
        private IExpression Simplify(IExpression Expression)
        {
            var visitor = new GlobalValuePropagationUseVisitor(VariableValues, false);
            return visitor.Visit(Expression);
        }

        /// <summary>
        /// Tries to evaluate the given expression within the context of this jump thread.
        /// </summary>
        /// <param name="Expression">The expression to evaluate.</param>
        /// <returns>A value if the expression could be evaluated; otherwise, <c>null</c>.</returns>
        public IBoundObject EvaluateOrNull(IExpression Expression)
        {
            return Simplify(Expression).EvaluateConstant();
        }

        /// <summary>
        /// Tries to add the given block to this jump thread.
        /// </summary>
        /// <param name="Block">The block to add to this jump thread.</param>
        /// <param name="Arguments">The list of arguments for the block's parameters.</param>
        /// <returns><c>true</c> if the given block was appended to this thread; otherwise, <c>false</c>.</returns>
        public bool TryAddBlock(BasicBlock Block, IReadOnlyList<SSAVariable> Arguments)
        {
            // A jump thread cannot include a cycle. If we allowed this, then
            // we could slip into an infinite loop.
            if (!threadBlocks.Add(Block.Tag))
            {
                return false;
            }

            // Try to find definitions for argument variables.
            var paramValues = new Dictionary<SSAVariable, IExpression>();
            var paramAssignments = new Dictionary<IVariable, IVariable>();
            foreach (var param in Block.Parameters, var arg in Arguments)
            {
                IExpression argVal;
                if (varValues.TryGetValue(arg, &argVal))
                {
                    paramValues[param] = argVal;
                }

                paramAssignments[param] = arg;
            }

            // Add them all to the defined values.
            foreach (var varDef in paramValues)
            {
                varValues[varDef.Key] = varDef.Value;
            }

            // Replace parameter substitution with a parallel assignment statement.
            threadBody.Add(VariableHelpers.CreateParallelSetStatement(
                paramAssignments, new Dictionary<IType, IVariable>()));

            // Append the block's contents to the thread.
            AddBlockBody(Block.Contents);

            if (Block.Flow is SelectFlow)
            {
                // The selection flow instruction's condition might evaluate to a constant
                // value within the context of this jump thread. If so, then we can pick
                // a branch and jump to that.
                var selection = (SelectFlow)Block.Flow;
                var condVal = EvaluateOrNull(selection.Condition);
                if (condVal == null)
                {
                    FinalFlow = selection;
                }
                else if (condVal.GetValue<bool>())
                {
                    FinalFlow = new JumpFlow(selection.ThenBranch);
                }
                else
                {
                    FinalFlow = new JumpFlow(selection.ElseBranch);
                }
            }
            else
            {
                // Set the final flow instruction.
                FinalFlow = Block.Flow;
            }

            return true;
        }

        /// <summary>
        /// Adds the given basic block body to this thread.
        /// </summary>
        private void AddBlockBody(IStatement Body)
        {
            // Append the body to the thread.
            threadBody.Add(CloningVisitor.Visit(Body));

            // Analyze the body.
            AnalyzeBlockBody(Body);
        }

        /// <summary>
        /// Mines the given basic block body statement for variable definitions,
        /// which are then included in the thread.
        /// </summary>
        /// <param name="Body">The statement to mine for variable definitions.</param>
        private void AnalyzeBlockBody(IStatement Body)
        {
            // TODO: the definition-evaluation technique used here
            // is suboptimal because it does not respect the ordering of
            // the definitions. For instance, variable `j` from the example
            // below could slip through unevaluated if it is simplified
            // before `i` is.
            //
            //     i = 4
            //     j = i + 4
            //

            // Mine it for definitions.
            var defFinder = new SSAVariableDefFinder();
            defFinder.Visit(Body);

            // Simplify the definitions and update the variable value dictionary.
            foreach (var varDef in defFinder.Definitions)
            {
                varValues[varDef.Key] = Simplify(varDef.Value);
            }
        }
    }

    /// <summary>
    /// A branch visitor that tries to replace threads of branches by direct branches.
    /// This visitor works within the context for a control-flow graph.
    /// </summary>
    public class JumpThreadingVisitor : BranchVisitorBase
    {
        /// <summary>
        /// Creates a jump-threading visitor from a control-flow graph and a predicate
        /// that decides whether a block should be duplicated or not.
        /// </summary>
        public this(FlowGraph Graph, Func<BasicBlock, bool> ShouldDuplicate)
        {
            this.Graph = Graph;
            this.shouldDuplicatePredicate = ShouldDuplicate;
            this.shouldDuplicateCache = new Dictionary<BasicBlock, bool>();
            this.newBlocks = new Dictionary<UniqueTag, BasicBlock>();
            this.currentBlock = null;
        }

        private Dictionary<UniqueTag, BasicBlock> newBlocks;
        private BasicBlock currentBlock;

        /// <summary>
        /// A predicate that tells if a given basic block should be duplicated.
        /// </summary>
        private Func<BasicBlock, bool> shouldDuplicatePredicate;

        /// <summary>
        /// A cache that remembers which blocks are worth duplicating and which are not.
        /// </summary>
        private Dictionary<BasicBlock, bool> shouldDuplicateCache;

        /// <summary>
        /// Gets the control-flow graph that this jump-threading visitor operates on.
        /// </summary>
        /// <returns>The control-flow graph for this visitor.</returns>
        public FlowGraph Graph { get; private set; }

        /// <summary>
        /// Gets a dictionary that maps visited basic block tags to basic blocks in
        /// the transformed graph.
        /// </summary>
        /// <returns>A dictionary that maps basic block tags to basic blocks.</returns>
        public IReadOnlyDictionary<UniqueTag, BasicBlock> Blocks { get { return newBlocks; } }

        /// <summary>
        /// Tells if the given basic block is worth duplicating.
        /// </summary>
        /// <param name="Block">A basic block which is considered for duplication.</param>
        /// <returns><c>true</c> if the basic block is worth duplicating; otherwise, <c>false</c>.</returns>
        public bool ShouldDuplicate(BasicBlock Block)
        {
            bool result;
            if (!shouldDuplicateCache.TryGetValue(Block, &result))
            {
                result = shouldDuplicatePredicate(Block);
                shouldDuplicateCache[Block] = result;
            }
            return result;
        }

        /// <summary>
        /// Tries to discover a jump thread for the given branch in the given graph.
        /// </summary>
        /// <param name="Block">The block that defines the branch.</param>
        /// <param name="Branch">The first branch in the thread.</param>
        /// <returns>A jump thread for the given branch.</returns>
        private JumpThread DiscoverJumpThread(BasicBlock Block, BlockBranch Branch)
        {
            var thread = new JumpThread(Block, Branch);
            while (true)
            {
                // Append the branch to the thread if we think that it might be
                // worth it.
                var block = Graph.GetBlock(Branch.TargetTag);
                if (!ShouldDuplicate(block) || !thread.TryAddBlock(block, Branch.Arguments))
                {
                    break;
                }

                if (thread.FinalFlow is JumpFlow)
                {
                    // Make this jump's branch the next branch in the thread.
                    var jump = (JumpFlow)thread.FinalFlow;
                    Branch = jump.Branch;
                }
                else
                {
                    break;
                }
            }
            return thread;
        }

        public override BlockBranch Visit(BlockBranch Branch)
        {
            var thread = DiscoverJumpThread(currentBlock, Branch);
            if (thread.Length == 0)
            {
                return Branch;
            }

            // If the initialization statement does nothing, then we can simply
            // return the rewritten branch.
            var init = thread.Body;
            var newFlow = thread.FinalFlow;
            if (init.IsEmpty)
            {
                if (newFlow is JumpFlow)
                {
                    return ((JumpFlow)newFlow).Branch;
                }
                else
                {
                    return Branch;
                }
            }

            // If the initialization statement actually does something, then we need to
            // create a temporary ('thunk') block and have that perform both the initialization
            // and the branch.
            var thunkBlock = new BasicBlock(
                new UniqueTag("thunk_block"), new List<SSAVariable>(),
                init, newFlow);
            newBlocks[thunkBlock.Tag] = thunkBlock;

            // Return a branch to the thunk.
            return new BlockBranch(thunkBlock.Tag);
        }

        private BasicBlock VisitImpl(BasicBlock Block)
        {
            if (Block.Flow is JumpFlow)
            {
                var jump = (JumpFlow)Block.Flow;
                var thread = DiscoverJumpThread(Block, jump.Branch);
                if (thread.Length == 0)
                {
                    return Block;
                }

                return new BasicBlock(
                    Block.Tag, Block.Parameters,
                    new BlockStatement(new IStatement[]
                    {
                        Block.Contents,
                        thread.Body
                    }).Simplify(),
                    thread.FinalFlow);
            }
            else if (Block.Flow is SelectFlow)
            {
                var oldBlock = currentBlock;
                currentBlock = Block;
                var result = new BasicBlock(
                    Block.Tag, Block.Parameters, Block.Contents,
                    Block.Flow.Accept(this));
                currentBlock = oldBlock;
                return result;
            }
            else
            {
                return Block;
            }
        }

        /// <summary>
        /// Visits the given basic block.
        /// </summary>
        /// <param name="Block">The basic block to visit.</param>
        /// <returns>The transformed basic block.</returns>
        public BasicBlock Visit(BasicBlock Block)
        {
            BasicBlock result;
            if (newBlocks.TryGetValue(Block.Tag, &result))
            {
                return result;
            }

            result = VisitImpl(Block);
            newBlocks[result.Tag] = result;
            return result;
        }
    }

    /// <summary>
    /// A jump threading visitor that applies jump threading to entire function bodies.
    /// </summary>
    public class GlobalJumpThreadingVisitor : FlowGraphVisitorBase
    {
        public this(Func<BasicBlock, bool> ShouldDuplicate)
        {
            this.ShouldDuplicate = ShouldDuplicate;
        }

        /// <summary>
        /// Gets a predicate that tells if a given basic block should be duplicated.
        /// </summary>
        public Func<BasicBlock, bool> ShouldDuplicate { get; private set; }

        protected override FlowGraph Visit(FlowGraph Graph)
        {
            // Perform jump threading.
            var visitor = new JumpThreadingVisitor(Graph, ShouldDuplicate);
            foreach (var block in Graph.Blocks)
            {
                visitor.Visit(block);
            }

            // We may have created dead blocks and we should really clean them up.
            // Dead block elimination is a relatively cheap operation that eases the
            // burden of the SSA construction algorithm.
            return new FlowGraph(Graph.EntryPointTag, visitor.Blocks).EliminateUnreachable();
        }
    }

    /// <summary>
    /// A heuristic that decides if blocks are worth duplicating based on block
    /// sizes and parameter counts.
    /// </summary>
    public class SizeBasedBlockDuplicationHeuristic
    {
        public this(int Tolerance, int ParameterWeight)
        {
            this.Tolerance = Tolerance;
            this.ParameterWeight = ParameterWeight;
        }

        /// <summary>
        /// Gets the 'tolerance' value, which is used as a constant factor
        /// when deciding whether a block should be split or not.
        /// </summary>
        public int Tolerance { get; private set; }

        /// <summary>
        /// Gets the 'parameter weight' value, which describes the 'cost' of
        /// having a parameter in terms of IR node sizes.
        /// </summary>
        public int ParameterWeight { get; private set; }

        /// <summary>
        /// Decides whether it is feasible to duplicate the given block.
        /// </summary>
        public bool ShouldDuplicate(BasicBlock Block)
        {
            // Replacing parameters by locals will typically allow us to optimize more
            // aggressively, and it also reduces the size of live ranges for variables.
            int pro = Tolerance + Block.Parameters.Count * ParameterWeight;

            // Don't duplicate large blocks. That'd just increase code
            // size, which is probably a bad idea for cache and JIT reasons.
            var sizeVisitor = new SizeVisitor(true);
            Block.Accept(sizeVisitor);

            return pro - sizeVisitor.Size > 0;
        }
    }

    /// <summary>
    /// A pass that applies simple jump threading to flow graphs.
    /// </summary>
    public static class JumpThreadingPass : IPass<BodyPassArgument, IStatement>
    {
        /// <summary>
        /// This pass' name.
        /// </summary>
        public const string JumpThreadingPassName = "jump-threading";

        /// <summary>
        /// The option that specifies the block duplication 'tolerance' value.
        /// </summary>
        public const string ToleranceOption = "duplicate-block-tolerance";

        /// <summary>
        /// The option that specifies the block duplication 'parameter weight'
        /// value.
        /// </summary>
        public const string ParameterWeightOption = "duplicate-block-param-weight";

        public IStatement Apply(BodyPassArgument Arg)
            in { VerifyCFGPass.Apply(Arg.Body) }
            in
            {
                VerifySSAPass.Apply(
                    Arg.Body, Arg.PassEnvironment.Log, Arg.DeclaringMethod,
                    JumpThreadingPassName + " (input)")
            }
            out (result) { VerifyCFGPass.Apply(result) }
            out (result)
            {
                VerifySSAPass.Apply(
                    result, Arg.PassEnvironment.Log, Arg.DeclaringMethod,
                    JumpThreadingPassName + " (output)")
            }
        {
            var log = Arg.PassEnvironment.Log;
            int tolerance = log.Options.GetOption<int>(ToleranceOption, 8);
            int paramWeight = log.Options.GetOption<int>(ParameterWeightOption, 2);
            var heuristic = new SizeBasedBlockDuplicationHeuristic(tolerance, paramWeight);
            var visitor = new GlobalJumpThreadingVisitor(heuristic.ShouldDuplicate);
            // Apply the visitor.
            var visitedBody = visitor.Visit(Arg.Body);

            // Fix broken SSA form in the visited body.
            return FixBrokenSSAPass.Apply(visitedBody);
        }
    }
}
