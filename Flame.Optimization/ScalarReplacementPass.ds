using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;
using Pixie;

namespace Flame.Optimization
{
    // Scalar replacement of aggregates is an optimization that replaces
    // aggregates (for now, we'll stick to value types) by a number of scalars.
    // This has the advantage of making those scalars candidates for register
    // allocation, and is useful because it enables other optimizations.
    //
    // Let A and B be an aggregate variables, let C and D be values of X's type,
    // let X be a field of said aggregate, and let f be a function.
    // We will define the following transformation rules:
    //
    //     (&A)->X = C;
    // ==> D = C;
    //
    //     (&A)->X;
    // ==> D;
    //
    //     &(&A)->X;
    // ==> &D;
    //
    //     (&A)->f(args...);
    // ==> inline(f, D, ..., args...);
    //
    //     A = B;
    // ==> { A1 = B1; ... An = Bn; }
    //
    //     A = default(typeof(A));
    // ==> { A1 = default(A1); ... An = default(An); }
    //
    // Only variables that are used in one of the above rewrite rules can be
    // transformed.

    /// <summary>
    /// A helper visitor that replaces aggregates by scalars
    /// in branch instructions.
    /// </summary>
    public class ScalarReplacementBranchVisitor : BranchVisitorBase
    {
        public const this(
            set IReadOnlyDictionary<LocalVariableBase, IReadOnlyDictionary<IField, LocalVariableBase>> Replacements);

        public IReadOnlyDictionary<LocalVariableBase, IReadOnlyDictionary<IField, LocalVariableBase>> Replacements { get; private set; }

        /// <summary>
        /// Visits an argument/parameter list of SSA variables.
        /// </summary>
        public IReadOnlyList<SSAVariable> VisitVariableList(
            IReadOnlyList<SSAVariable> Variables)
        {
            var argList = new List<SSAVariable>(Variables.Count);
            foreach (var arg in Variables)
            {
                IReadOnlyDictionary<IField, LocalVariableBase> replMap;
                if (Replacements.TryGetValue(arg, &replMap))
                {
                    argList.AddRange(Enumerable.Cast<SSAVariable>(replMap.Values));
                }
                else
                {
                    argList.Add(arg);
                }
            }
            return argList;
        }

        /// <summary>
        /// Visits the given block branch instruction.
        /// </summary>
        public override BlockBranch Visit(BlockBranch Branch)
        {
            return new BlockBranch(
                Branch.TargetTag, VisitVariableList(Branch.Arguments));
        }
    }

    /// <summary>
    /// A node visitor that replaces value type variables by scalar variables,
    /// provided that such a substitution is possible.
    /// </summary>
    public class ScalarReplacementVisitor : INodeVisitor
    {
        public const this(
            set BodyPassArgument PassArgument,
            set bool(IType) ShouldReplace,
            set bool(DissectedCall) ShouldInline,
            set bool ShouldExplainReplacements)
        {
            this.variableDependencies = new Dictionary<LocalVariableBase, HashSet<LocalVariableBase>>();
            this.blacklist = new HashSet<LocalVariableBase>();
            this.specExprs = new Dictionary<LocalVariableBase, List<SpeculativeExpression>>();
            this.specStmts = new Dictionary<LocalVariableBase, List<SpeculativeStatement>>();
            this.specRepls = new Dictionary<LocalVariableBase, IReadOnlyDictionary<IField, LocalVariableBase>>();
            this.variableNameMap = new UniqueNameMap<LocalVariableBase>(GetVariableName, "%");
            this.inlineMethods = new HashSet<IMethod>();
        }

        /// <summary>
        /// Gets the pass argument.
        /// </summary>
        public BodyPassArgument PassArgument { get; private set; }

        /// <summary>
        /// Gets boolean value that dictates whether this scalar replacement pass
        /// should explain its reasoning for scalar replacements, and scalar
        /// replacement failures.
        /// </summary>
        public bool ShouldExplainReplacements { get; private set; }

        /// <summary>
        /// Determines whether the given (value) type should be replaced by its
        /// components.
        /// </summary>
        public bool(IType) ShouldReplace { get; private set; }

        /// <summary>
        /// Checks if the given method should be inlined.
        /// </summary>
        public bool(DissectedCall) ShouldInline { get; private set; }

        /// <summary>
        /// Gets the declaring type, which is used to evaluate member
        /// accessibility.
        /// </summary>
        public IType DeclaringType { get { return PassArgument.DeclaringType; } }

        // Dictionaries that maps local variables to lists of speculative nodes,
        // which describe said local variable's behavior, assuming that it is
        // safe to replace by scalars.
        private Dictionary<LocalVariableBase, List<SpeculativeExpression>> specExprs;
        private Dictionary<LocalVariableBase, List<SpeculativeStatement>> specStmts;
        private Dictionary<LocalVariableBase, IReadOnlyDictionary<IField, LocalVariableBase>> specRepls;

        // A map that maps local variables to unique names, to issue
        // remarks.
        private UniqueNameMap<LocalVariableBase> variableNameMap;

        // Remember the local variable that is the current inline target.
        // This can be used to make accesses to inaccessible fields
        // dependent on the replacement of specific variables:
        // if the inline target is marked as irreplaceable, then the
        // inaccessible field accesses will disappear.
        private LocalVariableBase inlineTarget;

        // Maintain a set of all methods that are currently being inlined,
        // to keep us from recursively inlining recursive methods (as that
        // may cause infinite recursion).
        private HashSet<IMethod> inlineMethods;

        /// <summary>
        /// Gets a dictionary that maps local variables to their
        /// field-scalar mapping.
        /// </summary>
        public IReadOnlyDictionary<LocalVariableBase, IReadOnlyDictionary<IField, LocalVariableBase>> Replacements
        {
            get { return specRepls; }
        }

        private string GetVariableName(LocalVariableBase Local)
        {
            return Local.Member.Name.ToString();
        }

        /// <summary>
        /// Describes the given local with a sequence of markup nodes.
        /// </summary>
        public [MarkupNode] DescribeLocal(LocalVariableBase Local)
        {
            var nodes = new List<MarkupNode>();
            string varName = variableNameMap[Local];
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "'"));
            nodes.Add(new MarkupNode(NodeConstants.BrightNodeType, varName));
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "'"));
            string memberName = Local.Member.Name.ToString();
            if (!string.IsNullOrWhiteSpace(memberName) && memberName != varName)
            {
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType, " ('"));
                nodes.Add(new MarkupNode(NodeConstants.BrightNodeType, memberName));
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "')"));
            }
            return nodes;
        }

        private void RemarkFailedScalarReplacement(LocalVariableBase Aggregate, string Reason)
        {
            if (!ShouldExplainReplacements || !IsAggregate(Aggregate.Type))
                return;

            var nodes = new List<MarkupNode>();

            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "could not replace "));
            nodes.AddRange(DescribeLocal(Aggregate));
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, " by scalars, because "));
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, Reason));
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, " "));

            // Add a cause node ('[-Rscalarrepl-details]')
            nodes.Add(Flags.CreateCauseNode(ScalarReplacementPassBase.ScalarReplacementDetailsRemarksOption));
            // Add diagnostics for the method
            nodes.Add(PassArgument.DeclaringMethod.GetSourceLocation().CreateDiagnosticsNode());

            var log = PassArgument.PassEnvironment.Log;
            log.LogMessage(new LogEntry("pass remark", nodes));
        }

        // A dictionary that maps local variables to the variables that depend
        // on them: the value variables cannot be replaced by scalars unless the
        // key variable is replaced by an aggregate.
        private Dictionary<LocalVariableBase, HashSet<LocalVariableBase>> variableDependencies;

        // A set of local variables that are ineligible for scalar replacement.
        private HashSet<LocalVariableBase> blacklist;

        private INode contextNode;

        private List<T> GetOrCreateList<T>(
            Dictionary<LocalVariableBase, List<T>> Cache,
            LocalVariableBase Key)
        {
            List<T> result;
            if (!Cache.TryGetValue(Key, &result))
            {
                result = new List<T>();
                Cache[Key] = result;
            }
            return result;
        }

        private HashSet<LocalVariableBase> GetOrCreateSet(
            Dictionary<LocalVariableBase, HashSet<LocalVariableBase>> Cache,
            LocalVariableBase Key)
        {
            HashSet<LocalVariableBase> result;
            if (!Cache.TryGetValue(Key, &result))
            {
                result = new HashSet<LocalVariableBase>();
                Cache[Key] = result;
            }
            return result;
        }

        private IReadOnlyDictionary<IField, LocalVariableBase> GetScalarReplacements(
            LocalVariableBase Key)
        {
            assert(!IsBlacklisted(Key));
            IReadOnlyDictionary<IField, LocalVariableBase> result;
            if (!specRepls.TryGetValue(Key, &result))
            {
                var mutResult = new Dictionary<IField, LocalVariableBase>();
                bool makeSSA = Key is SSAVariable;
                foreach (var item in Key.Type.Fields)
                {
                    if (!item.IsStatic)
                    {
                        if (makeSSA)
                            mutResult[item] = new SSAVariable(item.FieldType);
                        else
                            mutResult[item] = new LocalVariable(item.FieldType);
                    }
                }
                specRepls[Key] = mutResult;
                result = mutResult;
            }
            return result;
        }

        /// <summary>
        /// Marks the given local variable as irreplaceable.
        /// </summary>
        private void MarkIrreplaceable(LocalVariableBase Local)
        {
            if (blacklist.Add(Local))
            {
                // Kill all speculative scalar replacement nodes for this
                // local.
                foreach (var item in GetOrCreateList<SpeculativeExpression>(specExprs, Local))
                {
                    item.IsAlive = false;
                }
                specExprs.Remove(Local);

                foreach (var item in GetOrCreateList<SpeculativeStatement>(specStmts, Local))
                {
                    item.IsAlive = false;
                }
                specStmts.Remove(Local);

                // Remove the local from the speculative replacement dictionary.
                specRepls.Remove(Local);

                // Mark all variables that depend on this variable getting
                // replaced, as irreplaceable.
                foreach (var item in GetOrCreateSet(variableDependencies, Local))
                {
                    MarkIrreplaceable(item);
                }
            }
        }

        /// <summary>
        /// Marks the given local variable as irreplaceable, and explains why.
        /// </summary>
        private void MarkIrreplaceable(LocalVariableBase Local, string Reason)
        {
            if (!IsBlacklisted(Local))
            {
                MarkIrreplaceable(Local);
                RemarkFailedScalarReplacement(Local, Reason);
            }
        }

        /// <summary>
        /// Marks the first local variable as a copy of the second local variable.
        /// </summary>
        public void MarkCopy(LocalVariableBase Destination, LocalVariableBase Source)
        {
            if (IsBlacklisted(Destination) || IsBlacklisted(Source))
            {
                // If one is irreplaceable, then we should make the other
                // irreplaceable, as well.
                MarkIrreplaceable(Destination);
                MarkIrreplaceable(Source);
            }
            else
            {
                // Otherwise, insert a dependency.
                GetOrCreateSet(variableDependencies, Destination).Add(Source);
                GetOrCreateSet(variableDependencies, Source).Add(Destination);
            }
        }

        /// <summary>
        /// Cancels the current inlining operation, by blacklisting the
        /// inline target.
        /// </summary>
        private void CancelInline(string Reason)
        {
            if (inlineTarget != null)
            {
                MarkIrreplaceable(inlineTarget, Reason);
                // Might as well make the inline target null now
                // to save ourselves some cycles.
                inlineTarget = null;
            }
        }

        /// <summary>
        /// Makes the innermost inlining operation dependent on the given type
        /// member's accessibility. All is well as long as either the type
        /// member is accessible from the current scope, or the target variable
        /// is replaced by aggregates.
        /// </summary>
        private void CheckAccessibility(
            LocalVariableBase Target, ITypeMember Member)
        {
            if (inlineTarget != null && !AccessChecker.CanAccess(DeclaringType, Member, PassArgument))
            {
                if (IsBlacklisted(Target))
                {
                    // There's just no way to recover from this.
                    CancelInline(
                        "member '" + Member.FullName + "' was not accessible " +
                        "from the current scope.");
                }
                else
                {
                    // Inaccessible members _can_ be accessed, provided that
                    // their target is replaced by scalars.
                    GetOrCreateSet(variableDependencies, Target).Add(inlineTarget);
                }
            }
        }

        /// <summary>
        /// Checks if the given type is an aggregate type that should, if at all
        /// possible, be replaced by scalars.
        /// </summary>
        private bool IsAggregate(IType Type)
        {
            return Type.IsValueType && ShouldReplace(Type);
        }

        /// <summary>
        /// Checks if the given variable has been blacklisted: it cannot be
        /// replaced by scalars, even though it is an aggregate.
        /// </summary>
        private bool IsBlacklisted(LocalVariableBase Variable)
        {
            return blacklist.Contains(Variable);
        }

        /// <summary>
        /// Represents the given variable as an aggregate local.
        /// If the variable is no aggregate variable,
        /// or if it's an irreplaceable aggregate,
        /// then null is returned.
        /// </summary>
        private LocalVariableBase AsAggregateLocal(IVariable Variable)
        {
            if (Variable is LocalVariableBase)
            {
                var localVar = (LocalVariableBase)Variable;
                if (!IsBlacklisted(localVar) && IsAggregate(localVar.Type))
                    return localVar;
            }
            else if (Variable is AtAddressVariable && IsAggregate(Variable.Type))
            {
                // Also try to peek through pointer indirection.
                var addrVar = (AtAddressVariable)Variable;
                return AsAggregateLocal(addrVar.Pointer);
            }
            return null;
        }

        /// <summary>
        /// Tries to interpret the given expression as some local aggregate's address.
        /// If the expression does indeed represent an aggregate's address, then
        /// the local aggregate variable is returned. Otherwise, null is returned.
        /// </summary>
        private LocalVariableBase AsAggregateLocal(IExpression Expression)
        {
            var innerExpr = Expression.GetEssentialExpression();
            if (innerExpr is IVariableNode)
            {
                var varNode = (IVariableNode)innerExpr;
                return AsAggregateLocal(varNode.GetVariable());
            }
            else
            {
                return null;
            }
        }

        private SpeculativeExpression MakeSpeculative(
            LocalVariableBase Variable, IExpression Safe, IExpression Speculative)
        {
            assert(!IsBlacklisted(Variable));
            var result = new SpeculativeExpression(Speculative, Safe);
            GetOrCreateList<SpeculativeExpression>(specExprs, Variable).Add(result);
            return result;
        }

        private SpeculativeStatement MakeSpeculative(
            LocalVariableBase Variable, IStatement Safe, IStatement Speculative)
        {
            assert(!IsBlacklisted(Variable));
            var result = new SpeculativeStatement(Speculative, Safe);
            GetOrCreateList<SpeculativeStatement>(specStmts, Variable).Add(result);
            return result;
        }

        public bool Matches(IExpression Expression)
        {
            return Expression is IVariableNode
                || Expression is InvocationExpression;
        }

        public bool Matches(IStatement Statement)
        {
            return Statement is ISetVariableNode
                || Statement is FlowGraphStatement;
        }

        private IExpression TransformGetField(FieldGetExpression Expression)
        {
            var target = AsAggregateLocal(Expression.Target);
            if (target == null)
            {
                return Expression.Accept(this);
            }
            else
            {
                var result = MakeSpeculative(
                    target, Expression,
                    GetScalarReplacements(target)[Expression.Field].CreateGetExpression());
                CheckAccessibility(target, Expression.Field);
                return result;
            }
        }

        private IExpression TransformFieldAddress(FieldGetPointerExpression Expression)
        {
            var target = AsAggregateLocal(Expression.Target);
            if (target == null)
            {
                return Expression.Accept(this);
            }
            else
            {
                var result = MakeSpeculative(
                    target, Expression,
                    ((IUnmanagedVariable)GetScalarReplacements(target)[Expression.Field]).CreateAddressOfExpression());
                CheckAccessibility(target, Expression.Field);
                return result;
            }
        }

        private IStatement TransformSetField(FieldSetStatement Statement)
        {
            var target = AsAggregateLocal(Statement.Target);
            if (target == null)
            {
                return Statement.Accept(this);
            }
            else
            {
                var val = Visit(Statement.Value);
                var conservativeStmt = new FieldSetStatement(Statement.Field, Statement.Target, val);
                if (IsBlacklisted(target))
                {
                    return conservativeStmt;
                }
                else
                {
                    var result = MakeSpeculative(
                        target, conservativeStmt,
                        GetScalarReplacements(target)[Statement.Field].CreateSetStatement(val));
                    CheckAccessibility(target, Statement.Field);
                    return result;
                }
            }
        }

        private IStatement TransformCopy(
            LocalVariableBase Destination, LocalVariableBase Source,
            IStatement Original)
        {
            var scalarCopy = new List<IStatement>();

            var destRepls = GetScalarReplacements(Destination);
            var srcRepls = GetScalarReplacements(Source);
            foreach (var field in srcRepls.Keys)
            {
                scalarCopy.Add(
                    destRepls[field].CreateSetStatement(
                        srcRepls[field].CreateGetExpression()));
            }
            MarkCopy(Destination, Source);
            return MakeSpeculative(
                Destination, Original,
                new BlockStatement(scalarCopy).Simplify());
        }

        private IStatement TransformAssignDefault(
            LocalVariableBase Destination, IStatement Original)
        {
            var stmts = new List<IStatement>();
            var destRepls = GetScalarReplacements(Destination);
            foreach (var scalar in destRepls.Values)
            {
                stmts.Add(scalar.CreateSetStatement(
                    new DefaultValueExpression(scalar.Type).Optimize()));
            }
            return MakeSpeculative(
                Destination, Original,
                new BlockStatement(stmts).Simplify());
        }

        private IStatement TransformAssignInvocation(
            LocalVariableBase Destination, IStatement Original,
            InvocationExpression Expression)
        {
            var inlinedCall = TryMakeInlinedCall(Expression, Destination);

            if (inlinedCall == null)
            {
                MarkIrreplaceable(
                    Destination,
                    "it was assigned the return value of a non-inlined function call.");
                return Original.Accept(this);
            }
            else
            {
                // Awesome. Now we just have to take into account that the
                // destination variable's replaceability hinges on this
                // inlining operation being performed, i.e. the call target
                // getting replaced by scalars.
                GetOrCreateSet(variableDependencies, inlinedCall.Item1).Add(Destination);
                return MakeSpeculative(inlinedCall.Item1, Original, inlinedCall.Item2);
            }
        }

        private IExpression TransformInvocation(InvocationExpression Expression)
        {
            var temp = new LocalVariable(Expression.Type);
            var inlinedCall = TryMakeInlinedCall(Expression, temp);

            if (inlinedCall == null)
            {
                return Expression.Accept(this);
            }
            else
            {
                return MakeSpeculative(
                    inlinedCall.Item1, Expression,
                    InliningVisitor.CreateLetExpression(
                        inlinedCall.Item2, temp));
            }
        }

        private Tuple<LocalVariableBase, IStatement> TryMakeInlinedCall(
            InvocationExpression Expression, IVariable ReturnVariable)
        {
            // Invocation expressions are a bit of an odd case: their
            // caller can always be replaced by scalars (if the invocation
            // is inlined, that is). Their arguments cannot be replaced,
            // however, unless the aforementioned inlining operation
            // is performed.
            var target = Expression.Target.GetEssentialExpression();
            if (target is GetMethodExpression)
            {
                // We can only inline direct calls.
                var getMethodExpr = (GetMethodExpression)target;
                if (!getMethodExpr.Op.Equals(Operator.GetDelegate))
                    return null;

                // Inlining non-aggregate local calls may not be safe, and is
                // not one of this pass' responsibilities.
                var targetVar = AsAggregateLocal(getMethodExpr.Caller);
                if (targetVar == null)
                    return null;

                // Inline the call, and then visit the expression.
                var inlinedCall = MakeInlinedCall(
                    targetVar, getMethodExpr.Caller,
                    getMethodExpr.Target, Expression.Arguments,
                    ReturnVariable);

                // The inlining operation itself could have blacklisted
                // the target variable. So we have to check for that here.
                if (inlinedCall == null || IsBlacklisted(targetVar))
                    return null;

                // We did it! Now let's just hope that we won't have to
                // roll back the inlining operation.
                return Tuple.Create<LocalVariableBase, IStatement>(targetVar, inlinedCall);
            }
            return null;
        }

        private IStatement MakeInlinedCall(
            LocalVariableBase TargetVar, IExpression TargetExpr,
            IMethod Method, [IExpression] Arguments, IVariable ReturnVariable)
        {
            var genMethodDecl = Method.GetRecursiveGenericDeclaration();
            if (inlineMethods.Contains(genMethodDecl))
                // Don't inline recursive methods.
                return null;

            // Let's start by checking if the inlining operation makes sense,
            // theoretically, according to the inlining heuristic.
            var theoreticalCall = new DissectedCall(
                TargetExpr, Method, Arguments, false);

            if (!ShouldInline(theoreticalCall))
                return null;

            // Scalar replacement of aggregates allows us to perform inlining
            // that would be illegal under normal circumstances, due to
            // access modifiers.
            //
            // However, we have to be careful to preserve the program's validity.
            // What we'd really like to avoid is the following unsafe
            // transformation:
            //
            //   1. First, we speculatively inline a function call.
            //   2. We then visit said inlined call, and the base
            //      argument variables' replaceabilities on the inlined call.
            //   3. At some point, we notice that the inlined call's
            //      target variable cannot be replaced by scalars.
            //      We roll back the inlining operation.
            //   4. The notion of replaceability for argument variables,
            //      which we computed in step 2., has now become incorrect.
            //
            // To avoid generating an invalid program (which is what happens
            // if we do nothing in step 4.), we will do one of the following,
            // per argument:
            //
            //   1. Preferably, we will discover that the argument is
            //      a local aggregate that can be replaced by scalars. We will
            //      mark said local variable as dependent on the call's target
            //      variable.
            //   2. Otherwise, we will visit the argument expression. This is
            //      a more conservative approach than option 1, so we'll use
            //      it as a last resort.

            var argList = new List<IExpression>();
            foreach (var arg in Arguments)
            {
                var aggrLocal = AsAggregateLocal(arg);
                if (aggrLocal != null)
                {
                    // Option 1., as described above.
                    GetOrCreateSet(variableDependencies, TargetVar).Add(aggrLocal);
                    argList.Add(arg);
                }
                else
                {
                    // Option 2., as described above.
                    argList.Add(Visit(arg));
                }
            }

            var call = new DissectedCall(TargetExpr, Method, argList, false);

            inlineMethods.Add(genMethodDecl);
            var oldInlineTarget = inlineTarget;
            inlineTarget = TargetVar;

            // Be sure to visit the inlined call, as it will probably impose
            // additional restrictions (though they probably won't be
            // as severe as the restrictions obtained by electing _not_
            // to inline the call).
            var result = Visit(InliningVisitor.InlineBody(call, ReturnVariable, PassArgument));

            inlineTarget = oldInlineTarget;
            inlineMethods.Remove(genMethodDecl);

            if (!AccessChecker.CanAccess(DeclaringType, result, PassArgument))
            {
                // Sometimes, we just can't inline everything, due to
                // access modifiers. In that case, we have to cancel
                // the inlining operation.
                return null;
            }

            return result;
        }

        private BasicBlock RewriteFlow(BasicBlock Block, ScalarReplacementBranchVisitor Visitor)
        {
            return new BasicBlock(
                Block.Tag, Visitor.VisitVariableList(Block.Parameters),
                Block.Contents, Block.Flow.Accept(Visitor));
        }

        private IStatement TransformFlowGraph(FlowGraphStatement Statement)
        {
            var graph = Statement.Graph;

            // First, mark all argument/parameter pairs as copies,
            // and rewrite block contents.
            var results = new Dictionary<UniqueTag, BasicBlock>();
            foreach (var block in graph.Blocks)
            {
                results[block.Tag] = block.Accept(this);
                foreach (var br in block.Flow.Branches)
                {
                    foreach (var arg in br.Arguments,
                             var parameter in graph.GetBlock(br.TargetTag).Parameters)
                    {
                        MarkCopy(parameter, arg);
                    }
                }
            }

            // All replacements are now final.
            // We can safely rewrite parameter and argument lists.
            var branchReplVisitor = new ScalarReplacementBranchVisitor(Replacements);
            foreach (var tag in graph.BlockTags)
            {
                results[tag] = RewriteFlow(results[tag], branchReplVisitor);
            }
            return new FlowGraphStatement(new FlowGraph(graph.EntryPointTag, results));
        }

        protected IExpression Transform(IExpression Expression)
        {
            if (Expression is FieldGetExpression)
            {
                return TransformGetField((FieldGetExpression)Expression);
            }
            else if (Expression is FieldGetPointerExpression)
            {
                return TransformFieldAddress((FieldGetPointerExpression)Expression);
            }
            else if (Expression is InvocationExpression)
            {
                return TransformInvocation((InvocationExpression)Expression);
            }

            assert(Expression is IVariableNode);
            var varNode = (IVariableNode)Expression;
            var srcVar = varNode.GetVariable();
            if (srcVar is LocalVariableBase)
            {
                // Both get and address-of expressions cannot be replaced, unless
                // they appear in some special context. This is not
                // one of those special cases.
                string valOrAddress;
                if (varNode.Action == VariableNodeAction.AddressOf)
                    valOrAddress = "address";
                else
                    valOrAddress = "value";

                string contextString;
                if (contextNode == null)
                    contextString = "";
                else
                    contextString = " (context node: " + contextNode.ToString() + ")";

                MarkIrreplaceable(
                    (LocalVariableBase)srcVar,
                    "its " + valOrAddress + " was taken outside of some special context." + contextString);
            }
            return Expression.Accept(this);
        }

        protected IStatement Transform(IStatement Statement)
        {
            if (Statement is FlowGraphStatement)
                return TransformFlowGraph((FlowGraphStatement)Statement);

            assert(Statement is ISetVariableNode);
            if (Statement is FieldSetStatement)
            {
                return TransformSetField((FieldSetStatement)Statement);
            }
            else
            {
                // This is a simple (aggregate) copy, i.e. A = B;
                // We'll try to transform it to a scalar copy.

                var setVarStmt = (ISetVariableNode)Statement;
                var dest = AsAggregateLocal(setVarStmt.GetVariable());
                if (dest == null)
                    // Destination variable is not an aggregate.
                    // Nothing to do here.
                    return Statement.Accept(this);

                var src = AsAggregateLocal(setVarStmt.Value);
                if (src != null)
                {
                    return TransformCopy(dest, src, Statement);
                }

                var essentialVal = setVarStmt.Value.GetEssentialExpression();
                if (essentialVal is DefaultValueExpression)
                {
                    // We can handle default assignment.
                    return TransformAssignDefault(dest, Statement);
                }
                else if (essentialVal is InvocationExpression)
                {
                    // We can also transform a number of assignments.
                    return TransformAssignInvocation(dest, Statement, (InvocationExpression)essentialVal);
                }
                else
                {
                    // Destination variable cannot be replaced by scalars, because
                    // the source value cannot be replaced, either. Bummer.
                    MarkIrreplaceable(dest);
                    return Statement.Accept(this);
                }
            }
        }

        public IExpression Visit(IExpression Value)
        {
            if (Matches(Value))
            {
                return Transform(Value);
            }
            else
            {
                var oldContextNode = contextNode;
                contextNode = Value;
                var result = Value.Accept(this);
                contextNode = oldContextNode;
                return result;
            }
        }

        public IStatement Visit(IStatement Value)
        {
            if (Matches(Value))
            {
                return Transform(Value);
            }
            else
            {
                var oldContextNode = contextNode;
                contextNode = Value;
                var result = Value.Accept(this);
                contextNode = oldContextNode;
                return result;
            }
        }
    }

    /// <summary>
    /// A base class for passes that replace scalars by aggregates.
    /// </summary>
    public abstract class ScalarReplacementPassBase : LoopPassBase
    {
        /// <summary>
        /// The scalar replacement of aggregates pass name.
        /// </summary>
        public const string ScalarReplacementPassName = "scalarrepl";

        /// <summary>
        /// The remarks option for scalar replacement: applying this pass to
        /// functions may emit messages if this is option set to true.
        /// </summary>
        public string ScalarReplacementRemarksOption
        {
            get { return Flags.GetRemarkOptionName(ScalarReplacementPassName); }
        }

        /// <summary>
        /// The option for detailed scalar replacement remarks: this option
        /// explains why scalar replacement is and is not performed.
        /// </summary>
        public static string ScalarReplacementDetailsRemarksOption
        {
            get { return Flags.GetRemarkOptionName(ScalarReplacementPassName + "-details"); }
        }

        /// <summary>
        /// Creates a delegate that determines whether the given aggregate
        /// should be replaced by scalars.
        /// </summary>
        public abstract bool(IType) GetReplacementCriteria(BodyPassArgument Argument);

        /// <summary>
        /// Creates a delegate that determines whether the given dissected
        /// direct call should be inlined. There is no need to take accessibility
        /// into account, as the scalar replacement visitor takes care of this.
        /// </summary>
        public abstract bool(DissectedCall) GetInliningCriteria(BodyPassArgument Argument);

        /// <summary>
        /// Logs a message that proclaims that an inlining operation
        /// has occurred.
        /// </summary>
        protected virtual void LogScalarReplacements(
            BodyPassArgument Argument, ScalarReplacementVisitor Visitor,
            int RecursionDepth, bool Detailed)
        {
            var nodes = new List<MarkupNode>();

            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, "replaced "));
            if (Detailed)
            {
                bool first = true;
                foreach (var local in Visitor.Replacements.Keys)
                {
                    if (first)
                        first = false;
                    else
                        nodes.Add(new MarkupNode(NodeConstants.TextNodeType, ", "));

                    nodes.AddRange(Visitor.DescribeLocal(local));
                }
            }
            else
            {
                int replCount = Visitor.Replacements.Count;

                // Add a description
                if (replCount == 1)
                {
                    nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                        "1 aggregate"));
                }
                else
                {
                    nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                        replCount + " aggregates"));
                }
            }
            nodes.Add(new MarkupNode(NodeConstants.TextNodeType, " by scalars. "));

            if (RecursionDepth > 0)
            {
                nodes.Add(new MarkupNode(NodeConstants.TextNodeType,
                    "(recursion depth: " + RecursionDepth + ") "));
            }

            // Add a cause node ('[-Rscalarrepl]')
            nodes.Add(Flags.CreateCauseNode(ScalarReplacementRemarksOption));
            // Add diagnostics for the method
            nodes.Add(Argument.DeclaringMethod.GetSourceLocation().CreateDiagnosticsNode());

            var log = Argument.PassEnvironment.Log;
            log.LogMessage(new LogEntry("pass remark", nodes));
        }

        public LoopPassResult Apply(BodyPassArgument Argument, int Iteration)
            in { VerifyCFGPass.Apply(Argument.Body) }
            in
            {
                VerifySSAPass.Apply(
                    Argument.Body, Argument.PassEnvironment.Log, Argument.DeclaringMethod,
                    ScalarReplacementPassName + " (input)")
            }
            out (result) { VerifyCFGPass.Apply(result.Body) }
            out (result)
            {
                VerifySSAPass.Apply(
                    result.Body, Argument.PassEnvironment.Log,
                    Argument.DeclaringMethod,
                    ScalarReplacementPassName + " (output)")
            }
        {
            var shouldReplace = GetReplacementCriteria(Argument);
            var shouldInline = GetInliningCriteria(Argument);
            var log = Argument.PassEnvironment.Log;
            bool shouldRemarkDetails = log.Options.GetOption<bool>(
                ScalarReplacementDetailsRemarksOption, false);
            bool shouldRemark = log.Options.GetOption<bool>(
                ScalarReplacementRemarksOption, shouldRemarkDetails);

            var visitor = new ScalarReplacementVisitor(
                Argument, shouldReplace, shouldInline, shouldRemarkDetails);
            var result = visitor.Visit(Argument.Body);

            int replCount = visitor.Replacements.Count;
            if (replCount > 0 && shouldRemark)
            {
                // Let's print some diagnostics, because we're so proud of
                // our work.
                LogScalarReplacements(
                    Argument, visitor, Iteration, shouldRemarkDetails);
            }
            return new LoopPassResult(result, replCount > 0);
        }
    }
}
