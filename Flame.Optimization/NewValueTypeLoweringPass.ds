using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Native;
using Flame.Compiler.Statements;
using Flame.Compiler.Visitors;
using Flame.Compiler.Variables;

namespace Flame.Optimization
{
    /// <summary>
    /// A pass that lowers value type creation expressions
    /// (i.e. calls to value type constructors that do not have
    /// a 'this' pointer) to temporaries and direct calls.
    /// </summary>
    public class NewValueTypeLoweringPass : NodeVisitorBase, IPass<IStatement, IStatement>
    {
        /// <summary>
        /// Creates a new-value type lowering pass instance.
        /// </summary>
        public const this(set bool MustLowerExpressions);

        /// <summary>
        /// A boolean value that tells whether new-value type expressions must
        /// also be lowered, in addition to new-value type assignments.
        /// </summary>
        public bool MustLowerExpressions { get; private set; }

        /// <summary>
        /// The name of the new-value type expression lowering pass.
        /// </summary>
        public const string NewValueTypeLoweringPassName = "lower-new-struct";

        /// <summary>
        /// The name of the new-value type expression optimization pass.
        /// </summary>
        public const string NewValueTypeOptimizationPassName = "optimize-new-struct";

        public override bool Matches(IExpression Value)
        {
            // Only lower new-value type invocations if we are instructed
            // to do so.
            return MustLowerExpressions && Value is InvocationExpression;
        }

        public override bool Matches(IStatement Value)
        {
            return Value is ISetVariableNode;
        }

        /// <summary>
        /// Initializes the given value type variable.
        /// The given constructor is called with the given
        /// arguments.
        /// </summary>
        public static IStatement InitializeValueType(
            IUnmanagedVariable Variable, IMethod Constructor,
            [IExpression] Arguments)
        {
            var result = new List<IStatement>();
            if (!Constructor.HasAttribute(PrimitiveAttributes.Instance.TotalInitializationAttribute.AttributeType))
                result.Add(Variable.CreateSetStatement(
                    new DefaultValueExpression(Variable.Type)));
            result.Add(new ExpressionStatement(new InvocationExpression(
                Constructor,
                Variable.CreateAddressOfExpression(),
                Arguments)));
            return new BlockStatement(result).Simplify();
        }

        /// <summary>
        /// Returns a constructor-expression pair that describes
        /// how the given expression creates a new value type.
        /// If the given expression does not create a value type,
        /// then null is returned.
        /// </summary>
        private static Tuple<IMethod, [IExpression]> ExtractNewValueTypeExpr(IExpression Expression)
        {
            if (!(Expression is InvocationExpression))
                return null;

            var invExpr = (InvocationExpression)Expression;
            var invTarget = invExpr.Target.GetEssentialExpression();

            if (!(invTarget is GetMethodExpression))
                return null;

            var target = (GetMethodExpression)invTarget;

            if (target != null &&
                target.Caller == null &&
                target.Target.IsConstructor &&
                target.Target.DeclaringType.GetIsValueType())
            {
                return Tuple.Create<IMethod, [IExpression]>(target.Target, invExpr.Arguments);
            }
            else
            {
                return null;
            }
        }

        private IExpression CreateInitializedExpression(
            IMethod Constructor, [IExpression] Arguments)
        {
            var temp = new LocalVariable(Constructor.DeclaringType);
            return new InitializedExpression(
                Visit(InitializeValueType(temp, Constructor, Arguments)),
                temp.CreateGetExpression(),
                temp.CreateReleaseStatement());
        }

        protected override IExpression Transform(IExpression Expression)
        {
            var exprTuple = ExtractNewValueTypeExpr(Expression);

            if (exprTuple == null)
                return Expression.Accept(this);

            return CreateInitializedExpression(exprTuple.Item1, exprTuple.Item2);
        }

        protected override IStatement Transform(IStatement Statement)
        {
            var setVarNode = (ISetVariableNode)Statement;

            var exprTuple = ExtractNewValueTypeExpr(setVarNode.Value.GetEssentialExpression());
            if (exprTuple == null)
                return Statement.Accept(this);

            var destVar = setVarNode.GetVariable();

            if (destVar is IUnmanagedVariable)
            {
                return Visit(InitializeValueType(
                    (IUnmanagedVariable)destVar, exprTuple.Item1, exprTuple.Item2));
            }
            else
            {
                return Statement.Accept(this);
            }
        }

        public IStatement Apply(IStatement Statement)
        {
            return Visit(Statement);
        }
    }
}
