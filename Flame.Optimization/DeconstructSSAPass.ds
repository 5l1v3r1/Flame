using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Flow;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// Contains all SSA local variable liveliness data for a single block.
    /// </summary>
    public class SSALivelinessData
    {
        public const this()
        {
            this.nodeIndex = 1;
            this.livePos = new Dictionary<SSAVariable, int>();
            this.deadPos = new Dictionary<SSAVariable, int>();
            this.usedVars = new HashSet<SSAVariable>();
        }

        private int nodeIndex;
        private Dictionary<SSAVariable, int> livePos;
        private Dictionary<SSAVariable, int> deadPos;
        private HashSet<SSAVariable> usedVars;

        private const int ImportPoint = -1;
        private const int ParameterPoint = 0;
        private const int ExportPoint = int.MaxValue;

        /// <summary>
        /// Gets the set of all variables whose values are loaded by this block.
        /// </summary>
        public [SSAVariable] UsedVariables
        {
            const get
            {
                return usedVars;
            }
        }

        /// <summary>
        /// Registers a definition action for the given variable.
        /// </summary>
        public void RegisterDefinition(SSAVariable Variable)
        {
            nodeIndex++;
            livePos[Variable] = nodeIndex;
        }

        /// <summary>
        /// Registers a get-value action for the given variable.
        /// </summary>
        public void RegisterAccess(SSAVariable Variable)
        {
            nodeIndex++;
            deadPos[Variable] = nodeIndex;
            usedVars.Add(Variable);
        }

        /// <summary>
        /// Marks the given variable as "imported", which means that
        /// it is defined elsewhere.
        /// </summary>
        public void MarkImport(SSAVariable Variable)
        {
            livePos[Variable] = ImportPoint;
        }

        /// <summary>
        /// Marks the given variable as a parameter: a locally defined
        /// variable that is assigned in parallel with the other parameters.
        /// </summary>
        public void MarkParameter(SSAVariable Variable)
        {
            livePos[Variable] = ParameterPoint;
        }

        /// <summary>
        /// Marks the given variable as an argument for this block.
        /// </summary>
        public void MarkArgument(SSAVariable Variable)
        {
            deadPos[Variable] = ParameterPoint;
            usedVars.Add(Variable);
        }

        /// <summary>
        /// "Exports" the given variable: its final access it set to the
        /// maximal value, which basically makes it immortal within the
        /// context of this block.
        /// </summary>
        public void MarkExport(SSAVariable Variable)
        {
            deadPos[Variable] = ExportPoint;
        }

        /// <summary>
        /// Checks if this block defines the given variable locally, i.e.
        /// it is defined within the block's body, or it is one of the block's
        /// parameters.
        /// </summary>
        public bool Defines(SSAVariable Variable)
        {
            int livePoint;
            return livePos.TryGetValue(Variable, &int livePoint)
                && livePoint >= ParameterPoint;
        }

        /// <summary>
        /// Checks if this block defines or imports the given variable.
        /// </summary>
        public bool DefinesOrImports(SSAVariable Variable)
        {
            return livePos.ContainsKey(Variable);
        }

        /// <summary>
        /// Gets an index that describes the point at which the given variable
        /// is defined.
        /// </summary>
        public int GetDefinitionIndex(SSAVariable Variable)
        {
            if (livePos.TryGetValue(Variable, &int livePoint))
                return livePoint;
            else
                return int.MaxValue;
        }

        /// <summary>
        /// Gets an index that describes the point at which the given variable
        /// is accessed for the last time.
        /// </summary>
        public int GetLastAccessIndex(SSAVariable Variable)
        {
            if (!deadPos.TryGetValue(Variable, &int deadPoint))
                return deadPoint;
            else
                return int.MinValue;
        }

        /// <summary>
        /// Checks if the given variable is live at the given point in execution,
        /// which is encoded as an integer.
        /// </summary>
        public bool IsLive(SSAVariable Variable, int Index)
        {
            int deadPoint = GetLastAccessIndex(Variable);
            int livePoint = GetDefinitionIndex(Variable);

            return Index >= livePoint && Index <= deadPoint;
        }
    }

    /// <summary>
    /// A node visitor that discovers live ranges.
    /// </summary>
    public class SSALiveRangeVisitor : NodeVisitorBase
    {
        public const this(
            set SSALiveRangeData Data,
            set Dictionary<SSAVariable, HashSet<SSALiveRangeData>> DefinitionBlocks,
            set Dictionary<SSAVariable, HashSet<SSAVariable>> Related);

        public SSALiveRangeData Data { const get; private set; }
        public Dictionary<SSAVariable, HashSet<SSALiveRangeData>> DefinitionBlocks { const get; private set; }
        public Dictionary<SSAVariable, HashSet<SSAVariable>> Related { const get; private set; }

        private void MarkRelatedAsymmetric(SSAVariable Left, SSAVariable Right)
        {
            HashSet<SSAVariable> relatedSet;
            if (!Related.TryGetValue(Left, &relatedSet))
            {
                relatedSet = new HashSet<SSAVariable>();
                Related[Left] = relatedSet;
            }
            relatedSet.Add(Right);
        }

        public void MarkRelated(SSAVariable Left, SSAVariable Right)
        {
            MarkRelatedAsymmetric(Left, Right);
            MarkRelatedAsymmetric(Right, Left);
        }

        public override const bool Matches(IExpression Value)
        {
            return Value is SSAGetExpression;
        }
        public override const bool Matches(IStatement Value)
        {
            return Value is SSADefineStatement;
        }

        protected override IExpression Transform(IExpression Expression)
        {
            var expr = (SSAGetExpression)Expression;
            Data.RegisterAccess(expr.Variable);
            return expr;
        }

        protected override IStatement Transform(IStatement Statement)
        {
            var stmt = (SSADefineStatement)Statement;
            var leftVar = stmt.Variable;
            var val = stmt.Value.GetEssentialExpression();
            Visit(val);
            if (val is SSAGetExpression)
            {
                var rightVar = ((SSAGetExpression)val).Variable;
                MarkRelated(leftVar, rightVar);
            }

            Data.RegisterDefinition(leftVar);

            assert(!DefinitionBlocks.ContainsKey(leftVar));
            var defsSet = new HashSet<SSALivelinessData>();
            defsSet.Add(Data);
            DefinitionBlocks[leftVar] = defsSet;

            return stmt;
        }
    }

    /// <summary>
    /// A data structure that contains live ranges for a control-flow graph,
    /// as well as a related variable map.
    /// </summary>
    public struct SSAGraphLiveliness
    {
        public const this(
            set Dictionary<UniqueTag, SSALiveRangeData> LiveRanges,
            set Dictionary<SSAVariable, HashSet<SSALiveRangeData>> DefinitionBlocks,
            set Dictionary<SSAVariable, HashSet<SSAVariable>> Related);

        /// <summary>
        /// Gets the graph's block tag - live ranges map.
        /// </summary>
        public Dictionary<UniqueTag, SSALiveRangeData> LiveRanges { const get; private set; }

        /// <summary>
        /// Gets a dictionary that maps SSA variables to their set of definition
        /// points, which are either assignments, or arguments.
        /// </summary>
        public Dictionary<SSAVariable, HashSet<SSALiveRangeData>> DefinitionBlocks { const get; private set; }

        /// <summary>
        /// Gets the graph's related variable set map.
        /// Coalescing these variables should result in less variable copying.
        /// </summary>
        public Dictionary<SSAVariable, HashSet<SSAVariable>> Related { const get; private set; }
    }

    /// <summary>
    /// Defines a pass that deconstructs SSA form.
    /// </summary>
    public static class DeconstructSSAPass : FlowGraphVisitorBase, IPass<IStatement, IStatement>
    {
        public const string DeconstructSSAPassName = "deconstruct-ssa";

        alias PredecessorPair = Tuple<UniqueTag, IReadOnlyList<SSAVariable>>;
        alias PredecessorDict = IReadOnlyDictionary<UniqueTag, [PredecessorPair]>;

        /// <summary>
        /// Checks if the live range for the block with the given tag defines
        /// or imports the given SSA variable. If not, then that variable is
        /// imported, and this method is applied recursively to its
        /// predecessor blocks.
        /// </summary>
        private void PropagateImport(
            UniqueTag Tag, SSAVariable Imported,
            PredecessorDict Predecessors,
            Dictionary<UniqueTag, SSALiveRangeData> LiveRanges)
        {
            var range = LiveRanges[Tag];
            if (!range.DefinesOrImports(Imported))
            {
                range.Import(Imported);
                if (Predecessors.ContainsKey(Tag))
                {
                    foreach (var pred in Predecessors[Tag])
                    {
                        PropagateImport(
                            pred.Item1, Imported, Predecessors, LiveRanges);
                    }
                }
            }
        }

        /// <summary>
        /// Computes live ranges, as well as related variables, for the given
        /// flow graph.
        /// </summary>
        private SSAGraphLiveliness ComputeLiveliness(FlowGraph Graph)
        {
            var results = new Dictionary<UniqueTag, SSALiveRangeData>();
            var defBlocks = new Dictionary<SSAVariable, HashSet<SSALiveRangeData>>();
            var related = new Dictionary<SSAVariable, HashSet<SSAVariable>>();
            foreach (var tag in Graph.BlockTags)
            {
                results[tag] = new SSALiveRangeData();
            }
            foreach (var block in Graph.Blocks)
            {
                var data = results[block.Tag];
                var visitor = new SSALiveRangeVisitor(data, defBlocks, related);
                visitor.Visit(block.Contents);

                foreach (var parameter in block.Parameters)
                    data.MarkParameter(parameter);

                foreach (var branch in block.Flow.Branches)
                foreach (var arg in branch.Arguments,
                         var parameter in Graph.GetBlock(arg.TargetTag).Parameters)
                {
                    data.MarkArgument(arg);
                    visitor.MarkRelated(arg, parameter);

                    HashSet<SSALiveRangeData> defSet;
                    if (!defBlocks.TryGetValue(parameter, &defSet))
                    {
                        defSet = new HashSet<SSALiveRangeData>();
                        defBlocks[parameter] = defSet;
                    }
                    defSet.Add(data);
                }
            }

            var preds = Graph.GetPredecessors();
            foreach (var item in results)
            {
                foreach (var usedVar in item.Value.UsedVariables)
                {
                    // Mark all imported variables as live.
                    PropagateImport(item.Key, usedVar, preds, results);
                }
            }

            return new SSAGraphLiveliness(results, defBlocks, related);
        }

        private bool LivelinessIntersects(
            SSAVariable First, SSAVariable Second,
            SSALivelinessData Liveliness)
        {
            
        }

        private bool CanCoalesce(
            LocalVariable Register, SSAVariable Variable,
            HashSet<SSAVariable> Neighbors)
        {
            foreach (var local in Neighbors)
            {
                if (LivelinessIntersects(local, Variable))
                    return false;
            }
            return true;
        }

        private bool HasIntersectionElements(
            HashSet<SSAVariable> Left, HashSet<SSAVariable> Right)
        {
            var inter = new HashSet<SSAVariable>(Left);
            inter.IntersectWith(Right);
            return inter.Count > 0;
        }

        private LocalVariable AllocateRegister(
            SSAVariable Variable, SSALivelinessData Liveliness,
            HashSet<SSAVariable> RelatedVariables,
            Dictionary<LocalVariable, HashSet<SSAVariable>> AllocatedRegisters)
        {
            var unrelated = new Dictionary<LocalVariable, HashSet<SSAVariable>>();

            // Try to coalesce related variables first.
            foreach (var pair in AllocatedRegisters)
            {
                if (HasIntersectionElements(RelatedVariables, pair.Value))
                {
                    if (CanCoalesce(pair.Key, Variable, pair.Value))
                    {
                        pair.Value.Add(Variable);
                        return pair.Key;
                    }
                    else
                    {
                        unrelated[pair.Key] = pair.Value;
                    }
                }
            }

            // Then try to coalesce unrelated variables.
            foreach (var pair in unrelated)
            {
                if (CanCoalesce(pair.Key, Variable, pair.Value))
                {
                    pair.Value.Add(Variable);
                    return pair.Key;
                }
            }

            // We couldn't re-use a pre-existing register. That's okay, though.
            // We'll just conjure op a new register, and use that.
            var newReg = new LocalVariable(Variable.Member);
            var newSet = new HashSet<SSAVariable>();
            newSet.Add(Variable);
            AllocatedRegisters[newReg] = Variable;
            return newReg;
        }

        private FlowGraph RegAlloc(FlowGraph Graph, SSAGraphLiveliness Liveliness)
        {
            // Perform register allocation on the SSA variables.
            // We will try to coalesce SSA variables as much as possible.

            var allocatedRegs = new Dictionary<LocalVariable, HashSet<SSAVariable>>();
            var allocatedVars = new Dictionary<SSAVariable, LocalVariable>();

        }

        protected override FlowGraph Visit(FlowGraph Graph)
        {
            return RegAlloc(Graph, ComputeLiveliness(Graph));
        }

        public IStatement Apply(IStatement Statement)
        {
            return Visit(Statement);
        }
    }
}
