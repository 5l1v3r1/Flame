using System;
using Flame.Compiler;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// Defines access checking techniques.
    /// </summary>
    public class AccessChecker
    {
        private const this(set IType currentType);

        /// <summary>
        /// The current type, which is used to access other types, fields and methods.
        /// </summary>
        private IType currentType;

        /// <summary>
        /// Tells if invalid access has been detected.
        /// </summary>
        private bool invalidAccess;

        private IType CheckTypeAccess(IType Target)
        {
            if (!invalidAccess && !currentType.CanAccess(Target))
            {
                invalidAccess = true;
            }
            return Target;
        }

        private T CheckMemberAccess<T>(T Target)
            where T : ITypeMember
        {
            if (!invalidAccess && !currentType.CanAccess(Target))
            {
                invalidAccess = true;
            }
            return Target;
        }

        private PredicateMemberNodeVisitor CreateCheckingVisitor()
        {
            var memberConv = new MemberConverter(
                new DelegateConverter<IType, IType>(CheckTypeAccess),
                new DelegateConverter<IMethod, IMethod>(CheckMemberAccess<IMethod>),
                new DelegateConverter<IField, IField>(CheckMemberAccess<IField>));

            return new PredicateMemberNodeVisitor(memberConv);
        }

        /// <summary>
        /// Determines whether the given type can access all types and members
        /// that are referenced by the given statement.
        /// </summary>
        public static bool CanAccess(IType CurrentType, IStatement Statement)
        {
            var checker = new AccessChecker(CurrentType);
            var visitor = checker.CreateCheckingVisitor();

            visitor.Visit(Statement);

            return !checker.invalidAccess;
        }

        /// <summary>
        /// Determines whether the given type can access all types and members
        /// that are referenced by the given expression.
        /// </summary>
        public static bool CanAccess(IType CurrentType, IExpression Expression)
        {
            var checker = new AccessChecker(CurrentType);
            var visitor = checker.CreateCheckingVisitor();

            visitor.Visit(Expression);

            return !checker.invalidAccess;
        }
    }
}
