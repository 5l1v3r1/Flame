using System;
using System.Collections.Generic;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;

namespace Flame.Optimization
{
    /// <summary>
    /// A pass that optimizes division/remainder operations with a constant RHS by
    /// using bitwise operations and modulo arithmetic.
    /// </summary>
    public class BithacksPass : NodeVisitorBase, IPass<IStatement, IStatement>
    {
        public this(int LargestIntSize)
        {
            this.LargestIntSize = LargestIntSize;
        }

        /// <summary>
        /// Gets the size in bits of the largest integer type that supports multiplication.
        /// </summary>
        /// <returns>The size in bits of the largest integer type that supports multiplication.</returns>
        public int LargestIntSize { get; private set; }

        /// <summary>
        /// Gets the name of the bithacks pass name.
        /// </summary>
        public const string BithacksPassName = "bithacks";

        public override bool Matches(IStatement Statement)
        {
            return false;
        }

        public override bool Matches(IExpression Expression)
        {
            return Expression is DivideExpression
                || Expression is RemainderExpression;
        }

        protected override IStatement Transform(IStatement Statement)
        {
            return Statement.Accept(this);
        }

        protected override IExpression Transform(IExpression Expression)
        {
            assert(Expression is BinaryExpression);
            var exprType = Expression.Type;

            var binExpr = (BinaryExpression)Expression;
            var rhs = binExpr.RightOperand.EvaluateConstant();
            if (rhs == null)
            {
                return Expression.Accept(this);
            }

            var rhsVal = rhs.GetValue<IntegerValue>();
            var one = new IntegerValue(1).Cast(rhsVal.Spec);

            if (Expression is DivideExpression)
            {
                if (rhsVal.Equals(one))
                {
                    return Visit(binExpr.LeftOperand);
                }
                else if (rhsVal.Normalized.Equals(one.Negated))
                {
                    return Visit(new NegateExpression(binExpr.LeftOperand));
                }
                else if (exprType.IsUnsignedInteger)
                {
                    if (rhsVal.IsPowerOfTwo)
                    {
                        // If the RHS is a power of two, then we can replace the division by a
                        // right shift.
                        var powOfTwo = rhsVal.IntegerLog(new IntegerValue(2).Cast(rhsVal.Spec));
                        return new RightShiftExpression(Visit(binExpr.LeftOperand), new IntegerExpression(powOfTwo));
                    }
                    else if (rhsVal.Spec.Size * 2 <= LargestIntSize)
                    {
                        return CreateUnsignedDivisionByConstant(binExpr.LeftOperand, rhsVal, exprType);
                    }
                }
            }
            else
            {
                assert(Expression is RemainderExpression);
                if (rhsVal.Equals(one))
                {
                    return new IntegerExpression( new IntegerValue(0).Cast(rhsVal.Spec));
                }
                else if (exprType.IsUnsignedInteger && rhsVal.IsPowerOfTwo)
                {
                    // We can replace `x % (2 ^ n)` with `x & mask`. Here's how `mask`
                    // is derived:
                    //
                    // Remainder(x, y) = x - y * Divide(x, y)
                    //                 = x - (2 ^ n) * Divide(x, 2 ^ n)
                    //                 = x - ((x >> n) << n)
                    //                 = x - (x & 0xFF...FF00...00)
                    //                                     ^~~~~~~ n bits
                    //                 = 0x00...00XX...XX
                    //                            ^~~~~~~ n low bits of x
                    //                 = x & 0x00...00FF...FF
                    //                                ^~~~~~~ n bits
                    //                 = x & (decltype(x))((1u << n) - 1)
                    //                 = x & mask
                    //
                    var powOfTwo = rhsVal.IntegerLog(new IntegerValue(2).Cast(rhsVal.Spec));
                    var mask = one.ShiftLeft(powOfTwo).Subtract(one).Cast(rhsVal.Spec);
                    return new AndExpression(Visit(binExpr.LeftOperand), new IntegerExpression(mask));
                }
            }
            return Expression.Accept(this);
        }

        /// <summary>
        /// Creates an expression that performs unsigned integer division by a constant value.
        /// </summary>
        /// <param name="LeftOperand">The left-hand side of the division operation.</param>
        /// <param name="RightOperand">The right-hand side of the division operation.</param>
        /// <param name="Type">The division's result type.</param>
        /// <returns>An expression that performs unsigned integer division by a constant value.</returns>
        private IExpression CreateUnsignedDivisionByConstant(
            IExpression LeftOperand, IntegerValue RightOperand, IType Type)
        {
            var lhs = LeftOperand;
            var rhsVal = RightOperand;
            var magic = rhsVal.ComputeUnsignedDivisionMagic();
            var one = new IntegerValue(1).Cast(rhsVal.Spec);

            var init = new List<IStatement>();
            if (magic.UseAdd)
            {
                if (rhsVal.IsEven)
                {
                    // If the RHS is even, then we should shift the LHS now. That'll
                    // save us some instructions and a variable.
                    int shiftAmount = rhsVal.TrailingZeroCount;
                    var shiftAmountVal = new IntegerValue(shiftAmount).Cast(rhsVal.Spec);
                    lhs = new RightShiftExpression(
                        lhs,
                        new IntegerExpression(shiftAmountVal));

                    // We know that (RHS >> shiftAmount) has shiftAmount leading zeros and
                    // we can use that information when recomputing the magic number.
                    magic = rhsVal.ShiftRight(shiftAmountVal).ComputeUnsignedDivisionMagic(shiftAmount);
                    assert(!magic.UseAdd);
                }
                else if (!IsLocalVariableGetExpr(lhs.GetEssentialExpression()))
                {
                    // We're going to use the LHS twice in the computation, so we have to spill it
                    // into a variable here.
                    var lhsReg = new RegisterVariable(lhs.Type);
                    init.Add(lhsReg.CreateSetStatement(lhs));
                    lhs = lhsReg.CreateGetExpression();
                }
            }

            // We now want to multiply the LHS by a magic constant and get the high half of
            // the result. However, we don't have an instruction that does that. (And Flame's
            // target platforms typically don't have one, either.) So we'll improvise by
            // first casting the LHS to an integer that is twice as wide, multiplying it by
            // the magic constant and extracting the high half of the result.
            var longType = PrimitiveTypes.GetUIntType(rhsVal.Spec.Size * 2);
            var longSpec = longType.GetIntegerSpec();
            IExpression mul = new MultiplyExpression(
                new StaticCastExpression(lhs, longType).Simplify(),
                new IntegerExpression(magic.Multiplier.Cast(longSpec)));

            if (magic.UseAdd)
            {
                // Extract the high half of the multiplication's result and store that in
                // a register.
                var mulReg = new RegisterVariable(Type);
                init.Add(mulReg.CreateSetStatement(
                    new StaticCastExpression(
                        new RightShiftExpression(
                            mul,
                            new IntegerExpression(
                                new IntegerValue(rhsVal.Spec.Size).Cast(longSpec))),
                        Type)));
                mul = mulReg.CreateGetExpression();

                // Compute the result.
                var result = new RightShiftExpression(
                    new AddExpression(
                        new RightShiftExpression(
                            new SubtractExpression(lhs, mul),
                            new IntegerExpression(one)),
                        mul),
                    new IntegerExpression(
                        new IntegerValue(magic.ShiftAmount - 1).Cast(longSpec)));

                // Return an expression.
                return Visit(new InitializedExpression(
                    new BlockStatement(init),
                    result));
            }
            else
            {
                // Shift the result `rhsVal.Spec.Size` bits to the right to extract the
                // high half of the multiplication's result and then shift it `magic.ShiftAmount`
                // bits to the right to satisfy the computation.
                return Visit(new StaticCastExpression(
                    new RightShiftExpression(
                        mul,
                        new IntegerExpression(
                            new IntegerValue(rhsVal.Spec.Size + magic.ShiftAmount).Cast(longSpec))),
                    Type));
            }
        }

        private static bool IsLocalVariableGetExpr(IExpression Expression)
        {
            if (Expression is IVariableNode)
            {
                var varNode = (IVariableNode)Expression;
                if (varNode.Action == VariableNodeAction.Get)
                {
                    var variable = varNode.GetVariable();
                    if (variable is ArgumentVariable
                        || variable is LocalVariableBase)
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public IStatement Apply(IStatement Statement)
        {
            return Visit(Statement);
        }
    }
}