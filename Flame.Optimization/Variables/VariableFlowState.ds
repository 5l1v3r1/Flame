using System;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.Compiler.Statements;

namespace Flame.Optimization.Variables
{
    /// <summary>
    /// A type of node that describes variable flow.
    /// </summary>
    public struct VariableFlowNode
    {
        public const this(set IVariableFlow Body, set InsertStatement PostInsert);

        public IVariableFlow Body { const get; private set; }
        public InsertStatement PostInsert { const get; private set; }
    }

    /// <summary>
    /// Defines a variable flow state, which is a singly linked list of
    /// sequential variable flow bodies.
    /// </summary>
    public abstract class VariableFlowState
    {
        /// <summary>
        /// Tests if this variable flow state is nonempty.
        /// </summary>
        public bool IsCons { const get return this is ConsVariableFlowState; }

        /// <summary>
        /// Tests if this variable flow state is empty.
        /// </summary>
        public bool IsNil { const get return this is NilVariableFlowState; }

        /// <summary>
        /// Casts this variable flow state to a nonempty variable flow state.
        /// Please use this alongside `IsCons`.
        /// </summary>
        public const ConsVariableFlowState AsCons()
        {
            return (ConsVariableFlowState)this;
        }

        /// <summary>
        /// Returns the insert point directly after the variable flow state's body.
        /// </summary>
        public abstract InsertStatement PostInsert { abstract const get; }

        /// <summary>
        /// Converts this variable flow state to sequential flow.
        /// </summary>
        public abstract const IVariableFlow ToFlow();

        /// <summary>
        /// Creates a new nonempty flow state by "appending" the given
        /// node to this flow state.
        /// No state is mutated.
        /// </summary>
        public const ConsVariableFlowState Cons(VariableFlowNode Node)
        {
            return new ConsVariableFlowState(Node, this);
        }

        /// <summary>
        /// Concatenates two variable flow states.
        /// </summary>
        public const VariableFlowState Concat(VariableFlowState Second)
        {
            if (Second.IsNil)
            {
                return this;
            }
            else
            {
                var secondCons = Second.AsCons();
                return Concat(secondCons.Tail).Cons(secondCons.Node);
            }
        }

        public const VariableFlowState Delta(VariableFlowState Second)
        {
            if (this.IsNil)
                return Second;
            else if (Second.IsNil)
                throw new ArgumentException("Invalid argument 'Second': Could not find any delta flow.");

            var thisCons = this.AsCons();
            var scndCons = Second.AsCons();

            if (thisCons == scndCons)
                return new NilVariableFlowState(thisCons.PreInsert);
            else
                return Delta(scndCons.Tail).Cons(scndCons.Node);
        }

        public const VariableFlowState Select(VariableFlowState First, VariableFlowState Second)
        {
            var flow = new SelectVariableFlow(this.PostInsert,
                                              First.ToFlow(), First.PostInsert,
                                              Second.ToFlow(), Second.PostInsert);

            // Make the select's post-insert statement the same as the pre-insert statement.
            // This may not be optimal, but some constructs just don't have a true post-insert statement:
            // a 'switch' block, for example, would have a tree of select blocks,
            // where two adjacent select blocks would likely not have a post-insert statement.
            //
            // Instead, the visitor will create a post-insert statement and
            // add this to the state.

            return this.Cons(new VariableFlowNode(flow, this.PostInsert));
        }

        public const VariableFlowState Loop(VariableFlowState Body)
        {
            var flow = new LoopVariableFlow(this.PostInsert, Body.ToFlow(), Body.PostInsert);

            // Make the cons' post-insert statement the same as the loop's post-insert
            // statement. This doesn't feel right, but I can't come up with
            // anything better to do. A statement that performs two loops
            // without a node inbetween doesn't offer any space to insert a
            // post-insert statement.
            //
            // Again, the visitor will create post-insert statements where appropriate.

            return this.Cons(new VariableFlowNode(flow, Body.PostInsert));
        }
    }

    /// <summary>
    /// An empty variable flow state.
    /// </summary>
    public class NilVariableFlowState : VariableFlowState
    {
        public const this(set InsertStatement InsertPoint);

        public InsertStatement InsertPoint { const get; private set; }

        public override InsertStatement PostInsert { override const get return InsertPoint; }
        public override const IVariableFlow ToFlow()
        {
            return EmptyVariableFlow;
        }
    }

    /// <summary>
    /// A nonempty variable flow state.
    /// </summary>
    public class ConsVariableFlowState : VariableFlowState
    {
        public const this(set VariableFlowNode Node, set VariableFlowState Tail);

        public VariableFlowNode Node { const get; private set; }
        public VariableFlowState Tail { const get; private set; }

        public InsertStatement PreInsert { const get return Tail.PostInsert; }
        public override InsertStatement PostInsert { override const get return Node.PostInsert; }

        public override const IVariableFlow ToFlow()
        {
            return new SequenceVariableFlow(Tail.ToFlow(), Node.Body);
        }
    }
}
