
namespace Flame.Optimization.Variables
{
    /// <summary>
    /// Records how many times a variable or variable definition has been accessed.
    /// </summary>
    public struct AccessCount
    {
        /// <summary>
        /// Creates a new access count that represents zero variable accesses.
        /// </summary>
        public const this();

        /// <summary>
        /// Creates a new access count that represents the specified number of accesses.
        /// </summary>
        public const this(set int Count);

        private const this(set bool IsInfinity, set int Count);

        /// <summary>
        /// Gets a boolean value that tells if this access count is an infinite number.
        /// </summary>
        public bool IsInfinity { const get; private set; }

        /// <summary>
        /// Gets the number of accesses, provided that this access count is not
        /// infinite.
        /// </summary>
        public int Count { const get; private set; }

        /// <summary>
        /// Adds this access count to another.
        /// </summary>
        public const AccessCount Add(AccessCount Other)
        {
            return new AccessCount(IsInfinity || Other.IsInfinity, Count + Other.Count);
        }

        /// <summary>
        /// Multiplies this access count with another.
        /// </summary>
        public const AccessCount Multiply(AccessCount Other)
        {
            // Multiplication rules:
            //  +  0 * x == 0
            //  +  Inf * y == Inf, where y != 0
            //  +  x * y == y * x

            int mulCount = Count * Other.Count;
            if ((this.IsInfinity || Other.IsInfinity) && mulCount > 0)
                return Infinity;
            else
                return new AccessCount(mulCount);
        }

        public const bool IsGreaterThanOrEquals(AccessCount Other)
        {
            return this.IsInfinity || (!Other.IsInfinity && Count >= Other.Count);
        }

        public const bool IsLessThanOrEquals(AccessCount Other)
        {
            return IsLessThan(Other) || Equals(Other);
        }

        public const bool IsGreaterThan(AccessCount Other)
        {
            return IsGreaterThanOrEquals(Other) && !Equals(Other);
        }

        public const bool IsLessThan(AccessCount Other)
        {
            return !IsGreaterThanOrEquals(Other);
        }

        public const AccessCount Max(AccessCount Other)
        {
            if (IsGreaterThanOrEquals(Other))
                return this;
            else
                return Other;
        }

        public const AccessCount Min(AccessCount Other)
        {
            if (IsGreaterThanOrEquals(Other))
                return Other;
            else
                return this;
        }

        public const override int GetHashCode()
        {
            if (IsInfinity)
                return -1;
            else
                return Count;
        }

        public const override bool Equals(object Other)
        {
            if (Other is AccessCount)
            {
                var otherCount = (AccessCount)Other;
                if (this.IsInfinity != otherCount.IsInfinity)
                    return false;
                else if (this.IsInfinity) // Both are infinite.
                    return true;
                else // Neither is infinite.
                    return this.Count == otherCount.Count;
            }
            else
            {
                return false;
            }
        }

        public const override string ToString()
        {
            if (IsInfinity)
                return "Infinity";
            else
                return (string)Count;
        }

        /// <summary>
        /// Gets an access count that represents an infinite number of accesses.
        /// </summary>
        public static AccessCount Infinity
        {
            const get return new AccessCount(true, 1);
        }
    }
}
