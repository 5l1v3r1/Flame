using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Visitors;

namespace Flame.Optimization.Variables
{
    /// <summary>
    /// A pass that applies constant and copy propagation to statements.
    /// </summary>
    public static class DefinitionPropagationPass : IPass<IStatement, IStatement>
    {
        /// <summary>
        /// Applies this pass to the given value.
        /// </summary>
        public IStatement Apply(IStatement Value)
        {
            var visitor = new VariableDefinitionVisitor();
            var newTree = visitor.Visit(Value);
            if (visitor.CurrentFlow == null)
                return newTree.Optimize(); // No point in updating definition reaches
                                           // if there aren't any.

            var flow = visitor.CurrentFlow.ToFlow();
            foreach (var item in visitor.DefinitionChains)
            {
                var initialReach = new VariableDefinitionReach(
                    new LocalVariableDefinition(VariableFlowHelpers.CreateLocal(item.MappedLocal)),
                    item.MappedLocal);
                flow.UpdateReach(initialReach, item); // Update the reach and chain.
            }

            // Invent some access metrics.
            var accessCounter = new AccessVisitor();
            accessCounter.Visit(newTree);
            AccessMetrics(IVariableDefinition, bool) accessFunc = accessCounter.FlattenedFlow;

            foreach (var chain in visitor.DefinitionChains)
            {
                // Copy the collection so we don't modify and enumerate at the same
                // time.
                var defsCopy = Enumerable.ToArray<VariableDefinitionReach>(chain.Definitions);
                foreach (var item in defsCopy)
                {
                    var bounds = accessFunc(item.Definition, false);
                    var newReach = item.Definition.UseMetrics(item, bounds);
                    chain.AddDefinition(newReach);
                }
            }

            return new DeadCodeVisitor().Visit(newTree.Optimize());
        }
    }
}
