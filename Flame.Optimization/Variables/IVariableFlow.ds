using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Variables;

namespace Flame.Optimization.Variables
{
    /// <summary>
    /// Defines a termination point for a block, which ends the current iteration.
    /// </summary>
    public struct BlockTerminationPoint
    {
        public const this(set VariableDefinitionReach Reach, set InsertStatement PreInsert);

        public VariableDefinitionReach Reach { const get; private set; }
        public InsertStatement PreInsert { const get; private set; }
    }

    /// <summary>
    /// Defines common functionality for variable flow structures.
    /// </summary>
    public interface IVariableFlow
    {
        /// <summary>
        /// Gets all termination points for the given chain and tagged block.
        /// This method must be called after updating the chain's reach
        /// with this block.
        /// </summary>
        const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Tag);

        /// <summary>
        /// Updates the given variable reach, possibly using a pre-insert point.
        /// </summary>
        VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain);
    }

    public static class EmptyVariableFlow : IVariableFlow
    {
        public const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Tag)
        {
            return Enumerable.Empty<BlockTerminationPoint>();
        }

        public VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            return Reach;
        }
    }

    public class VariableDefinitionFlow : IVariableFlow
    {
        public const this(set InsertStatement PreInsert, set VariableDefinitionReach Definition);

        public InsertStatement PreInsert { const get; private set; }
        public VariableDefinitionReach Definition { const get; private set; }

        public const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Tag)
        {
            return Enumerable.Empty<BlockTerminationPoint>();
        }

        public VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            if (Definition.MappedLocal == Reach.MappedLocal)
                return VariableFlowHelpers.Succeed(Chain, Reach, Definition, PreInsert);
            else
                return Reach.Definition.ReactTo(Reach, Definition, PreInsert);
        }
    }

    public class VariableAccessFlow : IVariableFlow
    {
        public const this(set VariableDefinitionChain AccessedChain, set IDefinitionAccess Access);

        public VariableDefinitionChain AccessedChain { const get; private set; }
        public IDefinitionAccess Access { const get; private set; }

        public const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Tag)
        {
            return Enumerable.Empty<BlockTerminationPoint>();
        }

        public VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            if (AccessedChain == Chain)
            {
                Chain.AddDefinition(Reach);
                Reach.Add(Access);
            }
            return Reach;
        }
    }

    public class SequenceVariableFlow : IVariableFlow
    {
        public const this(set IVariableFlow First, set IVariableFlow Second);

        public IVariableFlow First { const get; private set; }
        public IVariableFlow Second { const get; private set; }

        public const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Tag)
        {
            return Enumerable.Concat<BlockTerminationPoint>(
                First.GetTerminationPoints(Chain, Tag),
                Second.GetTerminationPoints(Chain, Tag));
        }

        public VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            var newReach = First.UpdateReach(Reach, Chain);
            return Second.UpdateReach(newReach, Chain);
        }
    }
}
