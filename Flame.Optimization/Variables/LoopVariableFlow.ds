using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;

namespace Flame.Optimization.Variables
{
    public class LoopVariableFlow : IVariableFlow
    {
        public const this(set UniqueTag Tag, set InsertStatement PreInsert,
                          set IVariableFlow LoopBody, set InsertStatement LoopPostInsert);

        public UniqueTag Tag { const get; private set; }
        public InsertStatement PreInsert { const get; private set; }
        public IVariableFlow LoopBody { const get; private set; }
        public InsertStatement LoopPostInsert { const get; private set; }

        public const [BlockTerminationPoint] GetTerminationPoints(VariableDefinitionChain Chain, UniqueTag Target)
        {
            return LoopBody.GetTerminationPoints(Chain, Target);
        }

        private List<BlockTerminationPoint> GetBlockTerminationPoints(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            var loopReach = LoopBody.UpdateReach(Reach, Chain);

            var results = new List<BlockTerminationPoint>();
            results.Add(new BlockTerminationPoint(loopReach, LoopPostInsert));
            results.AddRange(LoopBody.GetTerminationPoints(Chain, Tag));

            return FilterUnchanged(Reach, results);
        }

        private const List<BlockTerminationPoint> FilterUnchanged(VariableDefinitionReach Reach, [BlockTerminationPoint] Points)
        {
            var results = new List<BlockTerminationPoint>();
            foreach (var item in Points)
                if (item.Reach != Reach)
            {
                results.Add(item);
            }
            return results;
        }

        private const HashSet<VariableDefinitionReach> GetReaches([BlockTerminationPoint] Points)
        {
            var results = new HashSet<VariableDefinitionReach>();
            foreach (var item in Points)
            {
                results.Add(item.Reach);
            }
            return results;
        }

        public VariableDefinitionReach UpdateReach(VariableDefinitionReach Reach, VariableDefinitionChain Chain)
        {
            // Get old definition accesses, which are not part of this loop.
            var oldAccess = new HashSet<IDefinitionAccess>(Reach.Reach);

            var termPoints = GetBlockTerminationPoints(Reach, Chain);

            if (termPoints.Count == 0)
                return Reach; // Nothing has changed.

            // We know for sure that some definition has changed now, because
            // of the guarded return statement. We'll have to create
            // phi statements.

            // Gets all definition accesses of the original reach which are
            // part of this loop.
            var newAccess = new HashSet<IDefinitionAccess>(Reach.Reach);
            newAccess.ExceptWith(oldAccess);

            // Get all variable reaches.
            var allReaches = GetReaches(termPoints);
            allReaches.Add(Reach); // Throw in the original reach, too.

            // Create a phi def and reach.
            var phiDef = new LocalVariableDefinition(
                VariableFlowHelpers.CreatePhiLocal(Reach.MappedLocal, allReaches));
            var phiReach = new VariableDefinitionReach(phiDef, Reach.MappedLocal);

            VariableDefinitionReach matReach;
            if (newAccess.Count > 0)
            {
                // Materialize and transfer access.
                matReach = VariableFlowHelpers.Materialize(Chain, Reach, PreInsert);
                Reach.Transfer(phiReach, newAccess);
            }
            else
            {
                matReach = Reach;
            }

            // Transfer all definitions to the phi definition.
            VariableFlowHelpers.Transfer(Chain, matReach, phiReach, PreInsert);
            foreach (var item in termPoints)
            {
                VariableFlowHelpers.Transfer(Chain, item.Reach, phiReach, item.PreInsert);
            }

            return phiReach;
        }
    }
}
