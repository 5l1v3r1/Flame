using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Visitors;

namespace Flame.Optimization.Variables
{
    public class AccessSelectFlow
    {
        public const this(set AccessMetrics(IVariableDefinition, bool) First,
                          set AccessMetrics(IVariableDefinition, bool) Second);

        public AccessMetrics(IVariableDefinition, bool) First { const get; private set; }
        public AccessMetrics(IVariableDefinition, bool) Second { const get; private set; }

        public const AccessMetrics GetAccess(IVariableDefinition Def, bool IsDefined)
        {
            var fstAccess = First(Def, IsDefined);
            var sndAccess = Second(Def, IsDefined);

            return new AccessMetrics(fstAccess.MinAccess.Min(sndAccess.MinAccess),
                                     fstAccess.MaxAccess.Max(sndAccess.MaxAccess),
                                     fstAccess.IsDefined && sndAccess.IsDefined);
        }
    }

    public class FlattenedAccessFlow
    {
        public const this(set List<AccessMetrics(IVariableDefinition, bool)> Values);

        public List<AccessMetrics(IVariableDefinition, bool)> Values { const get; private set; }

        public const AccessMetrics GetAccess(IVariableDefinition Def, bool IsDefined)
        {
            var result = new AccessMetrics(IsDefined);
            foreach (var item in Values)
            {
                var access = item(Def, result.IsDefined);
                result = new AccessMetrics(result.MinAccess.Add(access.MinAccess),
                                           result.MaxAccess.Add(access.MaxAccess),
                                           access.IsDefined);
            }
            return result;
        }
    }

    public class AccessLoopFlow
    {
        public const this(set AccessMetrics(IVariableDefinition, bool) Body);

        public AccessMetrics(IVariableDefinition, bool) Body { const get; private set; }

        public const AccessMetrics GetAccess(IVariableDefinition Def, bool IsDefined)
        {
            var bodyAccess = Body(Def, IsDefined);

            if (!IsDefined)
                return bodyAccess;
            else
                return new AccessMetrics(new AccessCount(0),
                                         bodyAccess.MaxAccess.Multiply(AccessCount.Infinity),
                                         true);
        }
    }

    public class AccessLoadFlow
    {
        public const this(set IDefinitionAccessNode Node);

        public IDefinitionAccessNode Node { const get; private set; }

        public const AccessMetrics GetAccess(IVariableDefinition Def, bool IsDefined)
        {
            if (!IsDefined)
                return new AccessMetrics();

            var accessDef = Node.Chain.GetDefinition(Node.Access);

            if (accessDef == Def)
                return new AccessMetrics(new AccessCount(1), true);
            else
                return new AccessMetrics(true);
        }
    }

    public class AccessDefinitionFlow
    {
        public const this(set IVariableDefinition Definition);

        public IVariableDefinition Definition { const get; private set; }

        public const AccessMetrics GetAccess(IVariableDefinition Def, bool IsDefined)
        {
            return new AccessMetrics(Def == Definition || IsDefined);
        }
    }

    public class AccessVisitor : INodeVisitor,
        IFlowVisitor<List<Func<IVariableDefinition, bool, AccessMetrics>>,
                     List<Func<IVariableDefinition, bool, AccessMetrics>>>
    {
        alias StateItem = Func<IVariableDefinition, bool, AccessMetrics>;
        alias State = List<StateItem>;
        alias Delta = State;

        public const this()
        {
            CurrentFlow = new State();
        }

        private const State AppendFlow(State Source, StateItem Item)
        {
            var result = new State(Source);
            result.Add(Item);
            return result;
        }

        private const State ConcatFlow(State First, State Second)
        {
            var result = new State(First);
            result.AddRange(Second);
            return result;
        }

        private const State SliceFlow(State First, State Second)
        {
            return new State(Enumerable.Skip<StateItem>(Second, First.Count));
        }

        private const StateItem FlattenFlow(State Flow)
        {
            return new FlattenedAccessFlow(Flow).GetAccess;
        }

        public State CurrentFlow { const get; set; }
        public StateItem FlattenedFlow { const get return FlattenFlow(CurrentFlow); }

        public Delta TerminatedFlow { const get return new State(); }

        /// <summary>
        /// Computes the "sum" of a flow state and a control flow delta.
        /// </summary>
        public const State CreateCollapsedFlow(State First, Delta Second)
        {
            return ConcatFlow(First, Second);
        }

        /// <summary>
        /// Computes the "difference" between two flow states, such that
        /// the "sum" of the first flow state and the result of this operation
        /// results in the second state.
        /// </summary>
        public const Delta CreateDeltaFlow(State First, State Second)
        {
            return SliceFlow(First, Second);
        }

        /// <summary>
        /// Creates a flow delta that represents the sequential execution of
        /// two flow deltas.
        /// </summary>
        public const Delta CreateSequenceFlow(Delta First, Delta Second)
        {
            return ConcatFlow(First, Second);
        }

        /// <summary>
        /// Creates a flow delta that represents selecting precisely one of two
        /// flow deltas.
        /// </summary>
        public const Delta CreateSelectFlow(Delta First, Delta Second)
        {
            var result = new State();
            result.Add(new AccessSelectFlow(FlattenFlow(First), FlattenFlow(Second)).GetAccess);
            return result;
        }

        /// <summary>
        /// Creates a flow delta that will be executed zero or more
        /// times.
        /// </summary>
        public const Delta CreateLoopFlow(UniqueTag Tag, Delta Flow)
        {
            var result = new State();
            result.Add(new AccessLoopFlow(FlattenFlow(Flow)).GetAccess);
            return result;
        }

        /// <summary>
        /// "Visits" an expression: an expression is taken as input and transformed into another expression.
        /// </summary>
        public IExpression Visit(IExpression Value)
        {
            if (Value is IDefinitionAccessNode)
            {
                var defAccess = (IDefinitionAccessNode)Value;
                CurrentFlow = AppendFlow(CurrentFlow, new AccessLoadFlow(defAccess).GetAccess);
            }

            if (Value is IFlowExpression)
            {
                return ((IFlowExpression)Value).AcceptFlow<State, Delta>(this);
            }
            else if (Value is IPredicateNode)
            {
                ((IPredicateNode)Value).AcceptPredicate(this);
                return Value;
            }
            else
            {
                return Value.Accept(this);
            }
        }

        /// <summary>
        /// "Visits" a statement: an statement is taken as input and transformed into another statement.
        /// </summary>
        public IStatement Visit(IStatement Value)
        {
            if (Value is IDefinitionAccessNode)
            {
                var defAccess = (IDefinitionAccessNode)Value;
                CurrentFlow = AppendFlow(CurrentFlow, new AccessLoadFlow(defAccess).GetAccess);
            }
            else if (Value is IVariableDefinitionStatement)
            {
                var defStmt = (IVariableDefinitionStatement)Value;
                CurrentFlow = AppendFlow(CurrentFlow, new AccessDefinitionFlow(defStmt.Definition.Definition).GetAccess);
            }

            if (Value is IFlowStatement)
            {
                return ((IFlowStatement)Value).AcceptFlow<State, Delta>(this);
            }
            else if (Value is IPredicateNode)
            {
                ((IPredicateNode)Value).AcceptPredicate(this);
                return Value;
            }
            else
            {
                return Value.Accept(this);
            }
        }
    }
}
