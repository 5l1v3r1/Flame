using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;

namespace Flame.Optimization.Variables
{
    /// <summary>
    /// A variable definition that propagates an expression provided that none of
    /// its dependencies have changed, and that the definition is propagated exactly
    /// once.
    /// </summary>
    public class DependentVariableDefinition : IVariableDefinition
    {
        /// <summary>
        /// Creates a new dependent variable definition from the given arguments.
        /// </summary>
        public const this(set VariableDefinitionChain TargetChain,
                          set PropagationDependencies Dependencies,
                          set IExpression Value,
                          set InsertStatement InsertPoint);

        public VariableDefinitionChain TargetChain { const get; private set; }
        public PropagationDependencies Dependencies { const get; private set; }
        public IExpression Value { const get; private set; }
        public InsertStatement InsertPoint { const get; private set; }

        /// <summary>
        /// Gets this variable definition's underlying variable.
        /// </summary>
        public IUnmanagedVariable Variable { const get return null; }

        private VariableDefinitionReach matReach;
        private HashSet<IDefinitionAccess> matAccess;
        public bool HasMaterialized { const get return matReach != null; }

        public VariableDefinitionReach Materialize(VariableDefinitionReach Reach)
        {
            var allAccess = new HashSet<IDefinitionAccess>(Reach.Reach);
            if (!HasMaterialized)
            {
                matReach = VariableFlowHelpers.Materialize(TargetChain, Reach, InsertPoint);
                matAccess = new HashSet<IDefinitionAccess>(Reach.Reach);
                matAccess.ExceptWith(allAccess);
            }
            else
            {
                allAccess.ExceptWith(matAccess);
            }
            Reach.Transfer(matReach, allAccess);
            return matReach;
        }

        /// <summary>
        /// Creates a get-expression for this dependent variable definition.
        /// </summary>
        public IExpression CreateGetExpression()
        {
            return Value;
        }

        /// <summary>
        /// Has this variable definition "react" to definition access metrics.
        /// </summary>
        public VariableDefinitionReach UseMetrics(VariableDefinitionReach ReactingReach,
                                                  AccessMetrics Bounds)
        {
            if (Dependencies.ShouldMaterialize(Bounds.MaxAccess))
            {
                return Materialize(ReactingReach);
            }
            else
            {
                return ReactingReach;
            }
        }

        /// <summary>
        /// Has this variable definition "react" to a change in another definition's chain:
        /// it gets an opportunity to use the other variable's previous value.
        /// Either this variable definition reach or a newly created one is then returned.
        /// </summary>
        public VariableDefinitionReach ReactTo(VariableDefinitionReach ReactingReach,
                                               VariableDefinitionReach ActingDefinition,
                                               InsertStatement PreInsert)
        {
            // Check that the acting chain is the target chain.
            // We know that this definition is live, because that's kind of
            // a precondition.
            if (Dependencies.DependsOn(ActingDefinition.MappedLocal))
            {
                return Materialize(ReactingReach);
            }
            else
            {
                // No need to take action.
                return ReactingReach;
            }
        }
    }
}
