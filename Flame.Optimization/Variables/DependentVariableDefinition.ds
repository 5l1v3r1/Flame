using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;

namespace Flame.Optimization.Variables
{
    /// <summary>
    /// A variable definition that propagates an expression provided that none of
    /// its dependencies have changed, and that the definition is propagated exactly
    /// once.
    /// </summary>
    public class DependentVariableDefinition : IVariableDefinition
    {
        /// <summary>
        /// Creates a new dependent variable definition from the given arguments.
        /// </summary>
        public const this(set VariableDefinitionChain TargetChain,
                          [LocalVariableDescription] Dependencies,
                          set IExpression Value,
                          set InsertStatement InsertPoint)
        {
            this.depends = new HashSet<LocalVariableDescription>(Dependencies);
        }

        private HashSet<LocalVariableDescription> depends;

        public VariableDefinitionChain TargetChain { const get; private set; }
        public [LocalVariableDescription] Dependencies { const get return depends; }
        public IExpression Value { const get; private set; }
        public InsertStatement InsertPoint { const get; private set; }

        /// <summary>
        /// Gets this variable definition's underlying variable.
        /// </summary>
        public IUnmanagedVariable Variable { const get; private set; }

        public bool HasMaterialized { const get return Variable != null; }

        public VariableDefinitionReach Materialize(VariableDefinitionReach Reach)
        {
            var matReach = VariableFlowHelpers.Materialize(TargetChain, Reach, InsertPoint);
            Reach.Transfer(matReach, Reach.Reach);
            return matReach;
        }

        /// <summary>
        /// Creates a get-expression for this copy variable definition.
        /// </summary>
        public IExpression CreateGetExpression()
        {
            return Value;
        }

        /// <summary>
        /// Has this variable definition "react" to definition access metrics.
        /// </summary>
        public VariableDefinitionReach UseMetrics(VariableDefinitionReach ReactingReach,
                                                  AccessBounds Bounds)
        {
            if (Bounds.MaxAccess.IsGreaterThanOrEquals(new AccessCount(2)))
            {
                return Materialize(ReactingReach);
            }
            else
            {
                return ReactingReach;
            }
        }

        /// <summary>
        /// Has this variable definition "react" to a change in another definition's chain:
        /// it gets an opportunity to use the other variable's previous value.
        /// Either this variable definition reach or a newly created one is then returned.
        /// </summary>
        public VariableDefinitionReach ReactTo(VariableDefinitionReach ReactingReach,
                                               VariableDefinitionReach ActingDefinition,
                                               InsertStatement PreInsert)
        {
            // Check that the acting chain is the target chain.
            // We know that this definition is live, because that's kind of
            // a precondition.
            if (depends.Contains(ActingDefinition.MappedLocal))
            {
                return Materialize(ReactingReach);
            }
            else
            {
                // No need to take action.
                return ReactingReach;
            }
        }
    }
}
