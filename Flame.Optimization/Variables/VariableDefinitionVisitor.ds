using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Variables;
using Flame.Compiler.Visitors;
using Flame.Compiler.Statements;

namespace Flame.Optimization.Variables
{
    public class VariableConcatStateBuilder
    {
        public const this(set VariableFlowState Delta);

        public VariableFlowState Delta { const get; private set; }

        public const VariableFlowState Create(VariableFlowState Tail)
        {
            return Tail.Concat(Delta);
        }
    }

    public class VariableSequenceStateBuilder
    {
        public const this(set VariableFlowState(VariableFlowState) First,
                          set VariableFlowState(VariableFlowState) Second);

        public VariableFlowState(VariableFlowState) First { const get; private set; }
        public VariableFlowState(VariableFlowState) Second { const get; private set; }

        public const VariableFlowState Create(VariableFlowState Tail)
        {
            return Second(First(Tail));
        }
    }

    public class VariableSelectStateBuilder
    {
        public const this(set VariableFlowState(VariableFlowState) First,
                          set VariableFlowState(VariableFlowState) Second);

        public VariableFlowState(VariableFlowState) First { const get; private set; }
        public VariableFlowState(VariableFlowState) Second { const get; private set; }

        public const VariableFlowState Create(VariableFlowState Tail)
        {
            var nil = new NilVariableFlowState(Tail.PostInsert);

            return Tail.Select(First(nil), Second(nil));
        }
    }

    public class VariableLoopStateBuilder
    {
        public const this(set BlockTag Tag, set VariableFlowState(VariableFlowState) Body);

        public BlockTag Tag { const get; private set; }
        public VariableFlowState(VariableFlowState) Body { const get; private set; }

        public const VariableFlowState Create(VariableFlowState Tail)
        {
            var nil = new NilVariableFlowState(Tail.PostInsert);

            return Tail.Loop(Tag, Body(nil));
        }
    }

    public class TerminatedLocalFlowBuilder
    {
        public const this(set BlockTag Tag);

        public BlockTag Tag { const get; private set; }

        public const VariableFlowState Create(VariableFlowState Tail)
        {
            return Tail.Cons(new VariableFlowNode(
                new TerminatedBlockVariableFlow(Tail.PostInsert, Tag), Tail.PostInsert));
        }
    }

    public class VariableDefinitionVisitor : NodeVisitorBase, ILocalFlowVisitor<VariableFlowState, VariableFlowState(VariableFlowState)>
    {
        alias State = VariableFlowState;
        alias Delta = VariableFlowState(VariableFlowState);

        /// <summary>
        /// Creates a new final flow remover from the given enclosing flow
        /// and a function that matches final flow.
        /// </summary>
        public const this()
        {
            this.CurrentFlow = null;
            this.mappedLocals = new Dictionary<LocalVariableDescription, VariableDefinitionChain>();
            this.propTypes = new Dictionary<IType, bool>();
        }

        private Dictionary<LocalVariableDescription, VariableDefinitionChain> mappedLocals;
        private Dictionary<IType, bool> propTypes;

        public [VariableDefinitionChain] DefinitionChains { const get return mappedLocals.Values; }

        private VariableDefinitionChain MapLocal(LocalVariableDescription Description)
        {
            if (mappedLocals.ContainsKey(Description))
            {
                return mappedLocals[Description];
            }
            else
            {
                var chain = new VariableDefinitionChain(Description);
                mappedLocals[Description] = chain;
                return chain;
            }
        }

        private VariableDefinitionChain MapLocal(IVariable Variable)
        {
            var desc = new LocalVariableDescription(Variable);
            return MapLocal(desc);
        }

        private const bool IsLocal(IVariable Variable)
        {
            return Variable is ThisVariable || Variable is ArgumentVariable ||
                   (Variable is LateBoundVariable && !(Variable is ManuallyBoundVariable));
        }

        /// <summary>
        /// Identity helper function. For use as a delegate.
        /// </summary>
        private const T Id<T>(T Value)
        {
            return Value;
        }

        private const State CreateTerminatedFlow(State Tail)
        {
            return Tail.Cons(new VariableFlowNode(
                new TerminatedVariableFlow(Tail.PostInsert), Tail.PostInsert));
        }

        /// <summary>
        /// Checks if the given type is a propagate-always type, which can
        /// safely be propagated anywhere.
        /// </summary>
        private bool IsPropagateAlwaysTypeCore(IType Type)
        {
            if (Type.IsPrimitive || Type.IsDelegate)
            {
                return true;
            }
            else if (Type.IsValueType)
            {
                foreach (var item in Type.GetFields())
                    if (!IsPropagateAlwaysType(item.FieldType))
                {
                    return false;
                }
                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// Checks if the given type is a propagate-always type, which can
        /// safely be propagated anywhere.
        /// </summary>
        public bool IsPropagateAlwaysType(IType Type)
        {
            if (propTypes.ContainsKey(Type))
            {
                return propTypes[Type];
            }
            else
            {
                bool result = IsPropagateAlwaysTypeCore(Type);
                propTypes[Type] = result;
                return result;
            }
        }

        /// <summary>
        /// Gets or sets the current flow state.
        /// </summary>
        public State CurrentFlow { const get; set; }

        /// <summary>
        /// Gets a flow delta that represents flow termination:
        /// sequential flow that succeeds it will never be executed.
        /// </summary>
        /// <remarks>
        /// Terminated flow basically materializes everything.
        /// </remarks>
        public Delta TerminatedFlow { const get return CreateTerminatedFlow; }

        /// <summary>
        /// Gets a flow delta that represents global flow termination:
        /// this signifies the end of this function call.
        /// </summary>
        /// <remarks>
        /// This really just does nothing at all, because we really don't
        /// care about what happens after this.
        /// </remarks>
        public Delta TerminatedGlobalFlow { const get return Id<State>; }

        /// <summary>
        /// Computes the "sum" of a flow state and a control flow delta.
        /// </summary>
        public const State CreateCollapsedFlow(State First, Delta Second)
        {
            return Second(First);
        }

        /// <summary>
        /// Computes the "difference" between two flow states, such that
        /// the "sum" of the first flow state and the result of this operation
        /// results in the second state.
        /// </summary>
        public const Delta CreateDeltaFlow(State First, State Second)
        {
            return new VariableConcatStateBuilder(First.Delta(Second)).Create;
        }

        /// <summary>
        /// Creates a flow delta that represents the sequential execution of
        /// two flow deltas.
        /// </summary>
        public const Delta CreateSequenceFlow(Delta First, Delta Second)
        {
            return new VariableSequenceStateBuilder(First, Second).Create;
        }

        /// <summary>
        /// Creates a flow delta that represents selecting precisely one of two
        /// flow deltas.
        /// </summary>
        public const Delta CreateSelectFlow(Delta First, Delta Second)
        {
            return new VariableSelectStateBuilder(First, Second).Create;
        }

        /// <summary>
        /// Creates a flow delta that will be executed zero or more
        /// times.
        /// </summary>
        public const Delta CreateLoopFlow(BlockTag Tag, Delta Flow)
        {
            return new VariableLoopStateBuilder(Tag, Flow).Create;
        }

        public const Delta CreateTerminatedLocalFlow(BlockTag Tag)
        {
            return new TerminatedLocalFlowBuilder(Tag).Create;
        }

        public override const bool Matches(IExpression Value)
        {
            return Value is IVariableNode || Value is IFlowExpression ||
                   Value is LoadDefinitionExpression || Value is AddressOfDefinitionExpression;
        }
        public override const bool Matches(IStatement Value)
        {
            return Value is IVariableNode || Value is IFlowStatement;
        }

        private IVariable GetInnerVariable(IVariable Variable)
        {
            if (Variable is LateBoundVariable)
            {
                var innerVar = ((LateBoundVariable)Variable).BoundVariable;
                if (innerVar != null)
                    return GetInnerVariable(innerVar);
            }
            return Variable;
        }

        private IStatement VisitFlowStmt(IStatement Statement)
        {
            if (Statement is IFlowStatement)
            {
                return ((IFlowStatement)Statement).AcceptFlow<State, Delta>(this);
            }
            else
            {
                return Statement.Accept(this);
            }
        }

        private IExpression VisitFlowExpr(IExpression Expression)
        {
            if (Expression is IFlowExpression)
            {
                return ((IFlowExpression)Expression).AcceptFlow<State, Delta>(this);
            }
            else
            {
                return Expression.Accept(this);
            }
        }

        private IExpression WrapAccessExpression(IExpression Expr, VariableDefinitionChain Chain, IDefinitionAccess Access)
        {
            var insertPoint = new InsertStatement();
            var flow        = new VariableAccessFlow(Chain, Access);
            CurrentFlow     = CurrentFlow.Cons(new VariableFlowNode(flow, insertPoint));
            return new InitializedExpression(EmptyStatement, Expr, insertPoint);
        }

        private IExpression TransformVariableAccess(IExpression Expression)
        {
            var node = (IVariableNode)Expression;
            var variable = GetInnerVariable(node.GetVariable());

            if (IsLocal(variable))
            {
                var chain = MapLocal(variable);
                if (node.Action == VariableNodeAction.AddressOf)
                {
                    return Visit(new AddressOfDefinitionExpression(chain));
                }
                else if (node.Action == VariableNodeAction.Get)
                {
                    return Visit(new LoadDefinitionExpression(chain));
                }
            }
            return VisitFlowExpr(Expression);
        }

        private bool IsLiteralValue(IExpression Value)
        {
            return Value.IsConstant && IsPropagateAlwaysType(Value.Type) && Value.Evaluate() != null;
        }

        private IVariable GetCopiedVariable(IExpression Value)
        {
            if (Value is IVariableNode)
            {
                var node = (IVariableNode)Value;
                if (node.Action == VariableNodeAction.Get)
                {
                    var variable = node.GetVariable();
                    if (IsLocal(variable))
                        return variable;
                }
            }
            return null;
        }

        /// <summary>
        /// Extracts propagation dependencies from this value.
        /// </summary>
        private PropagationDependencies GetDependencies(IExpression Value)
        {
            if (Value == null || IsLiteralValue(Value))
            {
                return PropagationDependencies.Always();
            }
            else if (Value is UnaryOperatorExpression)
            {
                var opExpr = (UnaryOperatorExpression)Value;
                if (opExpr.OperatorOverload == null || opExpr.OperatorOverload.IsConstant)
                    return GetDependencies(opExpr.Value).Union(PropagationDependencies.Once());
                else
                    return PropagationDependencies.Never();
            }
            else if (Value is BinaryOperatorExpression)
            {
                var opExpr = (BinaryOperatorExpression)Value;
                if (opExpr.OperatorOverload == null || opExpr.OperatorOverload.IsConstant)
                    return GetDependencies(opExpr.LeftOperand).Union(
                           GetDependencies(opExpr.RightOperand)).Union(PropagationDependencies.Once());
                else
                    return PropagationDependencies.Never();
            }
            else if (Value is ConversionExpression)
            {
                return GetDependencies(((ConversionExpression)Value).Value);
            }
            else if (Value is GetMethodExpression)
            {
                var getMethodExpr = (GetMethodExpression)Value;
                return GetDependencies(getMethodExpr.Caller);
            }
            else if (Value is InvocationExpression)
            {
                var callExpr = (InvocationExpression)Value;
                if (!callExpr.Method.IsConstant)
                    return PropagationDependencies.Never();
                var callDepends = GetDependencies(callExpr.Target);
                foreach (var arg in callExpr.Arguments)
                {
                    if (callDepends.Mode == PropagationMode.Never)
                        return PropagationDependencies.Never();
                    callDepends = callDepends.Union(GetDependencies(arg));
                }
                return callDepends.Union(PropagationDependencies.Once());
            }
            else if (Value is FieldGetExpression)
            {
                var fieldExpr = (FieldGetExpression)Value;
                return GetDependencies(fieldExpr.Target).Union(PropagationDependencies.Once());
            }
            else if (Value is InitializedExpression)
            {
                var initExpr = (InitializedExpression)Value;
                if (initExpr.Initialization.IsEmpty && initExpr.Finalization.IsEmpty)
                    return GetDependencies(initExpr.Value);
                else
                    return PropagationDependencies.Never();
            }
            else
            {
                var copiedVar = GetCopiedVariable(Value);
                if (copiedVar == null)
                    return PropagationDependencies.Never();
                else
                    return PropagationDependencies.Always(new LocalVariableDescription(copiedVar));
            }
        }

        private IExpression HoistInitialization(IExpression Value, InsertStatement InsertPoint)
        {
            if (Value is InitializedExpression)
            {
                var initExpr = (InitializedExpression)Value;
                if (initExpr.Finalization.IsEmpty)
                {
                    InsertPoint.Insert(Visit(initExpr.Initialization));
                    return HoistInitialization(initExpr.Value, InsertPoint);
                }
            }
            return Value;
        }

        private VariableDefinitionReach CreateDefinition(VariableDefinitionChain Chain,
            IExpression Value, InsertStatement InsertPoint)
        {
            if (IsLiteralValue(Value)) // Propagate constants.
            {
                return new VariableDefinitionReach(
                    new ConstantVariableDefinition(Visit(Value)),
                    Chain.MappedLocal);
            }
            else
            {
                var copyVar = GetCopiedVariable(Value);
                if (copyVar != null) // Propagate copies.
                {
                    var copiedChain = MapLocal(copyVar);
                    var access      = new UnconditionalAccess();
                    var getExpr     = Visit(new LoadDefinitionExpression(copiedChain, access));
                    return new VariableDefinitionReach(
                        new CopyVariableDefinition(Chain, copiedChain, getExpr),
                        Chain.MappedLocal);
                }

                var depends = GetDependencies(Value);
                if (depends.Mode != PropagationMode.Never)
                {
                    return new VariableDefinitionReach(
                        new DependentVariableDefinition(Chain, depends, Visit(Value), InsertPoint),
                        Chain.MappedLocal);
                }
                else // Don't propagate anything else.
                {
                    var local    = Chain.MappedLocal;
                    var defin    = new LocalVariableDefinition(VariableFlowHelpers.CreateLocal(local));
                    var reach    = new VariableDefinitionReach(defin, local);
                    InsertPoint.Insert(new VariableDefinitionStatement(reach, Visit(Value)));
                    return reach;
                }
            }
        }

        private IStatement TransformVariableAccess(IStatement Statement)
        {
            var node = (IVariableNode)Statement;
            var variable = GetInnerVariable(node.GetVariable());

            if (IsLocal(variable))
            {
                var chain = MapLocal(variable);
                if (node.Action == VariableNodeAction.Set)
                {
                    var insertPoint = new InsertStatement();
                    var preInsrt    = EmitInsertionPoint();
                    insertPoint.Insert(preInsrt);
                    var defVal      = HoistInitialization(((ISetVariableNode)node).Value, preInsrt);
                    var varDef      = CreateDefinition(chain, defVal, insertPoint);
                    insertPoint.Insert(new VariableDefinitionMarker(varDef));
                    var defFlow     = new VariableDefinitionFlow(preInsrt, varDef);
                    CurrentFlow     = CurrentFlow.Cons(new VariableFlowNode(defFlow, insertPoint));
                    return insertPoint;
                }
                else if (node.Action == VariableNodeAction.Release)
                {
                    return new ReleaseDefinitionStatement(chain);
                }
            }
            return VisitFlowStmt(Statement);
        }

        private InsertStatement EmitInsertionPoint()
        {
            var point = new InsertStatement();
            if (CurrentFlow == null)
            {
                CurrentFlow = new NilVariableFlowState(point);
            }
            else
            {
                CurrentFlow = CurrentFlow.Cons(new VariableFlowNode(EmptyVariableFlow, point));
            }
            return point;
        }

        private IExpression TransformCore(IExpression Expression)
        {
            if (Expression is IVariableNode)
                return TransformVariableAccess(Expression);
            else
                return VisitFlowExpr(Expression);
        }

        protected override IExpression Transform(IExpression Expression)
        {
            if (Expression is LoadDefinitionExpression)
            {
                var expr = (LoadDefinitionExpression)Expression;
                return WrapAccessExpression(expr, expr.Chain, expr.Access);
            }
            else if (Expression is AddressOfDefinitionExpression)
            {
                var expr = (AddressOfDefinitionExpression)Expression;
                return WrapAccessExpression(expr, expr.Chain, expr.Access);
            }
            else
            {
                var prePt = EmitInsertionPoint();
                var result = TransformCore(Expression);
                var postPt = EmitInsertionPoint();
                return new InitializedExpression(prePt, result, postPt);
            }
        }

        private IStatement TransformCore(IStatement Statement)
        {
            if (Statement is IVariableNode)
                return TransformVariableAccess(Statement);
            else
                return VisitFlowStmt(Statement);
        }

        protected override IStatement Transform(IStatement Statement)
        {
            var prePt  = EmitInsertionPoint();
            var result = TransformCore(Statement);
            var postPt = EmitInsertionPoint();
            return new BlockStatement(new IStatement[] { prePt, result, postPt });
        }
    }
}
