# Flame

Flame is a collection of C# libraries for building tools that read, analyze, optimize and write managed languages. Things you can build with Flame include optimizing compilers, IL optimizers, static analyzers and more.

Key features include:
  * **An intermediate representation (IR) in static single assignment (SSA) form.** This type of IR is favored by state-of-the-art optimizing compilers such as LLVM and GCC. Flame IR is designed from the ground up with the express intent of making it as suitable as possible for a wide range of optimizations and analyses.
  * **A wealth of optimization passes that operate on Flame IR.** These passes include aggressive optimizations such as inlining, partial scalar replacement of aggregates, global value numbering, LINQ optimization, tail call optimization and [many others](http://jonathanvdc.github.io/Flame/api/Flame.Compiler.Transforms.html).
  * **A variety of IR analyses.** These analyses extract information not explicitly encoded in Flame IR. For example, there are analyses that compute dominator trees, value numbering, block predecessor information, value nullability and [more](http://jonathanvdc.github.io/Flame/api/Flame.Compiler.Analysis.html).
  * **A pluggable architecture.** Flame conveniently includes many built-in transforms and analyses, but sometimes these generic algorithms don't quite cover your use case exactly. In that case, you can easily implement your own transform or analysis.
  * **A CIL front-end and back-end.** Flame can translate CIL to Flame IR and vice-versa, allowing you to easily read and/or write CIL while operating at the optimization and analysis&ndash;focused abstraction layer afforded by Flame IR.

For an introduction to Flame's main concepts see [A brief introduction to Flame](https://jonathanvdc.github.io/Flame/articles/intro.html).

## Subprojects

At its core, Flame is a set of libraries designed to support tools that read, analyze, optimize and write managed languages. Additionally, Flame includes a number of projects that use Flame in a fairly straightforward way.

### `ilopt`

`ilopt` is an ahead-of-time optimizer for CIL assemblies, that is, `ilopt` is a fairly simple command-line tool that reads CIL assemblies, optimizes them and writes the optimized version back to disk.

`ilopt` currently understands most if not all of the CIL opcodes generated by the C# compiler. Other opcodes may not be supported yet. For an overview of single-file C# programs that `ilopt` can definitely optimize, take a look at the [`ilopt` test programs](https://github.com/jonathanvdc/Flame/tree/master/tool-tests/ILOpt).

## Build instructions

Flame is a C# project that targets .NET 4.5 implementations, like Mono and the .NET framework. .NET Core is not supported yet because Flame relies on NuGet packages that don't yet support .NET Core.

Additionally, Flame uses [EC#](http://ecsharp.net/) macros to convert Flame IR rewrite rule DSL to C# code.

### Linux, Mac OS X

Building Flame is easy if you're on Linux or Mac OS X. Just spell
```console
$ make nuget
$ make
```

That's it. The above will grab NuGet dependencies, compile EC# macros down to regular C# and build the project.

To run the unit tests, type
```console
$ make test
```

### Windows

Building Flame is somewhat more challenging on Windows. If at all possible, use a GNU Make implementation to run the Makefile, same as for Linux and Mac OS X.

Otherwise, you will need to do the following:

  1. Restore NuGet packages (`nuget restore`).
  2. Build the macros. (`msbuild /p:Configuration=Release FlameMacros/FlameMacros.csproj`).
  3. Compile EC# macros down to regular C# (`make dsl` in the Makefile, otherwise `FlameMacros/bin/Release/LeMP.exe --macros FlameMacros/bin/Release/FlameMacros.dll --outext=.out.cs file.ecs` for all `.ecs` files).
  4. Build Flame itself (`msbuild /p:Configuration=Release Flame.sln`).

Run the unit tests by spelling
```console
UnitTests\bin\Release\UnitTests.exe all
```

Windows workflow enhancements welcome!
