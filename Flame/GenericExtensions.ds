using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame
{
	public static class GenericExtensions
	{
		#region IsGenericParameter

		/// <summary>
		/// Gets a boolean value that indicates if the given type is a generic parameter.
		/// </summary>
		/// <param name="Type"></param>
		/// <returns></returns>
		public static bool IsGenericParameter[this IType Type]
		{
			const get
			{
				if (Type is IGenericParameter)
				{
					var genericParam = (IGenericParameter)Type;
					return genericParam.DeclaringMember != null;
				}
				else
				{
					return false;
				}
			}
		}

		#endregion

		#region Predicates

		/// <summary>
		/// Tests if the given (potentially) generic member has any
		/// generic parameters.
		/// </summary>
		public static bool IsGeneric[this IGenericMember Member]
		{
			const get { return Enumerable.Any<IGenericParameter>(Member.GenericParameters); }
		}

		/// <summary>
		/// Finds out if this generic member is a generic declaration, i.e.
		/// not a generic instance.
		/// </summary>
		public static bool IsGenericDeclaration[this IGenericMember Member]
		{
			const get { return !Member.IsGenericInstance; }
		}

		/// <summary>
		/// Determines whether the given member is a generic instance or not.
		/// </summary>
		public static bool IsGenericInstance[this IGenericMember Member]
		{
			const get { return Member is IGenericMemberInstance; }
		}

		/// <summary>
		/// Tells if the given type is a recursive generic instance: a generic instance
		/// or a nested type of a generic instance.
		/// </summary>
		public static bool IsRecursiveGenericInstance[this IType Type]
		{
			const get { return Type is GenericTypeBase; }
		}

		#endregion

		#region GetGenericDeclaration

		/// <summary>
		/// Gets this method's generic declaration if it is a generic instance.
		/// Otherwise, the given method is returned.
		/// </summary>
		public static IMethod GetGenericDeclaration(this IMethod Member)
		{
			if (Member is GenericMethod)
			{
				return ((GenericMethod)Member).Declaration;
			}
			else
			{
				return Member;
			}
		}

		/// <summary>
		/// Gets this type's generic declaration if it is a generic instance.
		/// Otherwise, the given type is returned.
		/// </summary>
		public static IType GetGenericDeclaration(this IType Member)
		{
			if (Member is GenericType)
			{
				return ((GenericType)Member).Declaration;
			}
			else
			{
				return Member;
			}
		}

		#endregion

		#region MakeGeneric

		/// <summary>
		/// Instantiates the given generic type with the given sequence of type
		/// arguments.
		/// </summary>
		public static IType MakeGenericType(this IType GenericDeclaration, [IType] TypeArguments)
		{
			var argArr = Enumerable.ToArray<IType>(TypeArguments);
			int genParamCount = Enumerable.Count<IGenericParameter>(GenericDeclaration.GenericParameters);
			if (argArr.Length != genParamCount)
			{
				throw new InvalidOperationException("Type '" + GenericDeclaration.FullName +
					"' with " + genParamCount + " generic parameters, cannot be instantiated with " +
					argArr.Length + " type arguments.");
			}
			else if (argArr == 0)
			{
				return GenericDeclaration;
			}
			else
			{
				return new GenericType(GenericDeclaration.GetGenericDeclaration(), argArr);
			}
		}

		/// <summary>
		/// Instantiates the given generic method with the given sequence of type
		/// arguments.
		/// </summary>
		public static IMethod MakeGenericMethod(this IMethod GenericDeclaration, [IType] TypeArguments)
		{
			var argArr = Enumerable.ToArray<IType>(TypeArguments);
			int genParamCount = Enumerable.Count<IGenericParameter>(GenericDeclaration.GenericParameters);
			if (argArr.Length != genParamCount)
			{
				throw new InvalidOperationException("Method '" + GenericDeclaration.FullName +
					"' with " + genParamCount + " generic parameters, cannot be instantiated with " +
					argArr.Length + " type arguments.");
			}
			else if (argArr == 0)
			{
				return GenericDeclaration;
			}
			else
			{
				return new GenericMethod(GenericDeclaration.GetGenericDeclaration(), argArr);
			}
		}

		#endregion

		#region GetGenericArguments

		/// <summary>
		/// Gets the generic member's generic arguments if it is a generic instance.
		/// Otherwise, the empty sequence is returned.
		/// </summary>
		public static [IType] GetGenericArguments(this IGenericMember Member)
		{
			if (Member is IGenericMemberInstance)
			{
				return ((IGenericMemberInstance)Member).GenericArguments;
			}
			else
			{
				return Enumerable.Empty<IType>();
			}
		}

		#endregion

		public static const [IGenericParameter] GetRecursiveGenericParameters(this IType Type)
		{
			var typeParams = Type.GenericParameters;
			if (Type.DeclaringNamespace is IType)
			{
				return Enumerable.Concat<IGenericParameter>(((IType)Type.DeclaringNamespace).GetRecursiveGenericParameters(),
						typeParams);
			}
			else
			{
				return typeParams;
			}
		}

		public static const [IType] GetRecursiveGenericArguments(this IType Type)
		{
			var genArgs = Type.GetGenericArguments();
			if (Type.DeclaringNamespace is IType)
			{
				return Enumerable.Concat<IType>(((IType)Type.DeclaringNamespace).GetRecursiveGenericArguments(),
					                            genArgs);
			}
			else
			{
				return genArgs;
			}
		}

		private static const IType GetChildType(INamespace Namespace, IType Type)
		{
			int genParamCount = Enumerable.Count<IGenericParameter>(Type.GenericParameters);
			foreach (var item in Namespace.Types)
				if (item.Name == Type.Name)
				if (Enumerable.Count<IGenericParameter>(item.GenericParameters) == genParamCount)
			{
				return item;
			}
			return null;
		}

		public static const IType GetRecursiveGenericDeclaration(this IType Type)
		{
			if (Type.DeclaringNamespace is IType && ((IType)Type.DeclaringNamespace).IsRecursiveGenericInstance)
			{
				var genDecl = (INamespace)((IType)Type.DeclaringNamespace).GetRecursiveGenericDeclaration();
				return GetChildType(genDecl, Type);
			}
			else if (Type.IsGenericInstance)
			{
				return Type.GetGenericDeclaration();
			}
			else
			{
				return Type;
			}
		}

		public static const IType MakeRecursiveGenericType(this IType Type, [IType] TypeArguments)
		{
			if (Type.DeclaringNamespace is IType)
			{
				var nsType = (IType)Type.DeclaringNamespace;
				if (nsType.IsRecursiveGenericInstance)
				{
					int paramCount = Enumerable.Count<IGenericParameter>(nsType.GetRecursiveGenericParameters());
					var parentArgs = Enumerable.Take<IType>(TypeArguments, paramCount);
					var actualArgs = Enumerable.Skip<IType>(TypeArguments, paramCount);
					var parentType = nsType.MakeRecursiveGenericType(parentArgs);
					var decl = GetChildType((INamespace)nsType, Type);
					if (Enumerable.Any<IType>(actualArgs))
					{
						return decl.MakeGenericType(actualArgs);
					}
					else
					{
						return decl;
					}
				}
			}
			return Type.MakeGenericType(TypeArguments);
		}
	}
}
