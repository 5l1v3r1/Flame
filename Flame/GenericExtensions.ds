using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame
{
	public static class GenericExtensions
	{
		#region IsGenericParameter

		/// <summary>
		/// Gets a boolean value that indicates if the given type is a generic parameter.
		/// </summary>
		/// <param name="Type"></param>
		/// <returns></returns>
		public static bool IsGenericParameter[this IType Type]
		{
			const get
			{
				if (Type is IGenericParameter)
				{
					var genericParam = (IGenericParameter)Type;
					return genericParam.DeclaringMember != null;
				}
				else
				{
					return false;
				}
			}
		}

		#endregion

		#region Predicates

		/// <summary>
		/// Tests if the given (potentially) generic member has any
		/// generic parameters.
		/// </summary>
		public static bool IsGeneric[this IGenericMember Member]
		{
			const get { return Enumerable.Any<IGenericParameter>(Member.GenericParameters); }
		}

		/// <summary>
		/// Finds out if this generic member is a generic declaration, i.e.
		/// not a generic instance.
		/// </summary>
		public static bool IsGenericDeclaration[this IGenericMember Member]
		{
			const get { return !Member.IsGenericInstance; }
		}

		/// <summary>
		/// Determines whether the given member is a generic instance or not.
		/// </summary>
		public static bool IsGenericInstance[this IGenericMember Member]
		{
			const get { return Member is IGenericMemberInstance; }
		}

		/// <summary>
		/// Tells if the given type is a recursive generic instance: a generic instance
		/// or a nested type of a generic instance.
		/// </summary>
		public static bool IsRecursiveGenericInstance[this IType Type]
		{
			const get { return Type is GenericTypeBase; }
		}

		#endregion

		#region GetGenericDeclaration

		/// <summary>
		/// Gets this method's generic declaration if it is a generic instance.
		/// Otherwise, the given method is returned.
		/// </summary>
		public static IMethod GetGenericDeclaration(this IMethod Member)
		{
			if (Member is GenericMethod)
			{
				return ((GenericMethod)Member).Declaration;
			}
			else
			{
				return Member;
			}
		}

		/// <summary>
		/// Gets this type's generic declaration if it is a generic instance.
		/// Otherwise, the given type is returned.
		/// </summary>
		public static IType GetGenericDeclaration(this IType Member)
		{
			if (Member is GenericType)
			{
				return ((GenericType)Member).Declaration;
			}
			else
			{
				return Member;
			}
		}

		#endregion

		#region MakeGeneric

		/// <summary>
		/// Instantiates the given generic type with the given sequence of type
		/// arguments.
		/// </summary>
		public static IType MakeGenericType(this IType GenericDeclaration, [IType] TypeArguments)
		{
			var argArr = Enumerable.ToArray<IType>(TypeArguments);
			int genParamCount = Enumerable.Count<IGenericParameter>(GenericDeclaration.GenericParameters);
			if (argArr.Length != genParamCount)
			{
				throw new InvalidOperationException("Type '" + GenericDeclaration.FullName +
					"' with " + genParamCount + " generic parameters, cannot be instantiated with " +
					argArr.Length + " type arguments.");
			}
			else if (argArr == 0)
			{
				return GenericDeclaration;
			}
			else
			{
				return new GenericType(GenericDeclaration.GetGenericDeclaration(), argArr);
			}
		}

		/// <summary>
		/// Instantiates the given generic method with the given sequence of type
		/// arguments.
		/// </summary>
		public static IMethod MakeGenericMethod(this IMethod GenericDeclaration, [IType] TypeArguments)
		{
			var argArr = Enumerable.ToArray<IType>(TypeArguments);
			int genParamCount = Enumerable.Count<IGenericParameter>(GenericDeclaration.GenericParameters);
			if (argArr.Length != genParamCount)
			{
				throw new InvalidOperationException("Method '" + GenericDeclaration.FullName +
					"' with " + genParamCount + " generic parameters, cannot be instantiated with " +
					argArr.Length + " type arguments.");
			}
			else if (argArr == 0)
			{
				return GenericDeclaration;
			}
			else
			{
				return new GenericMethod(GenericDeclaration.GetGenericDeclaration(), argArr);
			}
		}

		#endregion

		#region GetGenericArguments

		/// <summary>
		/// Gets the generic member's generic arguments if it is a generic instance.
		/// Otherwise, the empty sequence is returned.
		/// </summary>
		public static [IType] GetGenericArguments(this IGenericMember Member)
		{
			if (Member is IGenericMemberInstance)
			{
				return ((IGenericMemberInstance)Member).GenericArguments;
			}
			else
			{
				return Enumerable.Empty<IType>();
			}
		}

		#endregion

		public static const [IGenericParameter] GetRecursiveGenericParameters(this IType Type)
		{
			var typeParams = Type.GenericParameters;
			if (Type.DeclaringNamespace is IType)
			{
				return Enumerable.Concat<IGenericParameter>(
					    ((IType)Type.DeclaringNamespace).GetRecursiveGenericParameters(),
						typeParams);
			}
			else
			{
				return typeParams;
			}
		}

		public static const [IType] GetRecursiveGenericArguments(this IType Type)
		{
			var genArgs = Type.GetGenericArguments();
			if (Type.DeclaringNamespace is IType)
			{
				return Enumerable.Concat<IType>(((IType)Type.DeclaringNamespace).GetRecursiveGenericArguments(),
					                            genArgs);
			}
			else
			{
				return genArgs;
			}
		}

		public static const IType GetRecursiveGenericDeclaration(this IType Type)
		{
			if (Type is GenericTypeBase)
			{
				return ((GenericTypeBase)Type).Declaration.GetRecursiveGenericDeclaration();
			}
			else
			{
				return Type;
			}
		}

		public static const IMethod GetRecursiveGenericDeclaration(this IMethod Method)
		{
			if (Method is GenericMethodBase)
			{
				return ((GenericMethodBase)Method).Declaration.GetRecursiveGenericDeclaration();
			}
			else
			{
				return Method;
			}
		}

		public static const IField GetRecursiveGenericDeclaration(this IField Field)
		{
			if (Field is GenericInstanceField)
			{
				return ((GenericInstanceField)Field).Declaration.GetRecursiveGenericDeclaration();
			}
			else
			{
				return Field;
			}
		}

		public static const IProperty GetRecursiveGenericDeclaration(this IProperty Property)
		{
			if (Property is GenericInstanceProperty)
			{
				return ((GenericInstanceProperty)Property).Declaration.GetRecursiveGenericDeclaration();
			}
			else
			{
				return Property;
			}
		}

		public static const IType MakeRecursiveGenericType(this IType Type, [IType] TypeArguments)
		{
			if (Type.DeclaringNamespace is IType)
			{
				var nsType = (IType)Type.DeclaringNamespace;
				if (nsType.IsRecursiveGenericInstance)
				{
					int paramCount = Enumerable.Count<IGenericParameter>(nsType.GetRecursiveGenericParameters());
					var parentArgs = Enumerable.Take<IType>(TypeArguments, paramCount);
					var actualArgs = Enumerable.Skip<IType>(TypeArguments, paramCount);
					var parentType = nsType.MakeRecursiveGenericType(parentArgs);
					var decl = new GenericInstanceType(Type, ((GenericTypeBase)parentType).Resolver, parentType);
					if (Enumerable.Any<IType>(actualArgs))
					{
						return decl.MakeGenericType(actualArgs);
					}
					else
					{
						return decl;
					}
				}
			}
			return Type.MakeGenericType(TypeArguments);
		}
	}
}
