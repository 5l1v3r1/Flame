using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;

namespace Flame
{
	public class MemoizedFunc<TArg, TResult>
	{
		public const this(set TResult(TArg) func)
		{
			this.cache = new ConcurrentDictionary<TArg, TResult>();
		}

		private TResult(TArg) func;
		private ConcurrentDictionary<TArg, TResult> cache;

		public const bool HasComputed(TArg Arg)
		{
			return cache.ContainsKey(Arg);
		}

		public const TResult Apply(TArg Arg)
		{
			return cache.GetOrAdd(Arg, func);
		}
	}

	public class AncestryGraph
	{
		public const this()
		{
			this.ancestryFunc = new MemoizedFunc<Tuple<IType, IType>, int>(ComputeAncestry);
			this.Operators = new OperatorCache();
		}

		private MemoizedFunc<Tuple<IType, IType>, int> ancestryFunc;
		public OperatorCache Operators { const get; private set; }

		public const int GetAncestryDegree(IType Target, IType Other)
		{
			return ancestryFunc.Apply(new Tuple<IType, IType>(Target, Other));
		}

		public const bool Is(IType Target, IType Other)
		{
			return GetAncestryDegree(Target, Other) >= 0;
		}

		private const int ComputeAncestry(Tuple<IType, IType> Pair)
		{
			var invPair = new Tuple<IType, IType>(Pair.Item2, Pair.Item1);

			if (ancestryFunc.HasComputed(invPair))
			{
				int invAncestry = ancestryFunc.Apply(invPair);
				if (invAncestry == 0)
					return 0;
				else if (invAncestry > 0)
					return -1;
			}

			return ComputeAncestry(Pair.Item1, Pair.Item2);
		}

		private const int ComputeElementAncestry(IType Type, IType Other)
		{
			return GetAncestryDegree(Type.AsContainerType().ElementType,
									 Other.AsContainerType().ElementType);
		}

		private const int ComputeGenericVarianceAncestry(IType Type, IType Other)
		{
			if (Type.IsGenericInstance && Other.IsGenericInstance)
            {
            	if (Type.GetGenericDeclaration().Equals(Other.GetGenericDeclaration()))
            	{
            		int totalAncestry = 0;
	            	foreach (var genParam in Type.GetGenericParameters(),
							 var genArg1 in Type.GetGenericArguments(),
							 var genArg2 in Other.GetGenericArguments())
	            	{
	            		int argAncestry = 0;
	            		if (genParam.IsCovariant) // [int] is [object]
	            		{
	            			argAncestry = GetAncestryDegree(genArg1, genArg2);
	            		}
	            		else if (genParam.IsContravariant) // '(object) => void is (int) => void',
														   // so if 'T is V', '(V) => void is (T) => void'
	            		{
	            			argAncestry = GetAncestryDegree(genArg2, genArg1);
	            		}
	            		else if (!genArg1.Equals(genArg2))
	            		{
	            			return -1;
	            		}

	            		if (argAncestry < 0) return -1;
	            		else totalAncestry += argAncestry;
	            	}
	            	return totalAncestry;
            	}
            }
            return -1;
		}

		private const int ComputeDelegateAncestry(IMethod Method, IMethod Other)
		{
			int totalAncestry = GetAncestryDegree(Method.ReturnType, Other.ReturnType);
			if (totalAncestry < 0) return -1;

			var firstParams = Method.GetParameters();
			var secondParams = Other.GetParameters();

			if (firstParams.Length != secondParams.Length) return -1;

			var firstParamTypes = firstParams.GetTypes();
			var secondParamTypes = secondParams.GetTypes();

			foreach (var first in firstParamTypes, var second in secondParamTypes)
			{
				int argAncestry = GetAncestryDegree(second, first);

				if (argAncestry < 0) return -1;
				else totalAncestry += argAncestry;
			}

			return totalAncestry;
		}

		private const int ComputeIntersectionAncestry(IType Type, IType Other)
		{
			var leftInter = IntersectionType.GetIntersectedTypes(Type);
			var rightInter = IntersectionType.GetIntersectedTypes(Other);

			int result = 0;
			foreach (var item in rightInter)
			{
				int bestAncestry = ComputeLowestAncestry(leftInter, item);
				if (bestAncestry < 0) return -1;
				result += bestAncestry;
			}
			return result;
		}

		private const int ComputeLowestAncestry([IType] Types, IType Other)
		{
			int bestAncestry = -1;
			foreach (var item in Types)
			{
				int degree = GetAncestryDegree(item, Other);
				if (degree > -1 && (degree <= bestAncestry || bestAncestry == -1))
				{
					bestAncestry = degree;
				}
			}
			return bestAncestry;
		}

		private const int ComputeInheritanceAncestry(IType Type, IType Other)
		{
		    int bestAncestry = ComputeLowestAncestry(Type.GetBaseTypes(), Other);
            if (bestAncestry > -1)
            {
                return bestAncestry + 1;
            }
            else if (Other.IsRootType)
            {
                return 1;
            }
            else
            {
                return -1;
            }
		}

		private const int ComputeAncestry(IType Type, IType Other)
		{
			if (Type.Equals(Other))
            {
                return 0;
            }
            else if (Type.Equals(PrimitiveTypes.Null) && (Other.IsReferenceType || Other.IsPointer))
            {
                return 0;
            }
            else if (Type.IsArray && Other.IsArray)
            {
                if (Type.AsContainerType().AsArrayType().ArrayRank == Other.AsContainerType().AsArrayType().ArrayRank)
                {
                    return ComputeElementAncestry(Type, Other);
                }
                else
                {
                    return -1;
                }
            }
            else if (Type.IsVector && Other.IsArray)
            {
                if (Other.AsContainerType().AsArrayType().ArrayRank == Type.AsContainerType().AsVectorType().GetDimensions().Length)
                {
                    return ComputeElementAncestry(Type, Other);
                }
                else
                {
                    return -1;
                }
            }
            else if (Type.IsPointer && Other.IsPointer)
            {
            	var typePtrKind = Type.AsContainerType().AsPointerType().PointerKind;
            	var otherPtrKind = Other.AsContainerType().AsPointerType().PointerKind;
            	var elementAncestry = ComputeElementAncestry(Type, Other);
            	if (elementAncestry > 0)
            	{
            		if (!typePtrKind.Equals(PointerKind.TransientPointer) && otherPtrKind.Equals(PointerKind.TransientPointer))
            		{
            			return elementAncestry + 1;
            		}
            		else return elementAncestry;
            	}
            	else return -1;
            }
			else if (Type.IsDelegate && Other.IsDelegate)
			{
				var firstMethod = MethodType.GetMethod(Type);
				var secondMethod = MethodType.GetMethod(Other);

				return ComputeDelegateAncestry(firstMethod, secondMethod);
			}
			else if (Type.IsIntersectionType)
			{
				return ComputeIntersectionAncestry(Type, Other);
			}
            int varianceAncestry = ComputeGenericVarianceAncestry(Type, Other);
            if (varianceAncestry > 0)
            {
            	return varianceAncestry;
            }
            return ComputeInheritanceAncestry(Type, Other);
		}
	}
}
