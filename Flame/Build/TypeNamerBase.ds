using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Build
{
	public virtual class TypeNamerBase : TypeConverterBase<string>
	{
		public const this();

		protected override virtual const string MakePointerType(string ElementType, PointerKind Kind)
		{
			return ElementType + Kind.Extension;
		}

		protected override virtual const string MakeArrayType(string ElementType, int ArrayRank)
		{
			return GenericNameExtensions.AppendArraySuffix(ElementType, ArrayRank);
		}

		protected override virtual const string MakeVectorType(string ElementType, IReadOnlyList<int> Dimensions)
		{
			return GenericNameExtensions.AppendVectorSuffix(ElementType, Dimensions);
		}

		protected override virtual const string MakeGenericType(string GenericDeclaration, [string] TypeArguments)
		{
			return GenericNameExtensions.ChangeTypeArguments(GenericDeclaration, TypeArguments);
		}

		protected override virtual const string ConvertGenericParameter(IGenericParameter Type)
		{
			return Type.Name;
		}

		protected override virtual const string ConvertDelegateType(IType Type)
		{
			var deleg = MethodType.GetMethod(Type);
			var sb = new StringBuilder();
			sb.Append(Convert(deleg.ReturnType));
			sb.Append('(');
			var params = deleg.GetParameters();
			for (int i = 0; i < params.Length; i++)
			{
				if (i > 0) sb.Append(", ");
				sb.Append(Convert(params[i].ParameterType));
			}
			sb.Append(')');
			return (string)sb;
		}

		protected override virtual const string ConvertIntersectionType(IntersectionType Type)
		{
			return Convert(Type.First) + "&" + Convert(Type.Second);
		}

		protected override virtual const string ConvertTypeDefault(IType Type)
		{
			if (Type == null)
			{
				return "<unresolved type>";
			}
			else return Type.FullName;
		}
	}
}
