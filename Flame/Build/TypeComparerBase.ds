using System;
using System.Collections.Generic;
using System.Text;

namespace Flame.Build
{
	/// <summary>
	/// Describes a generic type comparer: a class that compares two types and produces a result based on that.
	/// </summary>
	public abstract class TypeComparerBase<T>
	{
		public const this();

		protected abstract const T CompareDefault(IType First, IType Second);
		protected abstract const T MakeGenericInstanceComparison(T DeclarationComparison, [T] TypeArgumentComparisons);
		protected abstract const T MakePointerComparison(T ElementComparison, PointerKind FirstKind, PointerKind SecondKind);
		protected abstract const T MakeArrayComparison(T ElementComparison, int FirstRank, int SecondRank);
		protected abstract const T MakeVectorComparison(T ElementComparison, int[] FirstDimensions, int[] SecondDimensions);

		/// <summary>
		/// Compares two structurally incompatible types.
		/// </summary>
		protected virtual const T CompareIncompatible(IType First, IType Second)
		{
			return CompareDefault(First, Second);
		}

		/// <summary>
		/// Compares two types that have an unknown structure.
		/// </summary>
		protected virtual const T CompareUnknown(IType First, IType Second)
		{
			return CompareDefault(First, Second);
		}

		/// <summary>
		/// Compares two generic type instances.
		/// </summary>
		protected virtual const T CompareGenericInstances(IType First, IType Second)
		{
			var declComparison = Compare(First.GetGenericDeclaration(), Second.GetGenericDeclaration());
			var argComparsions = new List<T>();
			foreach (var item1 in First.GetGenericArguments(), var item2 in Second.GetGenericArguments())
			{
				argComparsions.Add(Compare(item1, item2));
			}
			return MakeGenericInstanceComparison(declComparison, argComparsions);
		}

		protected virtual const T ComparePointerTypes(IPointerType First, IPointerType Second)
		{
			return MakePointerComparison(Compare(First.GetElementType(), Second.GetElementType()), First.PointerKind, Second.PointerKind);
		}

		protected virtual const T CompareArrayTypes(IArrayType First, IArrayType Second)
		{
			return MakeArrayComparison(Compare(First.GetElementType(), Second.GetElementType()), First.ArrayRank, Second.ArrayRank);
		}

		protected virtual const T CompareVectorTypes(IVectorType First, IVectorType Second)
		{
			return MakeVectorComparison(Compare(First.GetElementType(), Second.GetElementType()), First.GetDimensions(), Second.GetDimensions());
		}

		protected virtual const T CompareGenericParameters(IGenericParameter Left, IGenericParameter Right)
		{
			return CompareDefault(Left, Right);
		}

		protected virtual const T CompareContainerTypes(IContainerType First, IContainerType Second)
		{
			if (First.IsPointer || Second.IsPointer)
			{
				if (First.IsPointer && Second.IsPointer)
				{
					return ComparePointerTypes(First.AsPointerType(), Second.AsPointerType());
				}
				else return CompareIncompatible(First, Second);
			}
			else if (First.IsArray || Second.IsArray)
			{
				if (First.IsArray && Second.IsArray)
				{
					return CompareArrayTypes(First.AsArrayType(), Second.AsArrayType());
				}
				else return CompareIncompatible(First, Second);
			}
			else if (First.IsVector || Second.IsVector)
			{
				if (First.IsVector && Second.IsVector)
				{
					return CompareVectorTypes(First.AsVectorType(), Second.AsVectorType());
				}
				else return CompareIncompatible(First, Second);
			}
			else
			{
				return CompareUnknown(First, Second);
			}
		}

		public virtual const T Compare(IType First, IType Second)
		{
			if (First.IsContainerType || Second.IsContainerType)
			{
				if (First.IsContainerType && Second.IsContainerType)
				{
					return CompareContainerTypes(First.AsContainerType(), Second.AsContainerType());
				}
				else return CompareIncompatible(First, Second);
			}
			else if (First.IsGenericInstance || Second.IsGenericInstance)
			{
				if (First.IsGenericInstance && Second.IsGenericInstance)
				{
					return CompareGenericInstances(First, Second);
				}
				else return CompareIncompatible(First, Second);
			}
			else if (First.IsGenericParameter || Second.IsGenericParameter)
			{
				if (First.IsGenericParameter && Second.IsGenericParameter)
				{
					return CompareGenericParameters((IGenericParameter)First, (IGenericParameter)Second);
				}
				else return CompareIncompatible(First, Second);
			}
			else
			{
				return CompareDefault(First, Second);
			}
		}

		public virtual const [T] Compare([IType] First, [IType] Second)
		{
			List<T> results = new List<T>();
			foreach (var left in First, var right in Second)
			{
				results.Add(Compare(left, right));
			}
			return results;
		}
	}
}
