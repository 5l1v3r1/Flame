using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Build
{
	public virtual class DescribedGenericMethodInstance : IMethod, IGenericResolver, IEquatable<IMethod>
	{
		protected const this()
		{
			this.TypeArguments = Enumerable.Empty<IType>();
		}
		public const this(set IMethod Method, set IGenericResolver Parent, set IType DeclaringType, set [IType] TypeArguments);
		public const this(set IMethod Method, set IGenericResolver Parent, set IType DeclaringType)
		{
			this.TypeArguments = Enumerable.Empty<IType>();
		}
		public const this(set IMethod Method, set IGenericResolverType Parent, set [IType] TypeArguments)
		{
			this.DeclaringType = Parent;
		}
		public const this(set IMethod Method, set IGenericResolverType Parent)
		{
			this.DeclaringType = Parent;
			this.TypeArguments = Enumerable.Empty<IType>();
		}

		public IMethod Method { const get; protected set; }
		public IGenericResolver Parent { const get; protected set; }
		public IType DeclaringType { const get; protected set; }
		public [IType] TypeArguments { const get; protected set; }

		public const IType ResolveTypeParameter(IGenericParameter TypeParameter)
        {
        	foreach (var param in GetGenericParameters(), var arg in TypeArguments)
        	{
        		if (TypeParameter.Equals(param))
        		{
        			return arg;
        		}
        	}
        	if (Parent != null)
        	{
            	return Parent.ResolveTypeParameter(TypeParameter);
            }
            else
            {
            	return TypeParameter;
            }
        }

		public bool IsStatic { const get return Method.IsStatic; }
		public bool IsConstructor { const get return Method.IsConstructor; }

		public string Name
        {
            const get { return GenericNameExtensions.AppendTypeArguments(Method.GetGenericFreeName(), TypeArguments.Names); }
        }

        public string FullName
        {
            const get { return GenericNameExtensions.AppendTypeArguments(Method.GetGenericFreeFullName(), TypeArguments.FullNames); }
        }

		public const [IAttribute] GetAttributes()
        {
            return Method.GetAttributes();
        }

        public IType ReturnType
        {
            const get { return this.ResolveType(Method.ReturnType); }
        }

        public const IParameter[] GetParameters()
        {
            return this.ResolveParameters(Method.GetParameters());
        }

        public const IMethod[] GetBaseMethods()
        {
            return this.ResolveMethods(Method.GetBaseMethods());
        }

        public const IMethod GetGenericDeclaration()
        {
            if (DeclaringType == null || DeclaringType.IsGenericDeclaration || !DeclaringType.IsGeneric)
            {
                return Method;
            }
            else
            {
                return new DescribedGenericMethodInstance(Method, Parent, DeclaringType);
            }
        }

        public const IMethod MakeGenericMethod([IType] GenericArguments)
        {
            return new DescribedGenericMethodInstance(Method, Parent, DeclaringType, GenericArguments);
        }

        public const [IType] GetGenericArguments()
        {
            return TypeArguments;
        }

        public const [IGenericParameter] GetGenericParameters()
        {
            return Method.GetGenericParameters();
        }

        public IBoundObject Invoke(IBoundObject Caller, [IBoundObject] Arguments)
        {
            return null;
        }

        public override const string ToString()
        {
        	return Name;
        }

        #region Equality

        public override const bool Equals(object Other)
        {
        	if (Other is IMethod)
        	{
        		return Equals((IMethod)Other);
        	}
        	else return false;
        }

		private const bool DeclaringTypeEquals(IType Other)
		{
			return object.ReferenceEquals(DeclaringType, Other) ||
			       DeclaringType != null &&
				   Other != null &&
				   DeclaringType.Equals(Other);
		}

		private const bool ParentEquals(IGenericResolver Other)
		{
			return object.ReferenceEquals(Parent, Other) ||
				   Parent != null &&
				   Other != null &&
				   Parent.Equals(Other);
		}

        public const bool Equals(IMethod Other)
        {
        	if (Other is DescribedGenericMethodInstance)
        	{
        		return Equals((DescribedGenericMethodInstance)Other);
        	}
        	return DeclaringTypeEquals(Other.DeclaringType) &&
				   this.Method.Equals(Other.GetGenericDeclaration()) &&
				   Enumerable.SequenceEqual<IType>(this.TypeArguments, Other.GetGenericArguments());
        }

        public const bool Equals(DescribedGenericMethodInstance Other)
        {
        	return ParentEquals(Other.Parent) &&
				   this.Method.Equals(Other.Method) &&
				   Enumerable.SequenceEqual<IType>(this.TypeArguments, Other.TypeArguments);
        }

        public override const int GetHashCode()
        {
        	return Method.GetHashCode();
        }

        #endregion
	}
}
