using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Build
{
	/// <summary>
	/// A type converter that resolves type parameters based on a generic resolver.
	/// </summary>
	public class GenericResolvingConverter : TypeTransformerBase
	{
		public const this(set IGenericResolver Resolver);

		public IGenericResolver Resolver { const get; private set; }

		protected override const IType ConvertNestedType(IType Type, IType DeclaringType)
		{
			var convDeclType = Convert(DeclaringType);
			var convDeclNs = (INamespace)convDeclType;

			string tName = Type.Name;
			int genParamCount = Enumerable.Count<IGenericParameter>(Type.GetGenericParameters());

			foreach (var item in convDeclNs.GetTypes())
				if (item.Name == tName && Enumerable.Count<IGenericParameter>(item.GetGenericParameters()) == genParamCount)
			{
				return item;
			}

			return null; // Failure
		}

		protected override const IType ConvertGenericParameter(IGenericParameter Type)
		{
			var result = Resolver.ResolveTypeParameter(Type);
			if (result == null)
				return Type;
			else
				return result;
		}
	}

	public static class GenericResolverExtensions
	{
		public static const IType ResolveType(this IGenericResolver Resolver, IType Type)
		{
			var converter = new GenericResolvingConverter(Resolver);
			return converter.Convert(Type);
		}
		public static const IType[] ResolveTypes(this IGenericResolver Resolver, IType[] Types)
        {
        	var converter = new GenericResolvingConverter(Resolver);
        	IType[] results = new IType[Types.Length];
        	foreach (var item in Types, var output in results)
        	{
        		output = converter.Convert(item);
        	}
        	return results;
        }
		public static const [IType] ResolveTypes(this IGenericResolver Resolver, [IType] Types)
        {
			var converter = new GenericResolvingConverter(Resolver);
			return converter.Convert(Types);
        }

		private static const IMethod ResolveGenericInstanceMethod(IGenericResolver Resolver, IMethod Method)
		{
			var declType = Method.DeclaringType;
			var resolvedDeclType = Resolver.ResolveType(declType);
			if (!resolvedDeclType.Equals(declType))
			{
				var resolvedParamTypes = Resolver.ResolveTypes(Method.GetParameters().GetTypes());
				var comparer = new ScopedTypeEqualityComparer();

				if (Method.IsConstructor)
				{
					foreach (var item in resolvedDeclType.GetConstructors())
						if (item.IsStatic == Method.IsStatic)
						if (comparer.CompareAll(resolvedParamTypes,
							Resolver.ResolveTypes(item.GetParameters().GetTypes())))
					{
						return item;
					}
				}
				else
				{
					var resolvedRetType = Resolver.ResolveType(Method.ReturnType);

					foreach (var item in resolvedDeclType.GetMethods())
						if (item.Name.Equals(Method.Name))
						if (item.IsStatic == Method.IsStatic)
						if (comparer.Compare(resolvedRetType,
							Resolver.ResolveType(item.ReturnType)))
						if (comparer.CompareAll(resolvedParamTypes,
							Resolver.ResolveTypes(item.GetParameters().GetTypes())))
					{
						return item;
					}
				}

				return null; // Failure
			}
			else return Method;
		}

        public static const IMethod ResolveMethod(this IGenericResolver Resolver, IMethod Method)
        {
			var instMethod = ResolveGenericInstanceMethod(Resolver, Method);

            if (instMethod.IsGenericInstance)
            {
                var resolvedArgs = Resolver.ResolveTypes(instMethod.GetGenericArguments());
                return instMethod.MakeGenericMethod(resolvedArgs);
            }
            else
            {
                return instMethod;
            }
        }
        public static const IMethod[] ResolveMethods(this IGenericResolver Resolver, IMethod[] Methods)
        {
        	var results = new IMethod[Methods.Length];
        	foreach (var item in Methods, var output in results)
        	{
        		output = Resolver.ResolveMethod(item);
        	}
        	return results;
        }
        public static const [IMethod] ResolveMethods(this IGenericResolver Resolver, [IMethod] Methods)
        {
        	return Resolver.ResolveMethods(Enumerable.ToArray<IMethod>(Methods));
        }

        public static const IParameter ResolveParameter(this IGenericResolver Resolver, IParameter Parameter)
        {
        	return new DescribedRetypedParameter(Parameter, Resolver.ResolveType(Parameter.ParameterType));
        }
        public static const IParameter[] ResolveParameters(this IGenericResolver Resolver, IParameter[] Parameters)
        {
        	IParameter[] results = new IParameter[Parameters.Length];
        	foreach (var item in Parameters, var output in results)
        	{
        		output = Resolver.ResolveParameter(item);
        	}
        	return results;
        }
        public static const [IParameter] ResolveParameters(this IGenericResolver Resolver, [IParameter] Parameters)
        {
        	return Resolver.ResolveParameters(Enumerable.ToArray<IParameter>(Parameters));
        }
	}
}
