using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;

namespace Flame.Build
{
	public virtual class TypeTransformerBase : TypeConverterBase<IType>
	{
		public const this();

		private static const bool TypeReferencesEqual([IType] First, [IType] Second)
		{
			foreach (var left in First, var right in Second)
				if (!object.ReferenceEquals(left, right))
			{
				return false;
			}
			return true;
		}

		protected override virtual const IType MakePointerType(IType ElementType, PointerKind Kind)
		{
			return ElementType.MakePointerType(Kind);
		}

		protected override virtual const IType MakeArrayType(IType ElementType, int ArrayRank)
		{
			return ElementType.MakeArrayType(ArrayRank);
		}

		protected override virtual const IType MakeVectorType(IType ElementType, int[] Dimensions)
		{
			return ElementType.MakeVectorType(Dimensions);
		}

		protected override virtual const IType MakeGenericType(IType GenericDeclaration, [IType] TypeArguments)
		{
			return GenericDeclaration.MakeGenericType(TypeArguments);
		}

		protected override virtual const IType ConvertDelegateType(IType Type)
		{
			var method = MethodType.GetMethod(Type);
			var retType = Convert(method.ReturnType);

			var parameters = method.GetParameters();
			var paramTypes = parameters.GetTypes();
			var convTypes = Enumerable.ToArray<IType>(Convert(paramTypes));

			if (object.ReferenceEquals(retType, method.ReturnType) &&
				TypeReferencesEqual(convTypes, paramTypes))
			{
				return Type;
			}

			var descMethod = new DescribedMethod(method.Name, method.DeclaringType, retType, method.IsStatic);

			foreach (var type in convTypes, var item in parameters)
			{
				descMethod.AddParameter(new DescribedRetypedParameter(item, type));
			}
			foreach (var attr in method.GetAttributes())
			{
				descMethod.AddAttribute(attr);
			}

			return MethodType.Create(descMethod);
		}

		protected override virtual const IType ConvertIntersectionType(IntersectionType Type)
		{
			var convFirst = Convert(Type.First);
			var convSecond = Convert(Type.Second);

			if (object.ReferenceEquals(convFirst, Type.First) &&
				object.ReferenceEquals(convSecond, Type.Second))
			{
				return Type;
			}

			return new IntersectionType(Convert(Type.First), Convert(Type.Second));
		}

		protected override virtual const IType ConvertGenericInstance(IType Type)
		{
			var genDecl = Type.GetGenericDeclaration();
			var genArgs = Type.GetGenericArguments();

			var convDecl = Convert(genDecl);
			var convArgs = Enumerable.ToArray<IType>(Convert(genArgs));

			if (object.ReferenceEquals(convDecl, genDecl) &&
				TypeReferencesEqual(convArgs, genArgs))
			{
				return Type;
			}

			return MakeGenericType(convDecl, convArgs);
		}

		protected override virtual const IType ConvertPointerType(IPointerType Type)
		{
			var elemType = Type.GetElementType();
			var convElem = Convert(elemType);

			if (object.ReferenceEquals(convElem, elemType))
			{
				return Type;
			}

			return MakePointerType(convElem, Type.PointerKind);
		}

		protected override virtual const IType ConvertArrayType(IArrayType Type)
		{
			var elemType = Type.GetElementType();
			var convElem = Convert(elemType);

			if (object.ReferenceEquals(convElem, elemType))
			{
				return Type;
			}

			return MakeArrayType(convElem, Type.ArrayRank);
		}

		protected override virtual const IType ConvertVectorType(IVectorType Type)
		{
			var elemType = Type.GetElementType();
			var convElem = Convert(elemType);

			if (object.ReferenceEquals(convElem, elemType))
			{
				return Type;
			}

			return MakeVectorType(convElem, Type.GetDimensions());
		}

		protected override virtual const IType ConvertTypeDefault(IType Type)
		{
			return Type;
		}
	}
}
