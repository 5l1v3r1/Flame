using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Build;

namespace Flame
{
	public static class MethodExtensions
	{
		/// <summary>
		/// Gets a boolean value that tells if this method implements
		/// the given base method.
		/// </summary>
		public static bool IsImplementationOf(this IMethod Method, IMethod BaseMethod)
		{
			foreach (var item in Method.BaseMethods)
			{
				var decl = item.GetGenericDeclaration();
				if (decl.Equals(BaseMethod))
				{
					return true;
				}
				else if (decl.IsImplementationOf(BaseMethod))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Gets this method's implementation in the given type.
		/// If no implementation can be found, null is returned.
		/// </summary>
		/// <remarks>
		/// Note: a virtual method without overrides in the given type could
		/// arguably be considered its own, albeit trivial, implementation.
		/// This method still returns null in that case, however.
		/// </remarks>
		public static IMethod GetImplementation(this IMethod Method, IType Target)
		{
			if (Method is IAccessor)
			{
				var accessor = (IAccessor)Method;
				var type = accessor.AccessorType;
				var property = accessor.DeclaringProperty;
				foreach (var item in Target.GetAllProperties())
					if (!item.IsAbstract && !item.Equals(property))
				{
					var accImpl = item.GetAccessor(type);

					if (accImpl != null)
					if (!accImpl.IsAbstract && accImpl.IsImplementationOf(accessor))
					{
						return accImpl;
					}
				}
			}
			else
			{
				foreach (var item in Target.GetAllMethods())
				{
					if (!item.IsAbstract && !item.Equals(Method))
					{
						if (item.IsImplementationOf(Method))
						{
							return item;
						}
					}
				}
			}
			return null;
		}

		public static const IMethod ConcatMethods(this [IMethod] Methods)
		{
			if (Enumerable.Any<IMethod>(Enumerable.Skip<IMethod>(Methods, 1))) // More than 2 elements
				return null;
			return Enumerable.SingleOrDefault<IMethod>(Methods);
		}

		private static bool ShadowsMethod(IMethod Method, IMethod Other)
		{
			return Method.Name.Equals(Other.Name) &&
				   Method.IsStatic == Other.IsStatic &&
				   !Method.Equals(Other) &&
				   Method.DeclaringType.Is(Other.DeclaringType) &&
				   ScopedTypeEqualityComparer.CompareAll(
				       Method.Parameters.GetTypes(),
				       Other.Parameters.GetTypes());
		}

		private static bool ShadowsAccessorCore(IAccessor Top, IAccessor Bottom)
		{
			return Top.AccessorType == Bottom.AccessorType &&
				   Top.DeclaringProperty.Shadows(Bottom.DeclaringProperty);
		}

		private static bool ShadowsAccessor(IMethod Method, IMethod Other)
		{
			return Method is IAccessor && Other is IAccessor &&
				   ShadowsAccessorCore((IAccessor)Method, (IAccessor)Other);
		}

		/// <summary>
		/// Tells if the first method "shadows" the second, i.e. it has the
		/// same name, staticness and parameter list, but its declaring type
		/// is more derived than the second method's derived type.
		/// </summary>
		public static bool Shadows(this IMethod Method, IMethod Other)
		{
			return ShadowsMethod(Method, Other) || ShadowsAccessor(Method, Other);
		}

		/// <summary>
		/// Determines whether the given methods have the same signature or not.
		/// </summary>
		public static bool HasSameSignature(this IMethod Method, IMethod Other)
		{
			var comparer = ScopedTypeEqualityComparer;

			return Method.Name.Equals(Other.Name) &&
			       Method.IsStatic == Other.IsStatic &&
			       comparer.Compare(Method.ReturnType, Other.ReturnType) &&
			       comparer.CompareAll(Method.Parameters.GetTypes(), Other.Parameters.GetTypes());
		}

		public static IMethod GetBestMethod(this [IMethod] Candidates, IType[] ParameterTypes)
		{
			return (([IMethod])Candidates.GetBestMethods(ParameterTypes)).ConcatMethods();
		}
		public static IMethod GetBestMethod(this [IMethod] Candidates, IType CallerType, IType[] ParameterTypes)
		{
			return (([IMethod])Candidates.GetBestMethods(CallerType, ParameterTypes)).ConcatMethods();
		}
		public static IMethod GetBestMethod(this [IMethod] Candidates, bool IsStatic, IType CallerType, IType[] ParameterTypes)
		{
			var matches = new List<IMethod>();
			foreach (var method in Candidates.GetBestMethods(CallerType, ParameterTypes))
			{
				if (method.IsStatic == IsStatic)
					matches.Add(method);
			}
			return matches.ConcatMethods();
		}

		/// <summary>
		/// Gets all methods - directly declared and inherited - in the given
		/// declaring type with the given name, staticness and parameter types.
		/// </summary>
		public static [IMethod] GetAllMethods(this IType DeclaringType, string Name, bool IsStatic, IType[] ParameterTypes)
		{
			var methods = new List<IMethod>();
			foreach (var method in DeclaringType.GetAllMethods())
			{
				if (method.Name == Name &&
				    method.IsStatic == IsStatic &&
				    method.Parameters.GetTypes().AreEqual(ParameterTypes))
				{
					methods.Add(method);
				}
			}
			return methods;
		}

		/// <summary>
		/// Gets the first method in the given sequence of candidate methods
		/// with the given staticness, return type and parameter types.
		/// </summary>
		public static IMethod GetMethod(this [IMethod] Candidates, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			foreach (var method in Candidates)
			{
				if (method.IsStatic == IsStatic &&
				    method.ReturnType.Equals(ReturnType) &&
				    method.Parameters.GetTypes().AreEqual(ParameterTypes))
				{
					return method;
				}
			}
			return null;
		}

		/// <summary>
		/// Gets the first method in the given sequence of candidate methods
		/// with the given name, staticness, return type and parameter types.
		/// </summary>
		public static IMethod GetMethod(this [IMethod] Candidates, string Name, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			foreach (var method in Candidates)
			{
				if (method.Name == Name &&
					method.IsStatic == IsStatic &&
				    method.ReturnType.Equals(ReturnType) &&
					method.Parameters.GetTypes().AreEqual(ParameterTypes))
				{
					return method;
				}
			}
			return null;
		}

		/// <summary>
		/// Gets the first method in the given sequence of candidate methods that
		/// has the same signature as the given method.
		/// </summary>
		/// <remarks>
		/// This differs from the
		/// <code>GetMethod(this [IMethod], string, bool, IType, IType[])</code>
		/// overload in that generic parameters are also considered here.
		/// </remarks>
		public static IMethod GetMethod(this [IMethod] Candidates, IMethod Signature)
		{
			foreach (var item in Candidates)
			{
				if (item.HasSameSignature(Signature))
					return item;
			}
			return null;
		}

		public static IMethod GetMethod(this IType DeclaringType, string Name, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			return DeclaringType.GetAllMethods().GetMethod(Name, IsStatic, ReturnType, ParameterTypes);
		}
		public static IMethod GetMethod(this IType DeclaringType, bool IsStatic, IType[] ParameterTypes)
		{
			foreach (var method in DeclaringType.GetAllMethods())
			{
				if (method.IsStatic == IsStatic &&
				    method.Parameters.GetTypes().AreEqual(ParameterTypes))
				{
					return method;
				}
			}
			return null;
		}

		public static IMethod GetConstructor(this IType DeclaringType, IType[] ParameterTypes, bool IsStatic)
		{
			foreach (var method in DeclaringType.GetConstructors())
			{
				if (method.IsConstructor &&
				    method.IsStatic == IsStatic &&
				    method.Parameters.GetTypes().AreEqual(ParameterTypes))
				{
					return method;
				}
			}
			return null;
		}

		public static IMethod GetConstructor(this IType DeclaringType, IType[] ParameterTypes)
		{
			return DeclaringType.GetConstructor(ParameterTypes, false);
		}

		public static [IMethod] GetOperatorMethods(this IType Type)
		{
			return Type.GetAllMethods().GetOperatorMethods();
		}

		public static [IMethod] GetOperatorMethods(this IType Type, Operator Op)
		{
			return Type.GetAllMethods().GetOperatorMethods(Op);
		}

		public static [IMethod] GetOperatorMethods(this [IMethod] Candidates)
		{
			var methods = new List<IMethod>();
			foreach (var item in Candidates)
			{
				if (item.IsOperator)
					methods.Add(item);
			}
			return methods;
		}

		public static [IMethod] GetOperatorMethods(this [IMethod] Candidates, Operator Op)
		{
			var methods = new List<IMethod>();
			foreach (var item in Candidates)
			{
				if (item.IsOperator)
                if (item.GetOperator() == Op)
					methods.Add(item);
			}
			return methods;
		}

		public static IMethod GetOperatorMethod(this [IMethod] Candidates, Operator Op)
		{
			foreach (var item in Candidates)
			{
				if (item.GetOperator() == Op)
					return item;
			}
			return null;
		}

		/// <summary>
		/// Gets all non-constructor methods declared by this type.
		/// </summary>
		public static [IMethod] GetMethods(this IType Type)
		{
			var results = new List<IMethod>();
			foreach (var item in Type.Methods)
				if (!item.IsConstructor)
			{
				results.Add(item);
			}
			return results;
		}

		/// <summary>
		/// Gets this type's constructors.
		/// </summary>
		public static [IMethod] GetConstructors(this IType Type)
		{
			var results = new List<IMethod>();
			foreach (var item in Type.Methods)
				if (item.IsConstructor)
			{
				results.Add(item);
			}
			return results;
		}

		/// <summary>
		/// Gets a read-only array containing the given method's parameter list.
		/// </summary>
		public static IParameter[] GetParameters(this IMethod Method)
		{
			return Enumerable.ToArray<IParameter>(Method.Parameters);
		}

		/// <summary>
		/// Gets a boolean value that indicates whether the given method has a
		/// non-null, non-void return value.
		/// </summary>
		public static bool HasReturnValue[this IMethod Method]
		{
			const get
			{
				var retVal = Method.ReturnType;
				return !(retVal == null || retVal.Equals(PrimitiveTypes.Void));
			}
		}
	}
}
