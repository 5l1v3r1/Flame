using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Build;

namespace Flame
{
	public static class MethodExtensions
	{
		/// <summary>
		/// Gets a boolean value that tells if this method implements
		/// the given base method.
		/// </summary>
		public static const bool IsImplementationOf(this IMethod Method, IMethod BaseMethod)
		{
			foreach (var item in Method.GetBaseMethods())
			{
				var decl = item.GetGenericDeclaration();
				if (decl.Equals(BaseMethod))
				{
					return true;
				}
				else if (decl.IsImplementationOf(BaseMethod))
				{
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Gets this method's implementation in the given type.
		/// If no implementation can be found, null is returned.
		/// </summary>
		/// <remarks>
		/// Note: a virtual method without overrides in the given type could
		/// arguably be considered its own, albeit trivial, implementation.
		/// This method still returns null in that case, however.
		/// </remarks>
		public static const IMethod GetImplementation(this IMethod Method, IType Target)
		{
			if (Method is IAccessor)
			{
				var accessor = (IAccessor)Method;
				var type = accessor.AccessorType;
				var property = accessor.DeclaringProperty;
				foreach (var item in Target.GetAllProperties())
					if (!item.IsAbstract && !item.Equals(property))
				{
					var accImpl = item.GetAccessor(type);

					if (accImpl != null)
					if (!accImpl.IsAbstract && accImpl.IsImplementationOf(accessor))
					{
						return accImpl;
					}
				}
			}
			else
			{
				foreach (var item in Target.GetAllMethods())
				{
					if (!item.IsAbstract && !item.Equals(Method))
					{
						if (item.IsImplementationOf(Method))
						{
							return item;
						}
					}
				}
			}
			return null;
		}

		public static const IMethod ConcatMethods(this [IMethod] Methods)
		{
			if (Enumerable.Any<IMethod>(Enumerable.Skip<IMethod>(Methods, 1))) // More than 2 elements
				return null;
			return Enumerable.SingleOrDefault<IMethod>(Methods);
		}

		private static const bool ShadowsMethod(IMethod Method, IMethod Other)
		{
			return Method.Name.Equals(Other.Name) &&
				   Method.IsStatic == Other.IsStatic &&
				   !Method.Equals(Other) &&
				   Method.DeclaringType.Is(Other.DeclaringType) &&
				   new ScopedTypeEqualityComparer().CompareAll(
				       Method.GetParameters().GetTypes(),
				       Other.GetParameters().GetTypes());
		}

		private static const bool ShadowsAccessorCore(IAccessor Top, IAccessor Bottom)
		{
			return Top.AccessorType == Bottom.AccessorType &&
				   Top.DeclaringProperty.Shadows(Bottom.DeclaringProperty);
		}

		private static const bool ShadowsAccessor(IMethod Method, IMethod Other)
		{
			return Method is IAccessor && Other is IAccessor &&
				   ShadowsAccessorCore((IAccessor)Method, (IAccessor)Other);
		}

		/// <summary>
		/// Tells if the first method "shadows" the second, i.e. it has the
		/// same name, staticness and parameter list, but its declaring type
		/// is more derived than the second method's derived type.
		/// </summary>
		public static const bool Shadows(this IMethod Method, IMethod Other)
		{
			return ShadowsMethod(Method, Other) || ShadowsAccessor(Method, Other);
		}

		public static const bool HasSameSignature(this IMethod Method, IMethod Other)
		{
			var comparer = new ScopedTypeEqualityComparer();

			return Method.Name.Equals(Other.Name) &&
			       Method.IsStatic == Other.IsStatic &&
			       comparer.Compare(Method.ReturnType, Other.ReturnType) &&
			       comparer.CompareAll(Method.GetParameters().GetTypes(), Other.GetParameters().GetTypes());
		}

		public static const IMethod GetBestMethod(this [IMethod] Candidates, IType[] ParameterTypes)
		{
			return (([IMethod])Candidates.GetBestMethods(ParameterTypes)).ConcatMethods();
		}
		public static const IMethod GetBestMethod(this [IMethod] Candidates, IType CallerType, IType[] ParameterTypes)
		{
			return (([IMethod])Candidates.GetBestMethods(CallerType, ParameterTypes)).ConcatMethods();
		}
		public static const IMethod GetBestMethod(this [IMethod] Candidates, bool IsStatic, IType CallerType, IType[] ParameterTypes)
		{
			List<IMethod> matches = new List<IMethod>();
			foreach (var method in Candidates.GetBestMethods(CallerType, ParameterTypes))
			{
				if (method.IsStatic == IsStatic)
					matches.Add(method);
			}
			return matches.ConcatMethods();
		}

		public static const [IMethod] GetAllMethods(this IType DeclaringType, string Name, bool IsStatic, IType[] ParameterTypes)
		{
			List<IMethod> methods = new List<IMethod>();
			foreach (var method in DeclaringType.GetAllMethods())
			{
				if (method.Name.Equals(Name))
				if (method.IsStatic == IsStatic)
				if (method.GetParameters().GetTypes().AreEqual(ParameterTypes))
					methods.Add(method);
			}
			return methods;
		}

		public static const IMethod GetMethod(this [IMethod] Candidates, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			foreach (var method in Candidates)
			{
				if (method.IsStatic == IsStatic)
				if (method.ReturnType.Equals(ReturnType))
				if (method.GetParameters().GetTypes().AreEqual(ParameterTypes))
					return method;
			}
			return null;
		}
		public static const IMethod GetMethod(this [IMethod] Candidates, string Name, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			foreach (var method in Candidates)
			{
				if (method.Name.Equals(Name))
				if (method.IsStatic == IsStatic)
				if (method.ReturnType.Equals(ReturnType))
				if (method.GetParameters().GetTypes().AreEqual(ParameterTypes))
					return method;
			}
			return null;
		}
		public static const IMethod GetMethod(this IType DeclaringType, string Name, bool IsStatic, IType ReturnType, IType[] ParameterTypes)
		{
			return DeclaringType.GetAllMethods().GetMethod(Name, IsStatic, ReturnType, ParameterTypes);
		}
		public static const IMethod GetMethod(this IType DeclaringType, bool IsStatic, IType[] ParameterTypes)
		{
			foreach (var method in DeclaringType.GetAllMethods())
			{
				if (method.IsStatic == IsStatic)
				if (method.GetParameters().GetTypes().AreEqual(ParameterTypes))
					return method;
			}
			return null;
		}

		public static const IMethod GetConstructor(this IType DeclaringType, IType[] ParameterTypes, bool IsStatic)
		{
			foreach (var method in DeclaringType.GetConstructors())
			{
				if (method.IsConstructor)
				if (method.IsStatic == IsStatic)
				if (method.GetParameters().GetTypes().AreEqual(ParameterTypes))
					return method;
			}
			return null;
		}

		public static const IMethod GetConstructor(this IType DeclaringType, IType[] ParameterTypes)
		{
			return DeclaringType.GetConstructor(ParameterTypes, false);
		}

		public static const [IMethod] GetOperatorMethods(this IType Type)
		{
			return Type.GetAllMethods().GetOperatorMethods();
		}

		public static const [IMethod] GetOperatorMethods(this IType Type, Operator Op)
		{
			return Type.GetAllMethods().GetOperatorMethods(Op);
		}

		public static const [IMethod] GetOperatorMethods(this [IMethod] Candidates)
		{
			List<IMethod> methods = new List<IMethod>();
			foreach (var item in Candidates)
			{
				if (item.IsOperator)
					methods.Add(item);
			}
			return methods;
		}

		public static const [IMethod] GetOperatorMethods(this [IMethod] Candidates, Operator Op)
		{
			List<IMethod> methods = new List<IMethod>();
			foreach (var item in Candidates)
			{
				if (item.IsOperator)
                if (item.GetOperator() == Op)
					methods.Add(item);
			}
			return methods;
		}

		public static const IMethod GetOperatorMethod(this [IMethod] Candidates, Operator Op)
		{
			foreach (var item in Candidates)
			{
				if (item.GetOperator() == Op)
					return item;
			}
			return null;
		}

		/// <summary>
		/// Gets a boolean value that indicates whether the given method has a
		/// non-null, non-void return value.
		/// </summary>
		public static bool HasReturnValue[this IMethod Method]
		{
			const get
			{
				var retVal = Method.ReturnType;
				return !(retVal == null || retVal.Equals(PrimitiveTypes.Void));
			}
		}
	}
}
