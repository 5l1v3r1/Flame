using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;

namespace Flame
{
    public struct Operator
    {
        private const this(set int32 typeIndex);
        public const this(Operator Other)
        {
            this.typeIndex = Other.typeIndex;
        }

        private int32 typeIndex;

        public bool IsDefined
        {
            const get return typeIndex > -1;
        }

        public string Name
        {
            const get
            {
                if (typeIndex >= 0)
                    return typeNames[typeIndex];
                else
                    return null;
            }
        }

        #region Equality

        public override const int32 GetHashCode()
        {
            return typeIndex.GetHashCode();
        }

        public override const bool Equals(object obj)
        {
            if (obj is Operator)
            {
                return ((Operator)obj).typeIndex == typeIndex;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ToString

        public override string ToString()
        {
            return Name;
        }

        #endregion

        #region Static

        #region Management

        static this()
        {
            typeNames = new List<string>();
            operatorDict = new ConcurrentDictionary<string, Operator>();
            RegisterAll(new Operator[]
            {
                Operator.Add, Operator.Subtract,
                Operator.Multiply, Operator.Divide, Operator.Remainder,
                Operator.LeftShift, Operator.RightShift,
                Operator.Or, Operator.And, Operator.Xor,
                Operator.LogicalOr, Operator.LogicalAnd,
                Operator.BitwiseComplement,
                Operator.CheckEquality, Operator.CheckInequality,
                Operator.CheckLessThan, Operator.CheckLessThanOrEqual,
                Operator.CheckGreaterThan, Operator.CheckGreaterThanOrEqual,
                Operator.Not, Operator.Hash, Operator.Concat,
                Operator.IsInstance, Operator.AsInstance,
                Operator.StaticCast, Operator.DynamicCast,
                Operator.Box, Operator.UnboxReference, Operator.UnboxValue,
                Operator.ReinterpretCast,
                Operator.GetDelegate, Operator.GetVirtualDelegate,
                Operator.GetCurriedDelegate,
                Operator.Increment, Operator.Decrement
            });
        }

        private static List<string> typeNames;
        private static ConcurrentDictionary<string, Operator> operatorDict;

        private static void RegisterAll(Operator[] Operators); // Does nothing. 'Operator' values are already registered.

        private static Operator RegisterNew(string Name)
        {
            typeNames.Add(Name);
            return new Operator(typeNames.Count - 1);
        }

        public static Operator Register(string Name)
        {
            return operatorDict.GetOrAdd(Name, RegisterNew);
        }

        public static bool IsOperator(string Operator)
        {
            return typeNames.Contains(Operator);
        }
        public static bool TryGetOperator(string OperatorName, out Operator^ Result)
        {
            return operatorDict.TryGetValue(OperatorName, Result);
        }
        public static Operator GetOperator(string OperatorName)
        {
            if (TryGetOperator(OperatorName, &Operator result))
            {
                return result;
            }
            else
            {
                return Undefined;
            }
        }

        public static const bool IsComparisonOperator(Operator Op)
        {
            int tIndex = Op.typeIndex;
            return     tIndex == Operator.CheckEquality.typeIndex || tIndex == Operator.CheckInequality.typeIndex ||
                    tIndex == Operator.CheckGreaterThan.typeIndex || tIndex == Operator.CheckGreaterThanOrEqual.typeIndex ||
                    tIndex == Operator.CheckLessThan.typeIndex || tIndex == Operator.CheckLessThanOrEqual.typeIndex;
        }

        #endregion

        #region Common Accessors

        public static Operator Undefined
        {
            const get
            {
                return new Operator(-1);
            }
        }

        public static Operator Add
        {
            get
            {
                return Register("+");
            }
        }

        public static Operator Subtract
        {
            get
            {
                return Register("-");
            }
        }

        public static Operator Multiply
        {
            get
            {
                return Register("*");
            }
        }

        public static Operator Divide
        {
            get
            {
                return Register("/");
            }
        }

        public static Operator Remainder
        {
            get
            {
                return Register("%");
            }
        }

        public static Operator CheckEquality
        {
            get
            {
                return Register("==");
            }
        }

        public static Operator CheckInequality
        {
            get
            {
                return Register("!=");
            }
        }

        public static Operator CheckGreaterThan
        {
            get
            {
                return Register(">");
            }
        }

        public static Operator CheckLessThan
        {
            get
            {
                return Register("<");
            }
        }

        public static Operator CheckGreaterThanOrEqual
        {
            get
            {
                return Register(">=");
            }
        }

        public static Operator CheckLessThanOrEqual
        {
            get
            {
                return Register("<=");
            }
        }

        public static Operator Not
        {
            get
            {
                return Register("!");
            }
        }

        /// <summary>
        /// Gets the bitwise complement operator symbol. Note that this symbol
        /// should only be used for user-defined operators: intrinsics use
        /// the logical complement operator.
        /// </summary>
        public static Operator BitwiseComplement
        {
            get
            {
                return Register("~");
            }
        }

        public static Operator Or
        {
            get
            {
                return Register("|");
            }
        }
        public static Operator LogicalOr
        {
            get
            {
                return Register("||");
            }
        }

        public static Operator And
        {
            get
            {
                return Register("&");
            }
        }
        public static Operator LogicalAnd
        {
            get
            {
                return Register("&&");
            }
        }

        public static Operator Xor
        {
            get
            {
                return Register("^");
            }
        }

        public static Operator LeftShift
        {
            get
            {
                return Register("<<");
            }
        }
        public static Operator RightShift
        {
            get
            {
                return Register(">>");
            }
        }
        public static Operator Hash
        {
            get
            {
                return Register("hash");
            }
        }
        public static Operator Concat
        {
            get
            {
                return Register("++");
            }
        }

        public static Operator Increment
        {
            get
            {
                return Register("+1");
            }
        }

        public static Operator Decrement
        {
            get
            {
                return Register("-1");
            }
        }

        /// <summary>
        /// An operator that tests if a given reference or pointer is of a specific type,
        /// and returns a boolean.
        /// This is equivalent to the C# `is` operator.
        /// </summary>
        public static Operator IsInstance
        {
            get
            {
                return Register("is_instance");
            }
        }

        /// <summary>
        /// An operator that returns the given given reference or pointer if it is
        /// of the given type. Otherwise, null is returned.
        /// This is equivalent to the C# `as` operator.
        /// </summary>
        public static Operator AsInstance
        {
            get
            {
                return Register("as_instance");
            }
        }

        /// <summary>
        /// A conversion operator that converts a given value to an equivalent value
        /// of a different type. User-defined conversions overload this operator.
        /// </summary>
        /// <example>
        /// <code>
        /// double x = 3.0;
        /// double i = (int)x;
        ///            ^~~~~
        /// </code>
        /// </example>
        public static Operator StaticCast
        {
            get
            {
                return Register("static_cast");
            }
        }

        /// <summary>
        /// Defines a dynamic cast operator, which performs a runtime check to
        /// determine if a given reference or pointer is of a given type.
        /// The given reference or pointer is returned if this is the case.
        /// Otherwise, an exception is thrown at runtime.
        /// </summary>
        public static Operator DynamicCast
        {
            get
            {
                return Register("dynamic_cast");
            }
        }

        /// <summary>
        /// Defines a reinterpret cast operator, which converts a reference or
        /// pointer type to another reference or pointer type. The operation is
        /// assumed to always succeed, and does not require a runtime check.
        /// </summary>
        public static Operator ReinterpretCast
        {
            get
            {
                return Register("reinterpret_cast");
            }
        }

        /// <summary>
        /// Creates a non-virtual delegate from a method and a closure value.
        /// Said closure value's type must be a subtype of the given method's
        /// declaring type.
        /// </summary>
        public static Operator GetDelegate
        {
            get
            {
                return Register("get_delegate");
            }
        }

        /// <summary>
        /// Creates a virtual delegate from a method and a closure value.
        /// Said closure value's type must be a subtype of the given method's
        /// declaring type.
        /// </summary>
        public static Operator GetVirtualDelegate
        {
            get
            {
                return Register("get_virtual_delegate");
            }
        }

        /// <summary>
        /// Creates a non-virtual delegate from a static method and a closure value,
        /// which is the method's first parameter. Said closure value's type need not
        /// be a subtype of the given method's declaring type. The resulting delegate
        /// will have one parameter fewer than the number of parameters the
        /// method it is based on.
        /// </summary>
        public static Operator GetCurriedDelegate
        {
            get
            {
                return Register("get_curried_delegate");
            }
        }

        /// <summary>
        /// Creates a boxed version of a value.
        /// </summary>
        public static Operator Box
        {
            get
            {
                return Register("box");
            }
        }

        /// <summary>
        /// Unboxes a boxed value, and returns a reference to the value in the
        /// box. This operator cannot be applied to reference types.
        /// </summary>
        public static Operator UnboxReference
        {
            get
            {
                return Register("unbox_ref");
            }
        }

        /// <summary>
        /// Unboxes a boxed value, and returns the value in the box.
        /// This is a no-op for reference types.
        /// </summary>
        public static Operator UnboxValue
        {
            get
            {
                return Register("unbox_val");
            }
        }

        #endregion

        #endregion
    }
}
