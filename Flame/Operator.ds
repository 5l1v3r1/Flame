using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Text;

namespace Flame
{
    public struct Operator
    {
        private const this(set int32 typeIndex);
        public const this(Operator Other)
        {
            this.typeIndex = Other.typeIndex;
        }

        private int32 typeIndex;

        public bool IsDefined
        {
        	const get return typeIndex > -1;
        }

        public string Name
        {
	        const get
	        {
	        	if (typeIndex >= 0)
	        		return typeNames[typeIndex];
	        	else
	        		return null;
	        }
        }

        #region Equality

        public override const int32 GetHashCode()
        {
            return typeIndex.GetHashCode();
        }

        public override const bool Equals(object obj)
        {
            if (obj is Operator)
            {
                return ((Operator)obj).typeIndex == typeIndex;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ToString

        public override string ToString()
        {
            return Name;
        }

        #endregion

        #region Static

        #region Management

        static this()
        {
            typeNames = new List<string>();
            operatorDict = new ConcurrentDictionary<string, Operator>();
            RegisterAll(new Operator[]
            {
            	Operator.Add, Operator.Subtract,
            	Operator.Multiply, Operator.Divide, Operator.Remainder,
            	Operator.LeftShift, Operator.RightShift,
            	Operator.Or, Operator.And, Operator.Xor,
            	Operator.LogicalOr, Operator.LogicalAnd,
            	Operator.CheckEquality, Operator.CheckInequality,
            	Operator.CheckLessThan, Operator.CheckLessThanOrEqual,
            	Operator.CheckGreaterThan, Operator.CheckGreaterThanOrEqual,
            	Operator.Not, Operator.Hash, Operator.Concat,
                Operator.IsInstance, Operator.AsInstance,
                Operator.StaticCast, Operator.DynamicCast,
                Operator.ReinterpretCast,
                Operator.GetDelegate, Operator.GetVirtualDelegate,
                Operator.GetCurriedDelegate
            });
        }

        private static List<string> typeNames;
        private static ConcurrentDictionary<string, Operator> operatorDict;

        private static void RegisterAll(Operator[] Operators); // Does nothing. 'Operator' values are already registered.

        private static Operator RegisterNew(string Name)
        {
            typeNames.Add(Name);
            return new Operator(typeNames.Count - 1);
        }

        public static Operator Register(string Name)
        {
            return operatorDict.GetOrAdd(Name, RegisterNew);
        }

        public static bool IsOperator(string Operator)
        {
            return typeNames.Contains(Operator);
        }
        public static bool TryGetOperator(string OperatorName, out Operator^ Result)
        {
            return operatorDict.TryGetValue(OperatorName, Result);
        }
        public static Operator GetOperator(string OperatorName)
        {
        	if (TryGetOperator(OperatorName, &Operator result))
            {
                return result;
            }
            else
            {
                return Undefined;
            }
        }

        public static const bool IsComparisonOperator(Operator Op)
        {
        	int tIndex = Op.typeIndex;
        	return 	tIndex == Operator.CheckEquality.typeIndex || tIndex == Operator.CheckInequality.typeIndex ||
        			tIndex == Operator.CheckGreaterThan.typeIndex || tIndex == Operator.CheckGreaterThanOrEqual.typeIndex ||
        			tIndex == Operator.CheckLessThan.typeIndex || tIndex == Operator.CheckLessThanOrEqual.typeIndex;
        }

        #endregion

        #region Common Accessors

		public static Operator Undefined
		{
			const get
			{
				return new Operator(-1);
			}
		}

        public static Operator Add
        {
            const get
            {
                return Register("+");
            }
        }

        public static Operator Subtract
        {
            const get
            {
                return Register("-");
            }
        }

        public static Operator Multiply
        {
            const get
            {
                return Register("*");
            }
        }

        public static Operator Divide
        {
            const get
            {
                return Register("/");
            }
        }

        public static Operator Remainder
        {
            const get
            {
                return Register("%");
            }
        }

        public static Operator CheckEquality
        {
            const get
            {
                return Register("==");
            }
        }

        public static Operator CheckInequality
        {
            const get
            {
                return Register("!=");
            }
        }

        public static Operator CheckGreaterThan
        {
            const get
            {
                return Register(">");
            }
        }

        public static Operator CheckLessThan
        {
            const get
            {
                return Register("<");
            }
        }

        public static Operator CheckGreaterThanOrEqual
        {
            const get
            {
                return Register(">=");
            }
        }

        public static Operator CheckLessThanOrEqual
        {
            const get
            {
                return Register("<=");
            }
        }

        public static Operator Not
        {
            const get
            {
                return Register("!");
            }
        }

        public static Operator Or
        {
            const get
            {
                return Register("|");
            }
        }
        public static Operator LogicalOr
        {
            const get
            {
                return Register("||");
            }
        }

        public static Operator And
        {
            const get
            {
                return Register("&");
            }
        }
        public static Operator LogicalAnd
        {
            const get
            {
                return Register("&&");
            }
        }

        public static Operator Xor
        {
            const get
            {
                return Register("^");
            }
        }

        public static Operator LeftShift
        {
            const get
            {
                return Register("<<");
            }
        }
        public static Operator RightShift
        {
            const get
            {
                return Register(">>");
            }
        }
        public static Operator Hash
        {
        	const get
        	{
        		return Register("hash");
        	}
        }
        public static Operator Concat
        {
        	const get
        	{
        		return Register("++");
        	}
        }

        /// <summary>
        /// An operator that tests if a given reference or pointer is of a specific type,
        /// and returns a boolean.
        /// This is equivalent to the C# `is` operator.
        /// </summary>
        public static Operator IsInstance
        {
            const get
            {
                return Register("is_instance");
            }
        }

        /// <summary>
        /// An operator that returns the given given reference or pointer if it is
        /// of the given type. Otherwise, null is returned.
        /// This is equivalent to the C# `as` operator.
        /// </summary>
        public static Operator AsInstance
        {
            const get
            {
                return Register("as_instance");
            }
        }

        /// <summary>
        /// A conversion operator that converts a given value to an equivalent value
        /// of a different type. User-defined conversions overload this operator.
        /// </summary>
        /// <example>
        /// <code>
        /// double x = 3.0;
        /// double i = (int)x;
        ///            ^~~~~
        /// </code>
        /// </example>
        public static Operator StaticCast
        {
            const get
            {
                return Register("static_cast");
            }
        }

        /// <summary>
        /// Defines a dynamic cast operator, which performs a runtime check to
        /// determine if a given reference or pointer is of a given type.
        /// The given reference or pointer is returned if this is the case.
        /// Otherwise, an exception is thrown at runtime.
        /// </summary>
        public static Operator DynamicCast
        {
            const get
            {
                return Register("dynamic_cast");
            }
        }

        /// <summary>
        /// Defines a reinterpret cast operator, which converts a reference or
        /// pointer type to another reference or pointer type. The operation is
        /// assumed to always succeed, and does not require a runtime check.
        /// </summary>
        public static Operator ReinterpretCast
        {
            const get
            {
                return Register("reinterpret_cast");
            }
        }

        /// <summary>
        /// Creates a non-virtual delegate from a method and a closure value.
        /// Said closure value's type must be a subtype of the given method's
        /// declaring type.
        /// </summary>
        public static Operator GetDelegate
        {
            const get
            {
                return Register("get_delegate");
            }
        }

        /// <summary>
        /// Creates a virtual delegate from a method and a closure value.
        /// Said closure value's type must be a subtype of the given method's
        /// declaring type.
        /// </summary>
        public static Operator GetVirtualDelegate
        {
            const get
            {
                return Register("get_virtual_delegate");
            }
        }

        /// <summary>
        /// Creates a non-virtual delegate from a static method and a closure value,
        /// which is the method's first parameter. Said closure value's type need not
        /// be a subtype of the given method's declaring type. The resulting delegate
        /// will have one parameter fewer than the number of parameters the
        /// method it is based on.
        /// </summary>
        public static Operator GetCurriedDelegate
        {
            const get
            {
                return Register("get_curried_delegate");
            }
        }

        #endregion

        #endregion
    }
}
