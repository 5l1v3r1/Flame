using System;
using System.Collections.Generic;

namespace Flame
{
    /// <summary>
    /// A data structure that describes categories of pointers.
    /// </summary>
    public struct PointerKind
    {
        private const this(set int typeIndex);
        public const this(PointerKind Other)
        {
            this.typeIndex = Other.typeIndex;
        }

        private int typeIndex;

        /// <summary>
        /// Tests if this pointer kind is defined.
        /// </summary>
        public bool IsDefined
        {
            const get return typeIndex > -1;
        }

        /// <summary>
        /// Gets this pointer kind's extension.
        /// </summary>
        public string Extension
        {
            const get
            {
                if (typeIndex >= 0)
                    return typeNames[typeIndex];
                else
                    return null;
            }
        }

        /// <summary>
        /// Gets the ancestry rules for this pointer kind.
        /// </summary>
        public IPointerAncestryRules AncestryRules
        {
            get
            {
                if (typeIndex >= 0)
                    return ancRules[typeIndex];
                else
                    return null;
            }
        }

        #region Equality

        public override const int GetHashCode()
        {
            return typeIndex.GetHashCode();
        }

        public bool Equals(PointerKind Other)
        {
            return typeIndex == Other.typeIndex;
        }

        public override bool Equals(object obj)
        {
            if (obj is PointerKind)
            {
                return Equals((PointerKind)obj);
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ToString

        public override string ToString()
        {
            return Extension;
        }

        #endregion

        #region Static

        #region Management

        static this()
        {
            typeNames = new List<string>();
            ancRules = new List<IPointerAncestryRules>();
            kindDict = new Dictionary<string, PointerKind>();
            Register("*");
            Register("^");
            Register("'box");
        }

        private static List<string> typeNames;
        private static List<IPointerAncestryRules> ancRules;
        private static Dictionary<string, PointerKind> kindDict;

        private static PointerKind RegisterNew(
            string Extension, IPointerAncestryRules Rules)
        {
            typeNames.Add(Extension);
            ancRules.Add(Rules);
            var result = new PointerKind(typeNames.Count - 1);
            kindDict[Extension] = result;
            return result;
        }

        /// <summary>
        /// Registers a pointer kind with the given extension and set of pointer
        /// ancestry rules.
        /// </summary>
        public static PointerKind Register(string Extension, IPointerAncestryRules Rules)
        {
            PointerKind result;
            if (kindDict.TryGetValue(Extension, &result))
            {
                assert(result.AncestryRules.Equals(Rules));
                return result;
            }
            else
            {
                return RegisterNew(Extension, Rules);
            }
        }

        /// <summary>
        /// Registers a pointer kind with the given extension. The default
        /// set of ancestry rules is implied.
        /// </summary>
        public static PointerKind Register(string Extension)
        {
            return Register(Extension, PointerAncestryRules);
        }

        /// <summary>
        /// Checks if the given string is a pointer extension.
        /// </summary>
        public static bool IsPointerExtension(string Extension)
        {
            return kindDict.ContainsKey(Extension);
        }
        public static bool TryGetPointerKind(string TypeName, out PointerKind^ Result)
        {
            if (kindDict.TryGetValue(TypeName, Result))
            {
                return true;
            }

            for (int i = 0; i < typeNames.Count; ++i)
            {
                if (TypeName.EndsWith(typeNames[i]))
                {
                	*Result = new PointerKind(i);
                    return true;
                }
            }
            *Result = Undefined;
            return false;
        }
        public static PointerKind GetPointerKind(string TypeName)
        {
            if (TryGetPointerKind(TypeName, &PointerKind result))
            {
                return result;
            }
            else
            {
                return Undefined;
            }
        }

        #endregion

        #region Common Accessors

        public static PointerKind Undefined
        {
            const get
            {
                return new PointerKind(-1);
            }
        }

        public static PointerKind TransientPointer
        {
            get
            {
                return Register("*");
            }
        }

        public static PointerKind ReferencePointer
        {
            get
            {
                return Register("^");
            }
        }

        /// <summary>
        /// A reference to a boxed value.
        /// </summary>
        public static PointerKind BoxPointer
        {
            get
            {
                return Register("'box");
            }
        }

        #endregion

        #endregion
    }
}
