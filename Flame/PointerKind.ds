using System;
using System.Collections.Concurrent;
using System.Collections.Generic;

namespace Flame
{
    public struct PointerKind
    {
        private const this(set int32 typeIndex);
        public const this(PointerKind Other)
        {
            this.typeIndex = Other.typeIndex;
        }

        private int32 typeIndex;

        public bool IsDefined
        {
            const get return typeIndex > -1;
        }

        public string Extension
        {
            const get
            {
                if (typeIndex >= 0)
                    return typeNames[typeIndex];
                else
                    return null;
            }
        }

        #region Equality

        public override const int32 GetHashCode()
        {
            return typeIndex.GetHashCode();
        }

        public override const bool Equals(object obj)
        {
            if (obj is PointerKind)
            {
                return ((PointerKind)obj).typeIndex == typeIndex;
            }
            else
            {
                return false;
            }
        }

        #endregion

        #region ToString

        public override string ToString()
        {
            return Extension;
        }

        #endregion

        #region Static

        #region Management

        static this()
        {
            typeNames = new List<string>();
            kindDict = new ConcurrentDictionary<string, PointerKind>();
            Register("*");
            Register("^");
        }

        private static List<string> typeNames;
        private static ConcurrentDictionary<string, PointerKind> kindDict;

        private static PointerKind RegisterNew(string Extension)
        {
            typeNames.Add(Extension);
            return new PointerKind(typeNames.Count - 1);
        }

        public static PointerKind Register(string Extension)
        {
            return kindDict.GetOrAdd(Extension, RegisterNew);
        }

        public static const bool IsPointerExtension(string Extension)
        {
            return kindDict.ContainsKey(Extension);
        }
        public static bool TryGetPointerKind(string TypeName, out PointerKind^ Result)
        {
            if (kindDict.TryGetValue(TypeName, Result))
            {
                return true;
            }

            for (int i = 0; i < typeNames.Count; ++i)
            {
                if (TypeName.EndsWith(typeNames[i]))
                {
                	*Result = new PointerKind(i);
                    return true;
                }
            }
            *Result = Undefined;
            return false;
        }
        public static PointerKind GetPointerKind(string TypeName)
        {
            if (TryGetPointerKind(TypeName, &PointerKind result))
            {
                return result;
            }
            else
            {
                return Undefined;
            }
        }

        #endregion

        #region Common Accessors

        public static PointerKind Undefined
        {
            const get
            {
                return new PointerKind(-1);
            }
        }

        public static PointerKind TransientPointer
        {
            /*const*/ get // Marked not constant to avoid CTFE, which is not always supported
            {
                return Register("*");
            }
        }

        public static PointerKind ReferencePointer
        {
            /*const*/ get
            {
                return Register("^");
            }
        }

        #endregion

        #endregion
    }
}
