using System;
using System.Collections.Generic;
using Flame.Primitives;

namespace Flame
{
	using System.Collections.Generic;

	namespace Primitives
	{
		#region PrimitivesNamespace

		public static class PrimitivesNamespace : INamespace
		{
            public [IType] Types
            {
                get { return PrimitiveTypes.GetPrimitives(); }
            }

            public IAssembly DeclaringAssembly
            {
                const get { return null; }
            }

            public string Name
            {
                const get { return "System"; }
            }

            public string FullName
            {
                const get { return "System"; }
            }

            public AttributeMap Attributes
            {
                const get { return AttributeMap.Empty; }
            }

	    	public override const bool Equals(object Other)
	    	{
	    		return Other is PrimitivesNamespace;
	    	}
		}

		#endregion
	}

    public static class PrimitiveTypes
    {
    	static this()
    	{
    		int32Type = new PrimitiveNumberType<int32>("Int32", 3, default(int32), int32.MinValue, int32.MaxValue);
    		booleanType = new PrimitiveType<bool>("Boolean", 1, default(bool));
    		//stringType = new PrimitiveType<string>("String", 0 , null);
    		stringType = StringPrimitiveType;
    		PrimitiveTypes.Int8 = new PrimitiveNumberType<int8>("Int8", 1, default(int8), int8.MinValue, int8.MaxValue);
    		PrimitiveTypes.Int16 = new PrimitiveNumberType<int16>("Int16", 2, default(int16), int16.MinValue, int16.MaxValue);
    		PrimitiveTypes.Int64 = new PrimitiveNumberType<int64>("Int64", 4, default(int64), int64.MinValue, int64.MaxValue);
    		PrimitiveTypes.Bit8 = new PrimitiveType<bit8>("Bit8", 1, default(bit8));
    		PrimitiveTypes.Bit16 = new PrimitiveType<bit16>("Bit16", 2, default(bit16));
    		PrimitiveTypes.Bit32 = new PrimitiveType<bit32>("Bit32", 3, default(bit32));
    		PrimitiveTypes.Bit64 = new PrimitiveType<bit64>("Bit64", 4, default(bit64));
    		PrimitiveTypes.UInt8 = new PrimitiveNumberType<uint8>("UInt8", 1, default(uint8), uint8.MinValue, uint8.MaxValue);
    		PrimitiveTypes.UInt16 = new PrimitiveNumberType<uint16>("UInt16", 2, default(uint16), uint16.MinValue, uint16.MaxValue);
    		PrimitiveTypes.UInt32 = new PrimitiveNumberType<uint32>("UInt32", 3, default(uint32), uint32.MinValue, uint32.MaxValue);
    		PrimitiveTypes.UInt64 = new PrimitiveNumberType<uint64>("UInt64", 4, default(uint64), uint64.MinValue, uint64.MaxValue);
    		PrimitiveTypes.Float32 = new PrimitiveFloatType<float32>("Float32", 3, default(float32), float32.MinValue, float32.MaxValue, (float32)1.0 / (float32)0.0, (float32)(-1.0) / (float32)0.0);
    		PrimitiveTypes.Float64 = new PrimitiveFloatType<float64>("Float64", 4, default(float64), float64.MinValue, float64.MaxValue, 1.0 / 0.0, -1.0 / 0.0);
    		//PrimitiveTypes.Char = new PrimitiveType<char>("Char", 2, default(char));
    		PrimitiveTypes.Char = new CharPrimitiveType("Char", 2);
    		//PrimitiveTypes.Null = new PrimitiveType<object>("Null", 0, null);
    		PrimitiveTypes.Null = NullPrimitiveType;
    		PrimitiveTypes.Void = new PrimitiveType<object>("Void", 0, null);
    		PrimitiveTypes.IHashable = HashableType;
    		PrimitiveTypes.IEquatable = EquatableType;

			PrimitiveTypes.primTypes = new HashSet<IType>(new IType[]
			{
				PrimitiveTypes.Int8,
				PrimitiveTypes.Int16,
				PrimitiveTypes.Int32,
				PrimitiveTypes.Int64,
				PrimitiveTypes.Bit8,
				PrimitiveTypes.Bit16,
				PrimitiveTypes.Bit32,
				PrimitiveTypes.Bit64,
				PrimitiveTypes.UInt8,
				PrimitiveTypes.UInt16,
				PrimitiveTypes.UInt32,
				PrimitiveTypes.UInt64,
				PrimitiveTypes.Float32,
				PrimitiveTypes.Float64,
				PrimitiveTypes.Boolean,
				PrimitiveTypes.String,
				PrimitiveTypes.Char,
				PrimitiveTypes.Void
			});
    	}

    	private static IType int32Type;
    	public static IType Int32 { const get return int32Type; }

    	public static IType Int8 { const get; private set; }
    	public static IType Int16 { const get; private set; }
    	public static IType Int64 { const get; private set; }
    	public static IType Bit8 { const get; private set; }
    	public static IType Bit16 { const get; private set; }
    	public static IType Bit32 { const get; private set; }
    	public static IType Bit64 { const get; private set; }
    	public static IType UInt8 { const get; private set; }
    	public static IType UInt16 { const get; private set; }
    	public static IType UInt32 { const get; private set; }
    	public static IType UInt64 { const get; private set; }
    	public static IType Float32 { const get; private set; }
    	public static IType Float64 { const get; private set; }
    	public static IType Char { const get; private set; }

    	private static IType booleanType;
    	public static IType Boolean { const get return booleanType; }

    	private static IType stringType;
    	public static IType String { const get return stringType; }

    	public static IType Null { const get; private set; }
    	public static IType Void { const get; private set; }
    	public static IType IHashable { const get; private set; }
    	public static IType IEquatable { const get; private set; }

		private static HashSet<IType> primTypes;
		public static [IType] GetPrimitives()
		{
			return primTypes;
		}

		public static bool IsBit[this IType Type]
        {
        	const get
        	{
	            if (Type.IsPrimitive)
	            {
	                return Type.Name.StartsWith("Bit");
	            }
	            else
	            {
	            	return false;
	            }
            }
        }

        public static bool IsFloatingPoint[this IType Type]
        {
        	const get
        	{
	            if (Type.IsPrimitive)
	            {
	                return Type.Name.StartsWith("Float");
	            }
	            else
	            {
	            	return false;
	            }
            }
        }

        public static bool IsUnsignedInteger[this IType Type]
        {
        	const get
        	{
	            if (Type.IsPrimitive)
	            {
	                return Type.Name.StartsWith("UInt");
	            }
	            else
	            {
	            	return false;
	            }
            }
        }

       	public static bool IsSignedInteger[this IType Type]
        {
        	const get
        	{
	            if (Type.IsPrimitive)
	            {
	                return Type.Name.StartsWith("Int");
	            }
	            else
	            {
	            	return false;
	            }
            }
        }

        public static bool IsInteger[this IType Type]
        {
        	const get
        	{
        		return Type.IsSignedInteger || Type.IsUnsignedInteger;
        	}
        }

		public static bool IsPrimitive[this IType Type]
		{
			const get
			{
				return primTypes.Contains(Type);
			}
		}

		/// <summary>
		/// Gets the given type's primitive magnitude. The following table
		/// maps primitive magnitudes to primitives:
		/// * 4 - 64-bit primitives: float64, int64, uint64, bit64.
		/// * 3 - 32-bit primitives: float32, int32, uint32, bit32.
		/// * 2 - 16-bit primitives: int16, uint16, bit16, char.
		/// * 1 - 8-bit primitives: int8, uint8, bit8, bool.
		/// * 0 - everything else.
		/// </summary>
		public static const int GetPrimitiveMagnitude(this IType Type)
        {
            if (Type.Equals(PrimitiveTypes.Float64) || Type.Equals(PrimitiveTypes.Int64) || Type.Equals(PrimitiveTypes.UInt64) || Type.Equals(PrimitiveTypes.Bit64))
            {
                return 4;
            }
            else if (Type.Equals(PrimitiveTypes.Float32) || Type.Equals(PrimitiveTypes.Int32) || Type.Equals(PrimitiveTypes.UInt32) || Type.Equals(PrimitiveTypes.Bit32))
            {
                return 3;
            }
            else if (Type.Equals(PrimitiveTypes.Int16) || Type.Equals(PrimitiveTypes.UInt16) || Type.Equals(PrimitiveTypes.Bit16) || Type.Equals(PrimitiveTypes.Char))
            {
                return 2;
            }
            else if (Type.Equals(PrimitiveTypes.Int8) || Type.Equals(PrimitiveTypes.UInt8) || Type.Equals(PrimitiveTypes.Bit8) || Type.Equals(PrimitiveTypes.Boolean))
            {
                return 1;
            }
            else
            {
                return 0;
            }
        }

        public static int GetPrimitiveSize(this IType Type)
        {
            int magnitude = Type.GetPrimitiveMagnitude();
            if (magnitude == 0)
            {
            	return 0;
            }
            else
            {
            	return (int)Math.Pow(2, magnitude - 1);
            }
        }
	}
}
